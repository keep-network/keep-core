package tbtc

import (
	"context"
	"fmt"
	"time"

	"github.com/ipfs/go-log/v2"
	"github.com/keep-network/keep-core/pkg/protocol/group"
	"github.com/keep-network/keep-core/pkg/tecdsa/dkg"
)

// dkgResultSigner is responsible for signing the DKG result and verification of
// signatures generated by other group members.
type dkgResultSigner struct {
	chain         Chain
	dkgStartBlock uint64
}

func newDkgResultSigner(chain Chain, dkgStartBlock uint64) *dkgResultSigner {
	return &dkgResultSigner{
		chain:         chain,
		dkgStartBlock: dkgStartBlock,
	}
}

// SignResult signs the provided DKG result. It returns the information
// pertaining to the signing process: public key, signature, result hash.
func (drs *dkgResultSigner) SignResult(result *dkg.Result) (*dkg.SignedResult, error) {
	resultHash, err := drs.chain.CalculateDKGResultHash(drs.dkgStartBlock, result)
	if err != nil {
		return nil, fmt.Errorf(
			"dkg result hash calculation failed [%w]",
			err,
		)
	}

	signing := drs.chain.Signing()

	signature, err := signing.Sign(resultHash[:])
	if err != nil {
		return nil, fmt.Errorf(
			"dkg result hash signing failed [%w]",
			err,
		)
	}

	return &dkg.SignedResult{
		PublicKey:  signing.PublicKey(),
		Signature:  signature,
		ResultHash: resultHash,
	}, nil
}

// VerifySignature verifies if the signature was generated from the provided
// DKG result has using the provided public key.
func (drs *dkgResultSigner) VerifySignature(signedResult *dkg.SignedResult) (bool, error) {
	return drs.chain.Signing().VerifyWithPublicKey(
		signedResult.ResultHash[:],
		signedResult.Signature,
		signedResult.PublicKey,
	)
}

// dkgResultSubmitter is responsible for submitting the DKG result to the chain.
type dkgResultSubmitter struct {
	dkgLogger            log.StandardLogger
	chain                Chain
	groupSelectionResult *GroupSelectionResult
}

func newDkgResultSubmitter(
	dkgLogger log.StandardLogger,
	chain Chain,
	groupSelectionResult *GroupSelectionResult,
) *dkgResultSubmitter {
	return &dkgResultSubmitter{
		dkgLogger:            dkgLogger,
		chain:                chain,
		groupSelectionResult: groupSelectionResult,
	}
}

// SubmitResult submits the DKG result along with submitting signatures to the
// chain. In the process, it checks if the number of signatures is above
// the required threshold, whether the result was already submitted and waits
// until the member is eligible for DKG result submission.
func (drs *dkgResultSubmitter) SubmitResult(
	ctx context.Context,
	memberIndex group.MemberIndex,
	result *dkg.Result,
	signatures map[group.MemberIndex][]byte,
) error {
	config := drs.chain.GetConfig()

	if len(signatures) < config.GroupQuorum {
		return fmt.Errorf(
			"could not submit result with [%v] signatures for group quorum [%v]",
			len(signatures),
			config.GroupQuorum,
		)
	}

	resultSubmittedChan := make(chan uint64)

	subscription := drs.chain.OnDKGResultSubmitted(
		func(event *DKGResultSubmittedEvent) {
			resultSubmittedChan <- event.BlockNumber
		},
	)
	defer subscription.Unsubscribe()

	dkgState, err := drs.chain.GetDKGState()
	if err != nil {
		return fmt.Errorf("could not check DKG state: [%w]", err)
	}

	if dkgState != AwaitingResult {
		// Someone who was ahead of us in the queue submitted the result. Giving up.
		drs.dkgLogger.Infof(
			"[member:%v] DKG is no longer awaiting the result; "+
				"aborting DKG result submission",
			memberIndex,
		)
		return nil
	}

	submissionDelay := time.Duration(memberIndex-1) * dkgResultSubmissionDelayStep

	drs.dkgLogger.Infof(
		"[member:%v] waiting [%v] to submit",
		memberIndex,
		submissionDelay,
	)

	submissionTimer := time.NewTimer(submissionDelay)
	defer submissionTimer.Stop()

	for {
		select {
		case <-submissionTimer.C:
			// Member becomes eligible to submit the result. Result submission
			// would trigger the sender side of the result submission event
			// listener but also cause the receiver side (this select)
			// termination that will result with a dangling goroutine blocked
			// forever on the `onSubmittedResultChan` channel. This would
			// cause a resource leak. In order to avoid that, we should
			// unsubscribe from the result submission event listener before
			// submitting the result.
			subscription.Unsubscribe()

			publicKeyBytes, err := result.GroupPublicKeyBytes()
			if err != nil {
				return fmt.Errorf("cannot get public key bytes [%w]", err)
			}

			drs.dkgLogger.Infof(
				"[member:%v] submitting DKG result with public key [0x%x] and "+
					"[%v] supporting member signatures",
				memberIndex,
				publicKeyBytes,
				len(signatures),
			)

			return drs.chain.SubmitDKGResult(
				memberIndex,
				result,
				signatures,
				drs.groupSelectionResult,
			)
		case blockNumber := <-resultSubmittedChan:
			drs.dkgLogger.Infof(
				"[member:%v] leaving; DKG result submitted by other member "+
					"at block [%v]",
				memberIndex,
				blockNumber,
			)
			// A result has been submitted by other member. Leave without
			// publishing the result.
			return nil
		case <-ctx.Done():
			return fmt.Errorf("result publication timed out")
		}
	}
}
