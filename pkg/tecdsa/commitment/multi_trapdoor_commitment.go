// Package commitment implements a multi-trapdoor commitment scheme secure under
// concurrent adversary composition described by Rosario Gennaro in the
// referenced [G04] paper.
//
// The implementation is based on the the SDH assumption and uses bn256 elliptic
// curve as a group for which deciding Diffie-Hellman triplets is easy (bn256
// pairing). For a one-time signature scheme, we use ECDSA based on secp256k1
// curve. For each generated commitment a new secret and public key is generated
// and used to produce the commitment verification signature.
//
// You may consult our documentation for more details:
// docs/cryptography/trapdoor-commitments.adoc
//
//     [G04] Gennaro R. (2004) Multi-trapdoor Commitments and their
//           Applications to Non-Malleable Protocols.
package commitment

import (
	"crypto/ecdsa"
	"crypto/rand"
	"fmt"
	"math/big"

	"github.com/ethereum/go-ethereum/crypto/bn256/cloudflare"
	"github.com/ethereum/go-ethereum/crypto/secp256k1"
	"github.com/keep-network/keep-core/pkg/internal/byteutils"
)

// DecommitmentKey allows to open a commitment and verify if the value is what
// we have really committed to.
type DecommitmentKey struct {
	r         *big.Int        // D(M)
	signature *ecdsaSignature // sig = one_time_sig(C(M))
}

type ecdsaSignature struct {
	r, s *big.Int
}

// MultiTrapdoorCommitment is produced for each message we have committed to.
// It is usually revealed to the verifier immediately after it has been produced
// and lets to verify if the message revealed later by the committing party
// is really what that party has committed to.
//
// The commitment itself is not enough for a verification. In order to perform
// a verification, the interested party must receive the `DecommitmentKey`.
//
// Multi-trapdoor commitment scheme defines master trapdoor for a commitments
// family, which allows to open any commitment in that family.
// Master public key is a pair (g, h) associated with commitments family
// where `h = g^x in G`, `x` is a master trapdoor and `g` is a fixed generator
// point for an elliptic curve, so only `h` is needed which we call `masterPublicKey`.
//
// Usually the process happens in three phases:
// 1. `MasterPublicKey` is generated by verifier and passed to commiter. This
// value is used in next phases for commitment generation and verification.
// 2. `MultiTrapdoorCommitment` is evaluated and sent to verifier and then, after
// some time, secret value along with a `DecommitmentKey` is revealed and sent to
// the verifier.
// 3. The verifier can check the secret value against the
// commitment received earlier. The verification involves re-computing and
// comparing the commitment with the one published earlier as well as checking
// the commitment signature.
type MultiTrapdoorCommitment struct {
	commitment      *bn256.G2        // C(M)
	verificationKey *ecdsa.PublicKey // vk
}

// Generate evaluates a commitment and a decommitment key with specific master
// public key for the secret messages provided as an argument.
func Generate(
	masterPublicKey *bn256.G2, // h
	secrets ...[]byte,
) (*MultiTrapdoorCommitment, *DecommitmentKey, error) {
	secret := toSingleByteSlice(secrets...)

	// sk
	signatureSecretKey, err := ecdsa.GenerateKey(secp256k1.S256(), rand.Reader)
	if err != nil {
		return nil, nil, fmt.Errorf(
			"could not generate multi-trapdoor commitment [%v]", err,
		)
	}
	// vk
	signatureVerificationKey := &signatureSecretKey.PublicKey

	// pk = H(vk)
	commitmentPublicKey := hashPublicSignatureKey(signatureVerificationKey)

	// Generate a decommitment key
	r, _, err := bn256.RandomG1(rand.Reader)
	if err != nil {
		return nil, nil, err
	}

	hash := byteutils.Sha256Sum(secret)
	digest := new(big.Int).Mod(hash, bn256.Order)

	// he = h + g^pk
	he := new(bn256.G2).Add(masterPublicKey, new(bn256.G2).ScalarBaseMult(commitmentPublicKey))

	// commitment = g^digest + he^r
	commitment := new(bn256.G2).Add(
		new(bn256.G2).ScalarBaseMult(digest),
		new(bn256.G2).ScalarMult(he, r),
	)

	// sig = sk.sign(commitment)
	signatureR, signatureS, err := ecdsa.Sign(
		rand.Reader, signatureSecretKey, commitment.Marshal(),
	)
	if err != nil {
		return nil, nil, fmt.Errorf(
			"could not generate multi-trapdoor commitment [%v]", err,
		)
	}
	signature := &ecdsaSignature{r: signatureR, s: signatureS}

	return &MultiTrapdoorCommitment{
			commitment:      commitment,
			verificationKey: signatureVerificationKey,
		},
		&DecommitmentKey{
			r:         r,
			signature: signature,
		},
		nil
}

// Verify checks the received commitment against the revealed secret message.
func (tc *MultiTrapdoorCommitment) Verify(
	masterPublicKey *bn256.G2, // h
	decommitmentKey *DecommitmentKey,
	secrets ...[]byte,
) bool {
	secret := toSingleByteSlice(secrets...)

	hash := byteutils.Sha256Sum(secret)
	digest := new(big.Int).Mod(hash, bn256.Order)

	// pk = H(vk)
	commitmentPublicKey := hashPublicSignatureKey(tc.verificationKey)

	// a = g^r
	a := new(bn256.G1).ScalarBaseMult(decommitmentKey.r)

	// b = h + g^pk
	b := new(bn256.G2).Add(masterPublicKey, new(bn256.G2).ScalarBaseMult(commitmentPublicKey))

	// c = commitment + g^(-digest)
	c := new(bn256.G2).Add(
		tc.commitment,
		new(bn256.G2).Neg(new(bn256.G2).ScalarBaseMult(digest)),
	)

	// Get the base curve point `g`
	g := new(bn256.G1).ScalarBaseMult(big.NewInt(1))

	if bn256.Pair(a, b).String() != bn256.Pair(g, c).String() {
		return false
	}

	if !ecdsa.Verify(
		tc.verificationKey,
		tc.commitment.Marshal(),
		decommitmentKey.signature.r,
		decommitmentKey.signature.s,
	) {
		return false
	}

	return true
}

func hashPublicSignatureKey(publicSignatureKey *ecdsa.PublicKey) *big.Int {
	return new(big.Int).Mod(
		byteutils.Sha256Sum(toSingleByteSlice(
			publicSignatureKey.X.Bytes(),
			publicSignatureKey.Y.Bytes(),
		)),
		publicSignatureKey.Params().N,
	)
}

func toSingleByteSlice(slices ...[]byte) []byte {
	var combined []byte
	for _, slice := range slices {
		combined = append(combined, slice...)
	}
	return combined
}
