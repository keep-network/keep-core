package dkg

import (
	"context"
	"fmt"

	"github.com/bnb-chain/tss-lib/tss"
	"github.com/keep-network/keep-core/pkg/crypto/ephemeral"
	"github.com/keep-network/keep-core/pkg/protocol/group"
)

// generateEphemeralKeyPair takes the group member list and generates an
// ephemeral ECDH keypair for every other group member. Generated public
// ephemeral keys are broadcasted within the group.
func (ekpgm *ephemeralKeyPairGeneratingMember) generateEphemeralKeyPair() (
	*ephemeralPublicKeyMessage,
	error,
) {
	ephemeralKeys := make(map[group.MemberIndex]*ephemeral.PublicKey)

	// Calculate ephemeral key pair for every other group member
	for _, member := range ekpgm.group.MemberIDs() {
		if member == ekpgm.id {
			// donâ€™t actually generate a key with ourselves
			continue
		}

		ephemeralKeyPair, err := ephemeral.GenerateKeyPair()
		if err != nil {
			return nil, err
		}

		// save the generated ephemeral key to our state
		ekpgm.ephemeralKeyPairs[member] = ephemeralKeyPair

		// store the public key to the map for the message
		ephemeralKeys[member] = ephemeralKeyPair.PublicKey
	}

	return &ephemeralPublicKeyMessage{
		senderID:            ekpgm.id,
		ephemeralPublicKeys: ephemeralKeys,
		sessionID:           ekpgm.sessionID,
	}, nil
}

// generateSymmetricKeys attempts to generate symmetric keys for all remote group
// members via ECDH. It generates this symmetric key for each remote group member
// by doing an ECDH between the ephemeral private key generated for a remote
// group member, and the public key for this member, generated and broadcasted by
// the remote group member.
func (skgm *symmetricKeyGeneratingMember) generateSymmetricKeys(
	ephemeralPubKeyMessages []*ephemeralPublicKeyMessage,
) error {
	for _, ephemeralPubKeyMessage := range ephemeralPubKeyMessages {
		otherMember := ephemeralPubKeyMessage.senderID

		if !skgm.isValidEphemeralPublicKeyMessage(ephemeralPubKeyMessage) {
			return fmt.Errorf(
				"member [%v] sent invalid ephemeral public key message",
				otherMember,
			)
		}

		// Find the ephemeral key pair generated by this group member for
		// the other group member.
		ephemeralKeyPair, ok := skgm.ephemeralKeyPairs[otherMember]
		if !ok {
			return fmt.Errorf(
				"ephemeral key pair does not exist for member [%v]",
				otherMember,
			)
		}

		// Get the ephemeral private key generated by this group member for
		// the other group member.
		thisMemberEphemeralPrivateKey := ephemeralKeyPair.PrivateKey

		// Get the ephemeral public key broadcasted by the other group member,
		// which was intended for this group member.
		otherMemberEphemeralPublicKey :=
			ephemeralPubKeyMessage.ephemeralPublicKeys[skgm.id]

		// Create symmetric key for the current group member and the other
		// group member by ECDH'ing the public and private key.
		symmetricKey := thisMemberEphemeralPrivateKey.Ecdh(
			otherMemberEphemeralPublicKey,
		)
		skgm.symmetricKeys[otherMember] = symmetricKey
	}

	return nil
}

// isValidEphemeralPublicKeyMessage validates a given EphemeralPublicKeyMessage.
// Message is considered valid if it contains ephemeral public keys for
// all other group members.
func (skgm *symmetricKeyGeneratingMember) isValidEphemeralPublicKeyMessage(
	message *ephemeralPublicKeyMessage,
) bool {
	for _, memberID := range skgm.group.MemberIDs() {
		if memberID == message.senderID {
			// Message contains ephemeral public keys only for other group members
			continue
		}

		if _, ok := message.ephemeralPublicKeys[memberID]; !ok {
			skgm.logger.Warningf(
				"[member:%v] ephemeral public key message from member [%v] "+
					"does not contain public key for member [%v]",
				skgm.id,
				message.senderID,
				memberID,
			)
			return false
		}
	}

	return true
}

// tssRoundOne starts the TSS process by executing its first round. The
// outcome of that round is a message containing commitments and Paillier
// public keys for all other group members.
func (trom *tssRoundOneMember) tssRoundOne(
	ctx context.Context,
) (*tssRoundOneMessage, error) {
	if err := trom.tssParty.Start(); err != nil {
		return nil, fmt.Errorf(
			"failed to start TSS round one: [%v]",
			err,
		)
	}

	// We expect exactly one TSS message to be produced in this phase.
	select {
	case tssMessage := <-trom.tssOutgoingMessagesChan:
		tssMessageBytes, _, err := tssMessage.WireBytes()
		if err != nil {
			return nil, fmt.Errorf(
				"failed to encode TSS round one message: [%v]",
				err,
			)
		}

		return &tssRoundOneMessage{
			senderID:  trom.id,
			payload:   tssMessageBytes,
			sessionID: trom.sessionID,
		}, nil
	case <-ctx.Done():
		return nil, fmt.Errorf(
			"TSS round one outgoing message was not generated on time",
		)
	}
}

// tssRoundTwo performs the second round of the TSS process. The outcome of
// that round is a message containing shares and de-commitments for all other
// group members.
func (trtm *tssRoundTwoMember) tssRoundTwo(
	ctx context.Context,
	tssRoundOneMessages []*tssRoundOneMessage,
) (*tssRoundTwoMessage, error) {
	// Use messages from round one to update the local party and advance
	// to round two.
	for _, tssRoundOneMessage := range tssRoundOneMessages {
		senderID := tssRoundOneMessage.SenderID()

		_, tssErr := trtm.tssParty.UpdateFromBytes(
			tssRoundOneMessage.payload,
			resolveSortedTssPartyID(trtm.tssParameters, senderID),
			true,
		)
		if tssErr != nil {
			return nil, fmt.Errorf(
				"cannot update using TSS round one message "+
					"from member [%v]: [%v]",
				senderID,
				tssErr,
			)
		}
	}

	// Listen for TSS outgoing messages. We expect N-1 P2P messages (where N
	// is the number of properly operating members) carrying shares and 1
	// broadcast message holding the de-commitments.
	var tssMessages []tss.Message
outgoingMessagesLoop:
	for {
		select {
		case tssMessage := <-trtm.tssOutgoingMessagesChan:
			tssMessages = append(tssMessages, tssMessage)

			if len(tssMessages) == len(trtm.group.OperatingMemberIDs()) {
				break outgoingMessagesLoop
			}
		case <-ctx.Done():
			return nil, fmt.Errorf(
				"TSS round two outgoing messages were not " +
					"generated on time",
			)
		}
	}

	// Assemble all TSS outgoing messages into a single composite message.
	compositeMessage := &tssRoundTwoMessage{
		senderID:         trtm.id,
		broadcastPayload: nil,
		peersPayload:     make(map[group.MemberIndex][]byte),
		sessionID:        trtm.sessionID,
	}
	for _, tssMessage := range tssMessages {
		tssMessageBytes, tssMessageRouting, err := tssMessage.WireBytes()
		if err != nil {
			return nil, fmt.Errorf(
				"failed to encode TSS round two message: [%v]",
				err,
			)
		}

		if tssMessageRouting.IsBroadcast {
			// We expect only one broadcast message. Any other case is an error.
			if len(compositeMessage.broadcastPayload) > 0 {
				return nil, fmt.Errorf(
					"multiple TSS round two broadcast messages detected",
				)
			}

			compositeMessage.broadcastPayload = tssMessageBytes
		} else {
			// We expect that each P2P message targets only a single member.
			// Any other case is an error.
			if len(tssMessageRouting.To) != 1 {
				return nil, fmt.Errorf(
					"TSS round two multi-receiver P2P message detected",
				)
			}
			// Get the single receiver ID.
			receiverID := tssPartyIDToMemberID(tssMessageRouting.To[0])
			// Get the symmetric key with the receiver. If the symmetric key
			// cannot be found, something awful happened.
			symmetricKey, ok := trtm.symmetricKeys[receiverID]
			if !ok {
				return nil, fmt.Errorf(
					"cannot get symmetric key with member [%v]",
					receiverID,
				)
			}
			// Encrypt the payload using the receiver symmetric key.
			encryptedTssMessageBytes, err := symmetricKey.Encrypt(
				tssMessageBytes,
			)
			if err != nil {
				return nil, fmt.Errorf(
					"cannot encrypt TSS round two "+
						"P2P message for member [%v]: [%v]",
					receiverID,
					err,
				)
			}

			compositeMessage.peersPayload[receiverID] = encryptedTssMessageBytes
		}
	}

	// Just a sanity check at the end of processing.
	isMessageOk := len(compositeMessage.broadcastPayload) > 0 &&
		len(compositeMessage.peersPayload) == len(trtm.group.OperatingMemberIDs())-1
	if !isMessageOk {
		return nil, fmt.Errorf("cannot produce a proper TSS round two message")
	}

	return compositeMessage, nil
}

// tssRoundThree performs the third round of the TSS process. The outcome of
// that round is a message containing Paillier proofs for all other group
// members.
func (trtm *tssRoundTwoMember) tssRoundThree(
	ctx context.Context,
	tssRoundTwoMessages []*tssRoundTwoMessage,
) (*tssRoundThreeMessage, error) {
	// Use messages from round two to update the local party and advance
	// to round three.
	for _, tssRoundTwoMessage := range tssRoundTwoMessages {
		senderID := tssRoundTwoMessage.SenderID()
		senderTssPartyID := resolveSortedTssPartyID(trtm.tssParameters, senderID)

		// Update the local TSS party using the broadcast part of the message
		// produced in round two.
		_, tssErr := trtm.tssParty.UpdateFromBytes(
			tssRoundTwoMessage.broadcastPayload,
			senderTssPartyID,
			true,
		)
		if tssErr != nil {
			return nil, fmt.Errorf(
				"cannot update using the broadcast part of the "+
					"TSS round two message from member [%v]: [%v]",
				senderID,
				tssErr,
			)
		}

		// Check if the sender produced a P2P part of the TSS round two message
		// for this member.
		encryptedPeerPayload, ok := tssRoundTwoMessage.peersPayload[trtm.id]
		if !ok {
			return nil, fmt.Errorf(
				"no P2P part in the TSS round two message from member [%v]",
				senderID,
			)
		}
		// Get the symmetric key with the sender. If the symmetric key
		// cannot be found, something awful happened.
		symmetricKey, ok := trtm.symmetricKeys[senderID]
		if !ok {
			return nil, fmt.Errorf(
				"cannot get symmetric key with member [%v]",
				senderID,
			)
		}
		// Decrypt the P2P part of the TSS round two message.
		peerPayload, err := symmetricKey.Decrypt(encryptedPeerPayload)
		if err != nil {
			return nil, fmt.Errorf(
				"cannot decrypt P2P part of the TSS round two "+
					"message from member [%v]: [%v]",
				senderID,
				err,
			)
		}
		// Update the local TSS party using the P2P part of the message
		// produced in round two.
		_, tssErr = trtm.tssParty.UpdateFromBytes(
			peerPayload,
			senderTssPartyID,
			false,
		)
		if tssErr != nil {
			return nil, fmt.Errorf(
				"cannot update using the P2P part of the TSS round "+
					"two message from member [%v]: [%v]",
				senderID,
				tssErr,
			)
		}
	}

	// We expect exactly one TSS message to be produced in this phase.
	select {
	case tssMessage := <-trtm.tssOutgoingMessagesChan:
		tssMessageBytes, _, err := tssMessage.WireBytes()
		if err != nil {
			return nil, fmt.Errorf(
				"failed to encode TSS round one message: [%v]",
				err,
			)
		}

		return &tssRoundThreeMessage{
			senderID:  trtm.id,
			payload:   tssMessageBytes,
			sessionID: trtm.sessionID,
		}, nil
	case <-ctx.Done():
		return nil, fmt.Errorf(
			"TSS round three outgoing message was not generated on time",
		)
	}
}

// tssFinalize finalizes the TSS process by producing a result.
func (fm *finalizingMember) tssFinalize(
	ctx context.Context,
	tssRoundThreeMessages []*tssRoundThreeMessage,
) error {
	// Use messages from round three to update the local party and get the
	// result.
	for _, tssRoundThreeMessage := range tssRoundThreeMessages {
		senderID := tssRoundThreeMessage.SenderID()

		_, tssErr := fm.tssParty.UpdateFromBytes(
			tssRoundThreeMessage.payload,
			resolveSortedTssPartyID(fm.tssParameters, senderID),
			true,
		)
		if tssErr != nil {
			return fmt.Errorf(
				"cannot update using TSS round three message "+
					"from member [%v]: [%v]",
				senderID,
				tssErr,
			)
		}
	}

	select {
	case tssResult := <-fm.tssResultChan:
		fm.tssResult = tssResult
		return nil
	case <-ctx.Done():
		return fmt.Errorf(
			"TSS result was not generated on time",
		)
	}
}
