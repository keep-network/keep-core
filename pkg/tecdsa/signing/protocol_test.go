package signing

import (
	"context"
	"crypto/ecdsa"
	"encoding/hex"
	"fmt"
	"github.com/bnb-chain/tss-lib/common"
	"github.com/bnb-chain/tss-lib/tss"
	"github.com/keep-network/keep-core/pkg/crypto/ephemeral"
	"github.com/keep-network/keep-core/pkg/internal/tecdsatest"
	"github.com/keep-network/keep-core/pkg/internal/testutils"
	"github.com/keep-network/keep-core/pkg/protocol/group"
	"github.com/keep-network/keep-core/pkg/tecdsa"
	"math/big"
	"reflect"
	"strings"
	"testing"
	"time"
)

// TODO: This file contains unit tests that stress each protocol phase
//       separately. We should also develop integration tests checking the
//       whole signing protocol.

const (
	groupSize          = 3
	dishonestThreshold = 0
	sessionID          = "session-1"
)

func TestGenerateEphemeralKeyPair(t *testing.T) {
	members, err := initializeEphemeralKeyPairGeneratingMembersGroup(
		dishonestThreshold,
		groupSize,
	)
	if err != nil {
		t.Fatal(err)
	}

	// Generate ephemeral key pairs for each group member.
	messages := make(map[group.MemberIndex]*ephemeralPublicKeyMessage)
	for _, member := range members {
		message, err := member.generateEphemeralKeyPair()
		if err != nil {
			t.Fatal(err)
		}
		messages[member.id] = message
	}

	// Assert that each member has a correct state.
	for _, member := range members {
		// Assert the right key pairs count is stored in the member's state.
		expectedKeyPairsCount := groupSize - 1
		actualKeyPairsCount := len(member.ephemeralKeyPairs)
		testutils.AssertIntsEqual(
			t,
			fmt.Sprintf(
				"number of stored ephemeral key pairs for member [%v]",
				member.id,
			),
			expectedKeyPairsCount,
			actualKeyPairsCount,
		)

		// Assert the member does not hold a key pair with itself.
		_, ok := member.ephemeralKeyPairs[member.id]
		if ok {
			t.Errorf(
				"[member:%v] found ephemeral key pair generated to self",
				member.id,
			)
		}

		// Assert key pairs are non-nil.
		for otherMemberID, keyPair := range member.ephemeralKeyPairs {
			if keyPair == nil {
				t.Errorf(
					"[member:%v] key pair not set for member [%v]",
					member.id,
					otherMemberID,
				)
			}

			if keyPair.PrivateKey == nil {
				t.Errorf(
					"[member:%v] key pair's private key not set for member [%v]",
					member.id,
					otherMemberID,
				)
			}

			if keyPair.PublicKey == nil {
				t.Errorf(
					"[member:%v] key pair's public key not set for member [%v]",
					member.id,
					otherMemberID,
				)
			}
		}
	}

	// Assert that each message is formed correctly.
	for memberID, message := range messages {
		// We should always be the sender of our own messages.
		testutils.AssertIntsEqual(
			t,
			"message sender",
			int(memberID),
			int(message.senderID),
		)

		testutils.AssertIntsEqual(
			t,
			"ephemeral public keys count",
			groupSize-1,
			len(message.ephemeralPublicKeys),
		)

		// We should not generate an ephemeral key for ourselves.
		_, ok := message.ephemeralPublicKeys[memberID]
		if ok {
			t.Errorf("found ephemeral key generated to self")
		}

		// We should always use the proper session ID.
		testutils.AssertStringsEqual(
			t,
			fmt.Sprintf(
				"session ID in message generated by member [%v]",
				memberID,
			),
			sessionID,
			message.sessionID,
		)
	}
}

func TestGenerateSymmetricKeys(t *testing.T) {
	members, messages, err := initializeSymmetricKeyGeneratingMembersGroup(
		dishonestThreshold,
		groupSize,
	)
	if err != nil {
		t.Fatal(err)
	}

	// Generate symmetric keys for each group member.
	for _, member := range members {
		var receivedMessages []*ephemeralPublicKeyMessage
		for _, message := range messages {
			if message.senderID != member.id {
				receivedMessages = append(receivedMessages, message)
			}
		}

		err := member.generateSymmetricKeys(receivedMessages)
		if err != nil {
			t.Fatal(err)
		}
	}

	// Assert that each member has a correct state.
	for _, member := range members {
		// Assert the right keys count is stored in the member's state.
		expectedKeysCount := groupSize - 1
		actualKeysCount := len(member.symmetricKeys)
		testutils.AssertIntsEqual(
			t,
			fmt.Sprintf(
				"number of stored symmetric keys for member [%v]",
				member.id,
			),
			expectedKeysCount,
			actualKeysCount,
		)

		// Assert all symmetric keys stored by this member are correct.
		for otherMemberID, actualKey := range member.symmetricKeys {
			var otherMemberEphemeralPublicKey *ephemeral.PublicKey
			for _, message := range messages {
				if message.senderID == otherMemberID {
					if ephemeralPublicKey, ok := message.ephemeralPublicKeys[member.id]; ok {
						otherMemberEphemeralPublicKey = ephemeralPublicKey
					}
				}
			}

			if otherMemberEphemeralPublicKey == nil {
				t.Errorf(
					"[member:%v] no ephemeral public key from member [%v]",
					member.id,
					otherMemberID,
				)
			}

			expectedKey := ephemeral.SymmetricKey(
				member.ephemeralKeyPairs[otherMemberID].PrivateKey.Ecdh(
					otherMemberEphemeralPublicKey,
				),
			)

			if !reflect.DeepEqual(
				expectedKey,
				actualKey,
			) {
				t.Errorf(
					"[member:%v] wrong symmetric key for member [%v]",
					member.id,
					otherMemberID,
				)
			}
		}
	}
}

func TestGenerateSymmetricKeys_InvalidEphemeralPublicKeyMessage(t *testing.T) {
	members, messages, err := initializeSymmetricKeyGeneratingMembersGroup(
		dishonestThreshold,
		groupSize,
	)
	if err != nil {
		t.Fatal(err)
	}

	// Corrupt the message sent by member 2 by removing the ephemeral
	// public key generated for member 3.
	misbehavingMemberID := group.MemberIndex(2)
	delete(messages[misbehavingMemberID-1].ephemeralPublicKeys, 3)

	// Generate symmetric keys for each group member.
	for _, member := range members {
		var receivedMessages []*ephemeralPublicKeyMessage
		for _, message := range messages {
			if message.senderID != member.id {
				receivedMessages = append(receivedMessages, message)
			}
		}

		err := member.generateSymmetricKeys(receivedMessages)

		var expectedErr error
		// The misbehaved member should not get an error.
		if member.id != misbehavingMemberID {
			expectedErr = fmt.Errorf(
				"member [%v] sent invalid ephemeral "+
					"public key message",
				misbehavingMemberID,
			)
		}

		if !reflect.DeepEqual(expectedErr, err) {
			t.Errorf(
				"unexpected error\nexpected: %v\nactual:   %v\n",
				expectedErr,
				err,
			)
		}
	}
}

func TestTssRoundOne(t *testing.T) {
	members, err := initializeTssRoundOneMembersGroup(
		dishonestThreshold,
		groupSize,
	)
	if err != nil {
		t.Fatal(err)
	}

	// Perform TSS round one for each group member.
	messages := make(map[group.MemberIndex]*tssRoundOneMessage)
	for _, member := range members {
		ctx, cancelCtx := context.WithTimeout(
			context.Background(),
			10*time.Second,
		)

		tssRoundOneMessage, err := member.tssRoundOne(ctx)
		if err != nil {
			cancelCtx()
			t.Fatal(err)
		}
		messages[member.id] = tssRoundOneMessage

		cancelCtx()
	}

	// Assert that each member has a correct state.
	for _, member := range members {
		if !strings.Contains(member.tssParty.String(), "round: 1") {
			t.Errorf("wrong round number for member [%v]", member.id)
		}
	}

	// Assert that each message is formed correctly.
	for memberID, message := range messages {
		assertOutgoingMessageGeneralParameters(
			t,
			message.senderID,
			message.sessionID,
			memberID,
		)

		assertOutgoingMessageBroadcastPayload(
			t,
			message.broadcastPayload,
			memberID,
		)

		assertOutgoingMessagePeersPayload(
			t,
			message.peersPayload,
			memberID,
			members[memberID-1].symmetricKeys,
		)
	}
}

func TestTssRoundOne_OutgoingMessageTimeout(t *testing.T) {
	members, err := initializeTssRoundOneMembersGroup(
		dishonestThreshold,
		groupSize,
	)
	if err != nil {
		t.Fatal(err)
	}

	// Perform TSS round one for each group member.
	for _, member := range members {
		// To simulate the outgoing message timeout we do two things:
		// - we pass an already cancelled context
		// - we make sure no message is emitted from the channel by overwriting
		//   the existing channel with a new one that won't receive any
		//   messages from the underlying TSS local party
		ctx, cancelCtx := context.WithCancel(context.Background())
		cancelCtx()
		member.tssOutgoingMessagesChan = make(<-chan tss.Message)

		_, err := member.tssRoundOne(ctx)

		expectedErr := fmt.Errorf(
			"TSS round one outgoing messages were not generated on time",
		)
		if !reflect.DeepEqual(expectedErr, err) {
			t.Errorf(
				"unexpected error for member [%v]\n"+
					"expected: %v\n"+
					"actual:   %v\n",
				member.id,
				expectedErr,
				err,
			)
		}
	}
}

func TestTssRoundOne_SymmetricKeyMissing(t *testing.T) {
	members, err := initializeTssRoundOneMembersGroup(
		dishonestThreshold,
		groupSize,
	)
	if err != nil {
		t.Fatal(err)
	}

	// Perform TSS round one for each group member.
	for _, member := range members {
		// Cleanup symmetric key cache.
		member.symmetricKeys = make(map[group.MemberIndex]ephemeral.SymmetricKey)

		ctx, cancelCtx := context.WithTimeout(context.Background(), 10*time.Second)

		_, err := member.tssRoundOne(ctx)

		if !strings.Contains(
			err.Error(),
			"cannot get symmetric key with member",
		) {
			t.Errorf("wrong error for member [%v]: [%v]", member.id, err)
		}

		cancelCtx()
	}
}

func TestTssRoundTwo(t *testing.T) {
	members, tssRoundOneMessages, err := initializeTssRoundTwoMembersGroup(
		dishonestThreshold,
		groupSize,
	)
	if err != nil {
		t.Fatal(err)
	}

	// Perform TSS round two for each group member.
	tssRoundTwoMessages := make(map[group.MemberIndex]*tssRoundTwoMessage)
	for _, member := range members {
		var receivedTssRoundOneMessages []*tssRoundOneMessage
		for _, tssRoundOneMessage := range tssRoundOneMessages {
			if tssRoundOneMessage.senderID != member.id {
				receivedTssRoundOneMessages = append(
					receivedTssRoundOneMessages,
					tssRoundOneMessage,
				)
			}
		}

		ctx, cancelCtx := context.WithTimeout(
			context.Background(),
			10*time.Second,
		)

		tssRoundTwoMessage, err := member.tssRoundTwo(
			ctx,
			receivedTssRoundOneMessages,
		)
		if err != nil {
			cancelCtx()
			t.Fatal(err)
		}
		tssRoundTwoMessages[member.id] = tssRoundTwoMessage

		cancelCtx()
	}

	// Assert that each member has a correct state.
	for _, member := range members {
		if !strings.Contains(member.tssParty.String(), "round: 2") {
			t.Errorf("wrong round number for member [%v]", member.id)
		}
	}

	// Assert that each message is formed correctly.
	for memberID, message := range tssRoundTwoMessages {
		assertOutgoingMessageGeneralParameters(
			t,
			message.senderID,
			message.sessionID,
			memberID,
		)

		assertOutgoingMessagePeersPayload(
			t,
			message.peersPayload,
			memberID,
			members[memberID-1].symmetricKeys,
		)
	}
}

func TestTssRoundTwo_IncomingMessageCorrupted_WrongBroadcastPayload(t *testing.T) {
	members, messages, err := initializeTssRoundTwoMembersGroup(
		dishonestThreshold,
		groupSize,
	)
	if err != nil {
		t.Fatal(err)
	}

	corruptedPayload, err := hex.DecodeString("ffeeaabb")
	if err != nil {
		t.Fatal(err)
	}

	// Perform TSS round two for each group member.
	for _, member := range members {
		var receivedMessages []*tssRoundOneMessage
		for _, message := range messages {
			if message.senderID != member.id {
				// Corrupt the message's broadcast payload.
				message.broadcastPayload = corruptedPayload
				receivedMessages = append(receivedMessages, message)
			}
		}

		ctx, cancelCtx := context.WithTimeout(context.Background(), 10*time.Second)

		_, err := member.tssRoundTwo(ctx, receivedMessages)

		if !strings.Contains(
			err.Error(),
			"cannot update using the broadcast part of the TSS round one message",
		) {
			t.Errorf("wrong error for member [%v]: [%v]", member.id, err)
		}

		cancelCtx()
	}
}

func TestTssRoundTwo_IncomingMessageCorrupted_UndecryptablePeerPayload(t *testing.T) {
	members, messages, err := initializeTssRoundTwoMembersGroup(
		dishonestThreshold,
		groupSize,
	)
	if err != nil {
		t.Fatal(err)
	}

	corruptedPayload, err := hex.DecodeString("ffeeaabb")
	if err != nil {
		t.Fatal(err)
	}

	// Perform TSS round two for each group member.
	for _, member := range members {
		var receivedMessages []*tssRoundOneMessage
		for _, message := range messages {
			if message.senderID != member.id {
				// Make the P2P undecryptable by setting an arbitrary value
				// as ciphertext.
				corruptedPeersPayload := make(map[group.MemberIndex][]byte)
				for receiverID := range message.peersPayload {
					corruptedPeersPayload[receiverID] = corruptedPayload
				}
				message.peersPayload = corruptedPeersPayload
				receivedMessages = append(receivedMessages, message)
			}
		}

		ctx, cancelCtx := context.WithTimeout(context.Background(), 10*time.Second)

		_, err := member.tssRoundTwo(ctx, receivedMessages)

		if !strings.Contains(
			err.Error(),
			"cannot decrypt P2P part of the TSS round one message",
		) {
			t.Errorf("wrong error for member [%v]: [%v]", member.id, err)
		}

		cancelCtx()
	}
}

func TestTssRoundTwo_IncomingMessageCorrupted_WrongPeerPayload(t *testing.T) {
	members, messages, err := initializeTssRoundTwoMembersGroup(
		dishonestThreshold,
		groupSize,
	)
	if err != nil {
		t.Fatal(err)
	}

	corruptedPayload, err := hex.DecodeString("ffeeaabb")
	if err != nil {
		t.Fatal(err)
	}

	// Perform TSS round two for each group member.
	for _, member := range members {
		var receivedMessages []*tssRoundOneMessage
		for _, message := range messages {
			if message.senderID != member.id {
				// Corrupt the message's peers payload by encrypting an
				// arbitrary value.
				corruptedPeersPayload := make(map[group.MemberIndex][]byte)
				for receiverID := range message.peersPayload {
					symmetricKey := members[message.senderID-1].symmetricKeys[receiverID]
					encryptedCorruptedPayload, err := symmetricKey.Encrypt(corruptedPayload)
					if err != nil {
						t.Fatal(err)
					}
					corruptedPeersPayload[receiverID] = encryptedCorruptedPayload
				}
				message.peersPayload = corruptedPeersPayload
				receivedMessages = append(receivedMessages, message)
			}
		}

		ctx, cancelCtx := context.WithTimeout(context.Background(), 10*time.Second)

		_, err := member.tssRoundTwo(ctx, receivedMessages)

		if !strings.Contains(
			err.Error(),
			"cannot update using the P2P part of the TSS round one message",
		) {
			t.Errorf("wrong error for member [%v]: [%v]", member.id, err)
		}

		cancelCtx()
	}
}

func TestTssRoundTwo_IncomingMessageMissing(t *testing.T) {
	members, messages, err := initializeTssRoundTwoMembersGroup(
		dishonestThreshold,
		groupSize,
	)
	if err != nil {
		t.Fatal(err)
	}

	// Perform TSS round two for each group member.
	for _, member := range members {
		var receivedMessages []*tssRoundOneMessage
		for _, message := range messages {
			if message.senderID != member.id {
				receivedMessages = append(receivedMessages, message)
			}
		}

		ctx, cancelCtx := context.WithTimeout(context.Background(), 1*time.Second)
		// Pass only one incoming message from TSS round one for processing.
		_, err := member.tssRoundTwo(ctx, receivedMessages[:1])

		expectedErr := fmt.Errorf(
			"TSS round two outgoing messages were not generated on time",
		)
		if !reflect.DeepEqual(expectedErr, err) {
			t.Errorf(
				"unexpected error for member [%v]\n"+
					"expected: %v\n"+
					"actual:   %v\n",
				member.id,
				expectedErr,
				err,
			)
		}

		cancelCtx()
	}
}

func TestTssRoundTwo_OutgoingMessageTimeout(t *testing.T) {
	members, messages, err := initializeTssRoundTwoMembersGroup(
		dishonestThreshold,
		groupSize,
	)
	if err != nil {
		t.Fatal(err)
	}

	// Perform TSS round two for each group member.
	for _, member := range members {
		var receivedMessages []*tssRoundOneMessage
		for _, message := range messages {
			if message.senderID != member.id {
				receivedMessages = append(receivedMessages, message)
			}
		}

		// To simulate the outgoing message timeout we do two things:
		// - we pass an already cancelled context
		// - we make sure no message is emitted from the channel by overwriting
		//   the existing channel with a new one that won't receive any
		//   messages from the underlying TSS local party
		ctx, cancelCtx := context.WithCancel(context.Background())
		cancelCtx()
		member.tssOutgoingMessagesChan = make(<-chan tss.Message)

		_, err := member.tssRoundTwo(ctx, receivedMessages)

		expectedErr := fmt.Errorf(
			"TSS round two outgoing messages were not generated on time",
		)
		if !reflect.DeepEqual(expectedErr, err) {
			t.Errorf(
				"unexpected error for member [%v]\n"+
					"expected: %v\n"+
					"actual:   %v\n",
				member.id,
				expectedErr,
				err,
			)
		}
	}
}

func TestTssRoundTwo_SymmetricKeyMissing(t *testing.T) {
	members, messages, err := initializeTssRoundTwoMembersGroup(
		dishonestThreshold,
		groupSize,
	)
	if err != nil {
		t.Fatal(err)
	}

	// Perform TSS round two for each group member.
	for _, member := range members {
		var receivedMessages []*tssRoundOneMessage
		for _, message := range messages {
			if message.senderID != member.id {
				receivedMessages = append(receivedMessages, message)
			}
		}

		// Cleanup symmetric key cache.
		member.symmetricKeys = make(map[group.MemberIndex]ephemeral.SymmetricKey)

		ctx, cancelCtx := context.WithTimeout(context.Background(), 10*time.Second)

		_, err := member.tssRoundTwo(ctx, receivedMessages)

		if !strings.Contains(
			err.Error(),
			"cannot get symmetric key with member",
		) {
			t.Errorf("wrong error for member [%v]: [%v]", member.id, err)
		}

		cancelCtx()
	}
}

func TestTssRoundThree(t *testing.T) {
	members, tssRoundTwoMessages, err := initializeTssRoundThreeMembersGroup(
		dishonestThreshold,
		groupSize,
	)
	if err != nil {
		t.Fatal(err)
	}

	// Perform TSS round three for each group member.
	tssRoundThreeMessages := make(map[group.MemberIndex]*tssRoundThreeMessage)
	for _, member := range members {
		var receivedTssRoundTwoMessages []*tssRoundTwoMessage
		for _, tssRoundTwoMessage := range tssRoundTwoMessages {
			if tssRoundTwoMessage.senderID != member.id {
				receivedTssRoundTwoMessages = append(
					receivedTssRoundTwoMessages,
					tssRoundTwoMessage,
				)
			}
		}

		ctx, cancelCtx := context.WithTimeout(
			context.Background(),
			10*time.Second,
		)

		tssRoundThreeMessage, err := member.tssRoundThree(
			ctx,
			receivedTssRoundTwoMessages,
		)
		if err != nil {
			cancelCtx()
			t.Fatal(err)
		}
		tssRoundThreeMessages[member.id] = tssRoundThreeMessage

		cancelCtx()
	}

	// Assert that each member has a correct state.
	for _, member := range members {
		if !strings.Contains(member.tssParty.String(), "round: 3") {
			t.Errorf("wrong round number for member [%v]", member.id)
		}
	}

	// Assert that each message is formed correctly.
	for memberID, message := range tssRoundThreeMessages {
		assertOutgoingMessageGeneralParameters(
			t,
			message.senderID,
			message.sessionID,
			memberID,
		)

		assertOutgoingMessageBroadcastPayload(
			t,
			message.payload,
			memberID,
		)
	}
}

func TestTssRoundThree_IncomingMessageCorrupted_UndecryptablePeerPayload(t *testing.T) {
	members, messages, err := initializeTssRoundThreeMembersGroup(
		dishonestThreshold,
		groupSize,
	)
	if err != nil {
		t.Fatal(err)
	}

	corruptedPayload, err := hex.DecodeString("ffeeaabb")
	if err != nil {
		t.Fatal(err)
	}

	// Perform TSS round three for each group member.
	for _, member := range members {
		var receivedMessages []*tssRoundTwoMessage
		for _, message := range messages {
			if message.senderID != member.id {
				// Make the P2P undecryptable by setting an arbitrary value
				// as ciphertext.
				corruptedPeersPayload := make(map[group.MemberIndex][]byte)
				for receiverID := range message.peersPayload {
					corruptedPeersPayload[receiverID] = corruptedPayload
				}
				message.peersPayload = corruptedPeersPayload
				receivedMessages = append(receivedMessages, message)
			}
		}

		ctx, cancelCtx := context.WithTimeout(context.Background(), 10*time.Second)

		_, err := member.tssRoundThree(ctx, receivedMessages)

		if !strings.Contains(
			err.Error(),
			"cannot decrypt P2P part of the TSS round two message",
		) {
			t.Errorf("wrong error for member [%v]: [%v]", member.id, err)
		}

		cancelCtx()
	}
}

func TestTssRoundThree_IncomingMessageCorrupted_WrongPeerPayload(t *testing.T) {
	members, messages, err := initializeTssRoundThreeMembersGroup(
		dishonestThreshold,
		groupSize,
	)
	if err != nil {
		t.Fatal(err)
	}

	corruptedPayload, err := hex.DecodeString("ffeeaabb")
	if err != nil {
		t.Fatal(err)
	}

	// Perform TSS round three for each group member.
	for _, member := range members {
		var receivedMessages []*tssRoundTwoMessage
		for _, message := range messages {
			if message.senderID != member.id {
				// Corrupt the message's peers payload by encrypting an
				// arbitrary value.
				corruptedPeersPayload := make(map[group.MemberIndex][]byte)
				for receiverID := range message.peersPayload {
					symmetricKey := members[message.senderID-1].symmetricKeys[receiverID]
					encryptedCorruptedPayload, err := symmetricKey.Encrypt(corruptedPayload)
					if err != nil {
						t.Fatal(err)
					}
					corruptedPeersPayload[receiverID] = encryptedCorruptedPayload
				}
				message.peersPayload = corruptedPeersPayload
				receivedMessages = append(receivedMessages, message)
			}
		}

		ctx, cancelCtx := context.WithTimeout(context.Background(), 10*time.Second)

		_, err := member.tssRoundThree(ctx, receivedMessages)

		if !strings.Contains(
			err.Error(),
			"cannot update using the P2P part of the TSS round two message",
		) {
			t.Errorf("wrong error for member [%v]: [%v]", member.id, err)
		}

		cancelCtx()
	}
}

func TestTssRoundThree_IncomingMessageMissing(t *testing.T) {
	members, messages, err := initializeTssRoundThreeMembersGroup(
		dishonestThreshold,
		groupSize,
	)
	if err != nil {
		t.Fatal(err)
	}

	// Perform TSS round three for each group member.
	for _, member := range members {
		var receivedMessages []*tssRoundTwoMessage
		for _, message := range messages {
			if message.senderID != member.id {
				receivedMessages = append(receivedMessages, message)
			}
		}

		ctx, cancelCtx := context.WithTimeout(context.Background(), 1*time.Second)
		// Pass only one incoming message from TSS round two for processing.
		_, err := member.tssRoundThree(ctx, receivedMessages[:1])

		expectedErr := fmt.Errorf(
			"TSS round three outgoing message was not generated on time",
		)
		if !reflect.DeepEqual(expectedErr, err) {
			t.Errorf(
				"unexpected error for member [%v]\n"+
					"expected: %v\n"+
					"actual:   %v\n",
				member.id,
				expectedErr,
				err,
			)
		}

		cancelCtx()
	}
}

func TestTssRoundThree_OutgoingMessageTimeout(t *testing.T) {
	members, messages, err := initializeTssRoundThreeMembersGroup(
		dishonestThreshold,
		groupSize,
	)
	if err != nil {
		t.Fatal(err)
	}

	// Perform TSS round three for each group member.
	for _, member := range members {
		var receivedMessages []*tssRoundTwoMessage
		for _, message := range messages {
			if message.senderID != member.id {
				receivedMessages = append(receivedMessages, message)
			}
		}

		// To simulate the outgoing message timeout we do two things:
		// - we pass an already cancelled context
		// - we make sure no message is emitted from the channel by overwriting
		//   the existing channel with a new one that won't receive any
		//   messages from the underlying TSS local party
		ctx, cancelCtx := context.WithCancel(context.Background())
		cancelCtx()
		member.tssOutgoingMessagesChan = make(<-chan tss.Message)

		_, err := member.tssRoundThree(ctx, receivedMessages)

		expectedErr := fmt.Errorf(
			"TSS round three outgoing message was not generated on time",
		)
		if !reflect.DeepEqual(expectedErr, err) {
			t.Errorf(
				"unexpected error for member [%v]\n"+
					"expected: %v\n"+
					"actual:   %v\n",
				member.id,
				expectedErr,
				err,
			)
		}
	}
}

func TestTssRoundThree_SymmetricKeyMissing(t *testing.T) {
	members, messages, err := initializeTssRoundThreeMembersGroup(
		dishonestThreshold,
		groupSize,
	)
	if err != nil {
		t.Fatal(err)
	}

	// Perform TSS round two for each group member.
	for _, member := range members {
		var receivedMessages []*tssRoundTwoMessage
		for _, message := range messages {
			if message.senderID != member.id {
				receivedMessages = append(receivedMessages, message)
			}
		}

		// Cleanup symmetric key cache.
		member.symmetricKeys = make(map[group.MemberIndex]ephemeral.SymmetricKey)

		ctx, cancelCtx := context.WithTimeout(context.Background(), 10*time.Second)

		_, err := member.tssRoundThree(ctx, receivedMessages)

		if !strings.Contains(
			err.Error(),
			"cannot get symmetric key with member",
		) {
			t.Errorf("wrong error for member [%v]: [%v]", member.id, err)
		}

		cancelCtx()
	}
}

func TestTssRoundFour(t *testing.T) {
	members, tssRoundThreeMessages, err := initializeTssRoundFourMembersGroup(
		dishonestThreshold,
		groupSize,
	)
	if err != nil {
		t.Fatal(err)
	}

	// Perform TSS round four for each group member.
	tssRoundFourMessages := make(map[group.MemberIndex]*tssRoundFourMessage)
	for _, member := range members {
		var receivedTssRoundThreeMessages []*tssRoundThreeMessage
		for _, tssRoundThreeMessage := range tssRoundThreeMessages {
			if tssRoundThreeMessage.senderID != member.id {
				receivedTssRoundThreeMessages = append(
					receivedTssRoundThreeMessages,
					tssRoundThreeMessage,
				)
			}
		}

		ctx, cancelCtx := context.WithTimeout(
			context.Background(),
			10*time.Second,
		)

		tssRoundFourMessage, err := member.tssRoundFour(
			ctx,
			receivedTssRoundThreeMessages,
		)
		if err != nil {
			cancelCtx()
			t.Fatal(err)
		}
		tssRoundFourMessages[member.id] = tssRoundFourMessage

		cancelCtx()
	}

	// Assert that each member has a correct state.
	for _, member := range members {
		if !strings.Contains(member.tssParty.String(), "round: 4") {
			t.Errorf("wrong round number for member [%v]", member.id)
		}
	}

	// Assert that each message is formed correctly.
	for memberID, message := range tssRoundFourMessages {
		assertOutgoingMessageGeneralParameters(
			t,
			message.senderID,
			message.sessionID,
			memberID,
		)

		assertOutgoingMessageBroadcastPayload(
			t,
			message.payload,
			memberID,
		)
	}
}

func TestTssRoundFour_IncomingMessageCorrupted_WrongPayload(t *testing.T) {
	members, messages, err := initializeTssRoundFourMembersGroup(
		dishonestThreshold,
		groupSize,
	)
	if err != nil {
		t.Fatal(err)
	}

	corruptedPayload, err := hex.DecodeString("ffeeaabb")
	if err != nil {
		t.Fatal(err)
	}

	// Perform TSS round four for each group member.
	for _, member := range members {
		var receivedMessages []*tssRoundThreeMessage
		for _, message := range messages {
			if message.senderID != member.id {
				// Corrupt the message's payload.
				message.payload = corruptedPayload
				receivedMessages = append(receivedMessages, message)
			}
		}

		ctx, cancelCtx := context.WithTimeout(context.Background(), 10*time.Second)

		_, err := member.tssRoundFour(ctx, receivedMessages)

		if !strings.Contains(
			err.Error(),
			"cannot update using TSS round three message",
		) {
			t.Errorf("wrong error for member [%v]: [%v]", member.id, err)
		}

		cancelCtx()
	}
}

func TestTssRoundFour_IncomingMessageMissing(t *testing.T) {
	members, messages, err := initializeTssRoundFourMembersGroup(
		dishonestThreshold,
		groupSize,
	)
	if err != nil {
		t.Fatal(err)
	}

	// Perform TSS round four for each group member.
	for _, member := range members {
		var receivedMessages []*tssRoundThreeMessage
		for _, message := range messages {
			if message.senderID != member.id {
				receivedMessages = append(receivedMessages, message)
			}
		}

		ctx, cancelCtx := context.WithTimeout(context.Background(), 1*time.Second)
		// Pass only one incoming message from TSS round three for processing.
		_, err := member.tssRoundFour(ctx, receivedMessages[:1])

		expectedErr := fmt.Errorf(
			"TSS round four outgoing message was not generated on time",
		)
		if !reflect.DeepEqual(expectedErr, err) {
			t.Errorf(
				"unexpected error for member [%v]\n"+
					"expected: %v\n"+
					"actual:   %v\n",
				member.id,
				expectedErr,
				err,
			)
		}

		cancelCtx()
	}
}

func TestTssRoundFour_OutgoingMessageTimeout(t *testing.T) {
	members, messages, err := initializeTssRoundFourMembersGroup(
		dishonestThreshold,
		groupSize,
	)
	if err != nil {
		t.Fatal(err)
	}

	// Perform TSS round four for each group member.
	for _, member := range members {
		var receivedMessages []*tssRoundThreeMessage
		for _, message := range messages {
			if message.senderID != member.id {
				receivedMessages = append(receivedMessages, message)
			}
		}

		// To simulate the outgoing message timeout we do two things:
		// - we pass an already cancelled context
		// - we make sure no message is emitted from the channel by overwriting
		//   the existing channel with a new one that won't receive any
		//   messages from the underlying TSS local party
		ctx, cancelCtx := context.WithCancel(context.Background())
		cancelCtx()
		member.tssOutgoingMessagesChan = make(<-chan tss.Message)

		_, err := member.tssRoundFour(ctx, receivedMessages)

		expectedErr := fmt.Errorf(
			"TSS round four outgoing message was not generated on time",
		)
		if !reflect.DeepEqual(expectedErr, err) {
			t.Errorf(
				"unexpected error for member [%v]\n"+
					"expected: %v\n"+
					"actual:   %v\n",
				member.id,
				expectedErr,
				err,
			)
		}
	}
}

func TestTssRoundFive(t *testing.T) {
	members, tssRoundFourMessages, err := initializeTssRoundFiveMembersGroup(
		dishonestThreshold,
		groupSize,
	)
	if err != nil {
		t.Fatal(err)
	}

	// Perform TSS round five for each group member.
	tssRoundFiveMessages := make(map[group.MemberIndex]*tssRoundFiveMessage)
	for _, member := range members {
		var receivedTssRoundFourMessages []*tssRoundFourMessage
		for _, tssRoundFourMessage := range tssRoundFourMessages {
			if tssRoundFourMessage.senderID != member.id {
				receivedTssRoundFourMessages = append(
					receivedTssRoundFourMessages,
					tssRoundFourMessage,
				)
			}
		}

		ctx, cancelCtx := context.WithTimeout(
			context.Background(),
			10*time.Second,
		)

		tssRoundFiveMessage, err := member.tssRoundFive(
			ctx,
			receivedTssRoundFourMessages,
		)
		if err != nil {
			cancelCtx()
			t.Fatal(err)
		}
		tssRoundFiveMessages[member.id] = tssRoundFiveMessage

		cancelCtx()
	}

	// Assert that each member has a correct state.
	for _, member := range members {
		if !strings.Contains(member.tssParty.String(), "round: 5") {
			t.Errorf("wrong round number for member [%v]", member.id)
		}
	}

	// Assert that each message is formed correctly.
	for memberID, message := range tssRoundFiveMessages {
		assertOutgoingMessageGeneralParameters(
			t,
			message.senderID,
			message.sessionID,
			memberID,
		)

		assertOutgoingMessageBroadcastPayload(
			t,
			message.payload,
			memberID,
		)
	}
}

func TestTssRoundFive_IncomingMessageCorrupted_WrongPayload(t *testing.T) {
	members, messages, err := initializeTssRoundFiveMembersGroup(
		dishonestThreshold,
		groupSize,
	)
	if err != nil {
		t.Fatal(err)
	}

	corruptedPayload, err := hex.DecodeString("ffeeaabb")
	if err != nil {
		t.Fatal(err)
	}

	// Perform TSS round five for each group member.
	for _, member := range members {
		var receivedMessages []*tssRoundFourMessage
		for _, message := range messages {
			if message.senderID != member.id {
				// Corrupt the message's payload.
				message.payload = corruptedPayload
				receivedMessages = append(receivedMessages, message)
			}
		}

		ctx, cancelCtx := context.WithTimeout(context.Background(), 10*time.Second)

		_, err := member.tssRoundFive(ctx, receivedMessages)

		if !strings.Contains(
			err.Error(),
			"cannot update using TSS round four message",
		) {
			t.Errorf("wrong error for member [%v]: [%v]", member.id, err)
		}

		cancelCtx()
	}
}

func TestTssRoundFive_IncomingMessageMissing(t *testing.T) {
	members, messages, err := initializeTssRoundFiveMembersGroup(
		dishonestThreshold,
		groupSize,
	)
	if err != nil {
		t.Fatal(err)
	}

	// Perform TSS round five for each group member.
	for _, member := range members {
		var receivedMessages []*tssRoundFourMessage
		for _, message := range messages {
			if message.senderID != member.id {
				receivedMessages = append(receivedMessages, message)
			}
		}

		ctx, cancelCtx := context.WithTimeout(context.Background(), 1*time.Second)
		// Pass only one incoming message from TSS round four for processing.
		_, err := member.tssRoundFive(ctx, receivedMessages[:1])

		expectedErr := fmt.Errorf(
			"TSS round five outgoing message was not generated on time",
		)
		if !reflect.DeepEqual(expectedErr, err) {
			t.Errorf(
				"unexpected error for member [%v]\n"+
					"expected: %v\n"+
					"actual:   %v\n",
				member.id,
				expectedErr,
				err,
			)
		}

		cancelCtx()
	}
}

func TestTssRoundFive_OutgoingMessageTimeout(t *testing.T) {
	members, messages, err := initializeTssRoundFiveMembersGroup(
		dishonestThreshold,
		groupSize,
	)
	if err != nil {
		t.Fatal(err)
	}

	// Perform TSS round five for each group member.
	for _, member := range members {
		var receivedMessages []*tssRoundFourMessage
		for _, message := range messages {
			if message.senderID != member.id {
				receivedMessages = append(receivedMessages, message)
			}
		}

		// To simulate the outgoing message timeout we do two things:
		// - we pass an already cancelled context
		// - we make sure no message is emitted from the channel by overwriting
		//   the existing channel with a new one that won't receive any
		//   messages from the underlying TSS local party
		ctx, cancelCtx := context.WithCancel(context.Background())
		cancelCtx()
		member.tssOutgoingMessagesChan = make(<-chan tss.Message)

		_, err := member.tssRoundFive(ctx, receivedMessages)

		expectedErr := fmt.Errorf(
			"TSS round five outgoing message was not generated on time",
		)
		if !reflect.DeepEqual(expectedErr, err) {
			t.Errorf(
				"unexpected error for member [%v]\n"+
					"expected: %v\n"+
					"actual:   %v\n",
				member.id,
				expectedErr,
				err,
			)
		}
	}
}

func TestTssRoundSix(t *testing.T) {
	members, tssRoundFiveMessages, err := initializeTssRoundSixMembersGroup(
		dishonestThreshold,
		groupSize,
	)
	if err != nil {
		t.Fatal(err)
	}

	// Perform TSS round six for each group member.
	tssRoundSixMessages := make(map[group.MemberIndex]*tssRoundSixMessage)
	for _, member := range members {
		var receivedTssRoundFiveMessages []*tssRoundFiveMessage
		for _, tssRoundFiveMessage := range tssRoundFiveMessages {
			if tssRoundFiveMessage.senderID != member.id {
				receivedTssRoundFiveMessages = append(
					receivedTssRoundFiveMessages,
					tssRoundFiveMessage,
				)
			}
		}

		ctx, cancelCtx := context.WithTimeout(
			context.Background(),
			10*time.Second,
		)

		tssRoundSixMessage, err := member.tssRoundSix(
			ctx,
			receivedTssRoundFiveMessages,
		)
		if err != nil {
			cancelCtx()
			t.Fatal(err)
		}
		tssRoundSixMessages[member.id] = tssRoundSixMessage

		cancelCtx()
	}

	// Assert that each member has a correct state.
	for _, member := range members {
		if !strings.Contains(member.tssParty.String(), "round: 6") {
			t.Errorf("wrong round number for member [%v]", member.id)
		}
	}

	// Assert that each message is formed correctly.
	for memberID, message := range tssRoundSixMessages {
		assertOutgoingMessageGeneralParameters(
			t,
			message.senderID,
			message.sessionID,
			memberID,
		)

		assertOutgoingMessageBroadcastPayload(
			t,
			message.payload,
			memberID,
		)
	}
}

func TestTssRoundSix_IncomingMessageCorrupted_WrongPayload(t *testing.T) {
	members, messages, err := initializeTssRoundSixMembersGroup(
		dishonestThreshold,
		groupSize,
	)
	if err != nil {
		t.Fatal(err)
	}

	corruptedPayload, err := hex.DecodeString("ffeeaabb")
	if err != nil {
		t.Fatal(err)
	}

	// Perform TSS round six for each group member.
	for _, member := range members {
		var receivedMessages []*tssRoundFiveMessage
		for _, message := range messages {
			if message.senderID != member.id {
				// Corrupt the message's payload.
				message.payload = corruptedPayload
				receivedMessages = append(receivedMessages, message)
			}
		}

		ctx, cancelCtx := context.WithTimeout(context.Background(), 10*time.Second)

		_, err := member.tssRoundSix(ctx, receivedMessages)

		if !strings.Contains(
			err.Error(),
			"cannot update using TSS round five message",
		) {
			t.Errorf("wrong error for member [%v]: [%v]", member.id, err)
		}

		cancelCtx()
	}
}

func TestTssRoundSix_IncomingMessageMissing(t *testing.T) {
	members, messages, err := initializeTssRoundSixMembersGroup(
		dishonestThreshold,
		groupSize,
	)
	if err != nil {
		t.Fatal(err)
	}

	// Perform TSS round six for each group member.
	for _, member := range members {
		var receivedMessages []*tssRoundFiveMessage
		for _, message := range messages {
			if message.senderID != member.id {
				receivedMessages = append(receivedMessages, message)
			}
		}

		ctx, cancelCtx := context.WithTimeout(context.Background(), 1*time.Second)
		// Pass only one incoming message from TSS round five for processing.
		_, err := member.tssRoundSix(ctx, receivedMessages[:1])

		expectedErr := fmt.Errorf(
			"TSS round six outgoing message was not generated on time",
		)
		if !reflect.DeepEqual(expectedErr, err) {
			t.Errorf(
				"unexpected error for member [%v]\n"+
					"expected: %v\n"+
					"actual:   %v\n",
				member.id,
				expectedErr,
				err,
			)
		}

		cancelCtx()
	}
}

func TestTssRoundSix_OutgoingMessageTimeout(t *testing.T) {
	members, messages, err := initializeTssRoundSixMembersGroup(
		dishonestThreshold,
		groupSize,
	)
	if err != nil {
		t.Fatal(err)
	}

	// Perform TSS round six for each group member.
	for _, member := range members {
		var receivedMessages []*tssRoundFiveMessage
		for _, message := range messages {
			if message.senderID != member.id {
				receivedMessages = append(receivedMessages, message)
			}
		}

		// To simulate the outgoing message timeout we do two things:
		// - we pass an already cancelled context
		// - we make sure no message is emitted from the channel by overwriting
		//   the existing channel with a new one that won't receive any
		//   messages from the underlying TSS local party
		ctx, cancelCtx := context.WithCancel(context.Background())
		cancelCtx()
		member.tssOutgoingMessagesChan = make(<-chan tss.Message)

		_, err := member.tssRoundSix(ctx, receivedMessages)

		expectedErr := fmt.Errorf(
			"TSS round six outgoing message was not generated on time",
		)
		if !reflect.DeepEqual(expectedErr, err) {
			t.Errorf(
				"unexpected error for member [%v]\n"+
					"expected: %v\n"+
					"actual:   %v\n",
				member.id,
				expectedErr,
				err,
			)
		}
	}
}

func TestTssRoundSeven(t *testing.T) {
	members, tssRoundSixMessages, err := initializeTssRoundSevenMembersGroup(
		dishonestThreshold,
		groupSize,
	)
	if err != nil {
		t.Fatal(err)
	}

	// Perform TSS round seven for each group member.
	tssRoundSevenMessages := make(map[group.MemberIndex]*tssRoundSevenMessage)
	for _, member := range members {
		var receivedTssRoundSixMessages []*tssRoundSixMessage
		for _, tssRoundSixMessage := range tssRoundSixMessages {
			if tssRoundSixMessage.senderID != member.id {
				receivedTssRoundSixMessages = append(
					receivedTssRoundSixMessages,
					tssRoundSixMessage,
				)
			}
		}

		ctx, cancelCtx := context.WithTimeout(
			context.Background(),
			10*time.Second,
		)

		tssRoundSevenMessage, err := member.tssRoundSeven(
			ctx,
			receivedTssRoundSixMessages,
		)
		if err != nil {
			cancelCtx()
			t.Fatal(err)
		}
		tssRoundSevenMessages[member.id] = tssRoundSevenMessage

		cancelCtx()
	}

	// Assert that each member has a correct state.
	for _, member := range members {
		if !strings.Contains(member.tssParty.String(), "round: 7") {
			t.Errorf("wrong round number for member [%v]", member.id)
		}
	}

	// Assert that each message is formed correctly.
	for memberID, message := range tssRoundSevenMessages {
		assertOutgoingMessageGeneralParameters(
			t,
			message.senderID,
			message.sessionID,
			memberID,
		)

		assertOutgoingMessageBroadcastPayload(
			t,
			message.payload,
			memberID,
		)
	}
}

func TestTssRoundSeven_IncomingMessageCorrupted_WrongPayload(t *testing.T) {
	members, messages, err := initializeTssRoundSevenMembersGroup(
		dishonestThreshold,
		groupSize,
	)
	if err != nil {
		t.Fatal(err)
	}

	corruptedPayload, err := hex.DecodeString("ffeeaabb")
	if err != nil {
		t.Fatal(err)
	}

	// Perform TSS round seven for each group member.
	for _, member := range members {
		var receivedMessages []*tssRoundSixMessage
		for _, message := range messages {
			if message.senderID != member.id {
				// Corrupt the message's payload.
				message.payload = corruptedPayload
				receivedMessages = append(receivedMessages, message)
			}
		}

		ctx, cancelCtx := context.WithTimeout(context.Background(), 10*time.Second)

		_, err := member.tssRoundSeven(ctx, receivedMessages)

		if !strings.Contains(
			err.Error(),
			"cannot update using TSS round six message",
		) {
			t.Errorf("wrong error for member [%v]: [%v]", member.id, err)
		}

		cancelCtx()
	}
}

func TestTssRoundSeven_IncomingMessageMissing(t *testing.T) {
	members, messages, err := initializeTssRoundSevenMembersGroup(
		dishonestThreshold,
		groupSize,
	)
	if err != nil {
		t.Fatal(err)
	}

	// Perform TSS round seven for each group member.
	for _, member := range members {
		var receivedMessages []*tssRoundSixMessage
		for _, message := range messages {
			if message.senderID != member.id {
				receivedMessages = append(receivedMessages, message)
			}
		}

		ctx, cancelCtx := context.WithTimeout(context.Background(), 1*time.Second)
		// Pass only one incoming message from TSS round six for processing.
		_, err := member.tssRoundSeven(ctx, receivedMessages[:1])

		expectedErr := fmt.Errorf(
			"TSS round seven outgoing message was not generated on time",
		)
		if !reflect.DeepEqual(expectedErr, err) {
			t.Errorf(
				"unexpected error for member [%v]\n"+
					"expected: %v\n"+
					"actual:   %v\n",
				member.id,
				expectedErr,
				err,
			)
		}

		cancelCtx()
	}
}

func TestTssRoundSeven_OutgoingMessageTimeout(t *testing.T) {
	members, messages, err := initializeTssRoundSevenMembersGroup(
		dishonestThreshold,
		groupSize,
	)
	if err != nil {
		t.Fatal(err)
	}

	// Perform TSS round seven for each group member.
	for _, member := range members {
		var receivedMessages []*tssRoundSixMessage
		for _, message := range messages {
			if message.senderID != member.id {
				receivedMessages = append(receivedMessages, message)
			}
		}

		// To simulate the outgoing message timeout we do two things:
		// - we pass an already cancelled context
		// - we make sure no message is emitted from the channel by overwriting
		//   the existing channel with a new one that won't receive any
		//   messages from the underlying TSS local party
		ctx, cancelCtx := context.WithCancel(context.Background())
		cancelCtx()
		member.tssOutgoingMessagesChan = make(<-chan tss.Message)

		_, err := member.tssRoundSeven(ctx, receivedMessages)

		expectedErr := fmt.Errorf(
			"TSS round seven outgoing message was not generated on time",
		)
		if !reflect.DeepEqual(expectedErr, err) {
			t.Errorf(
				"unexpected error for member [%v]\n"+
					"expected: %v\n"+
					"actual:   %v\n",
				member.id,
				expectedErr,
				err,
			)
		}
	}
}

func TestTssRoundEight(t *testing.T) {
	members, tssRoundSevenMessages, err := initializeTssRoundEightMembersGroup(
		dishonestThreshold,
		groupSize,
	)
	if err != nil {
		t.Fatal(err)
	}

	// Perform TSS round eight for each group member.
	tssRoundEightMessages := make(map[group.MemberIndex]*tssRoundEightMessage)
	for _, member := range members {
		var receivedTssRoundSevenMessages []*tssRoundSevenMessage
		for _, tssRoundSevenMessage := range tssRoundSevenMessages {
			if tssRoundSevenMessage.senderID != member.id {
				receivedTssRoundSevenMessages = append(
					receivedTssRoundSevenMessages,
					tssRoundSevenMessage,
				)
			}
		}

		ctx, cancelCtx := context.WithTimeout(
			context.Background(),
			10*time.Second,
		)

		tssRoundEightMessage, err := member.tssRoundEight(
			ctx,
			receivedTssRoundSevenMessages,
		)
		if err != nil {
			cancelCtx()
			t.Fatal(err)
		}
		tssRoundEightMessages[member.id] = tssRoundEightMessage

		cancelCtx()
	}

	// Assert that each member has a correct state.
	for _, member := range members {
		if !strings.Contains(member.tssParty.String(), "round: 8") {
			t.Errorf("wrong round number for member [%v]", member.id)
		}
	}

	// Assert that each message is formed correctly.
	for memberID, message := range tssRoundEightMessages {
		assertOutgoingMessageGeneralParameters(
			t,
			message.senderID,
			message.sessionID,
			memberID,
		)

		assertOutgoingMessageBroadcastPayload(
			t,
			message.payload,
			memberID,
		)
	}
}

func TestTssRoundEight_IncomingMessageCorrupted_WrongPayload(t *testing.T) {
	members, messages, err := initializeTssRoundEightMembersGroup(
		dishonestThreshold,
		groupSize,
	)
	if err != nil {
		t.Fatal(err)
	}

	corruptedPayload, err := hex.DecodeString("ffeeaabb")
	if err != nil {
		t.Fatal(err)
	}

	// Perform TSS round eight for each group member.
	for _, member := range members {
		var receivedMessages []*tssRoundSevenMessage
		for _, message := range messages {
			if message.senderID != member.id {
				// Corrupt the message's payload.
				message.payload = corruptedPayload
				receivedMessages = append(receivedMessages, message)
			}
		}

		ctx, cancelCtx := context.WithTimeout(context.Background(), 10*time.Second)

		_, err := member.tssRoundEight(ctx, receivedMessages)

		if !strings.Contains(
			err.Error(),
			"cannot update using TSS round seven message",
		) {
			t.Errorf("wrong error for member [%v]: [%v]", member.id, err)
		}

		cancelCtx()
	}
}

func TestTssRoundEight_IncomingMessageMissing(t *testing.T) {
	members, messages, err := initializeTssRoundEightMembersGroup(
		dishonestThreshold,
		groupSize,
	)
	if err != nil {
		t.Fatal(err)
	}

	// Perform TSS round eight for each group member.
	for _, member := range members {
		var receivedMessages []*tssRoundSevenMessage
		for _, message := range messages {
			if message.senderID != member.id {
				receivedMessages = append(receivedMessages, message)
			}
		}

		ctx, cancelCtx := context.WithTimeout(context.Background(), 1*time.Second)
		// Pass only one incoming message from TSS round seven for processing.
		_, err := member.tssRoundEight(ctx, receivedMessages[:1])

		expectedErr := fmt.Errorf(
			"TSS round eight outgoing message was not generated on time",
		)
		if !reflect.DeepEqual(expectedErr, err) {
			t.Errorf(
				"unexpected error for member [%v]\n"+
					"expected: %v\n"+
					"actual:   %v\n",
				member.id,
				expectedErr,
				err,
			)
		}

		cancelCtx()
	}
}

func TestTssRoundEight_OutgoingMessageTimeout(t *testing.T) {
	members, messages, err := initializeTssRoundEightMembersGroup(
		dishonestThreshold,
		groupSize,
	)
	if err != nil {
		t.Fatal(err)
	}

	// Perform TSS round eight for each group member.
	for _, member := range members {
		var receivedMessages []*tssRoundSevenMessage
		for _, message := range messages {
			if message.senderID != member.id {
				receivedMessages = append(receivedMessages, message)
			}
		}

		// To simulate the outgoing message timeout we do two things:
		// - we pass an already cancelled context
		// - we make sure no message is emitted from the channel by overwriting
		//   the existing channel with a new one that won't receive any
		//   messages from the underlying TSS local party
		ctx, cancelCtx := context.WithCancel(context.Background())
		cancelCtx()
		member.tssOutgoingMessagesChan = make(<-chan tss.Message)

		_, err := member.tssRoundEight(ctx, receivedMessages)

		expectedErr := fmt.Errorf(
			"TSS round eight outgoing message was not generated on time",
		)
		if !reflect.DeepEqual(expectedErr, err) {
			t.Errorf(
				"unexpected error for member [%v]\n"+
					"expected: %v\n"+
					"actual:   %v\n",
				member.id,
				expectedErr,
				err,
			)
		}
	}
}

func TestTssRoundNine(t *testing.T) {
	members, tssRoundEightMessages, err := initializeTssRoundNineMembersGroup(
		dishonestThreshold,
		groupSize,
	)
	if err != nil {
		t.Fatal(err)
	}

	// Perform TSS round nine for each group member.
	tssRoundNineMessages := make(map[group.MemberIndex]*tssRoundNineMessage)
	for _, member := range members {
		var receivedTssRoundEightMessages []*tssRoundEightMessage
		for _, tssRoundEightMessage := range tssRoundEightMessages {
			if tssRoundEightMessage.senderID != member.id {
				receivedTssRoundEightMessages = append(
					receivedTssRoundEightMessages,
					tssRoundEightMessage,
				)
			}
		}

		ctx, cancelCtx := context.WithTimeout(
			context.Background(),
			10*time.Second,
		)

		tssRoundNineMessage, err := member.tssRoundNine(
			ctx,
			receivedTssRoundEightMessages,
		)
		if err != nil {
			cancelCtx()
			t.Fatal(err)
		}
		tssRoundNineMessages[member.id] = tssRoundNineMessage

		cancelCtx()
	}

	// Assert that each member has a correct state.
	for _, member := range members {
		if !strings.Contains(member.tssParty.String(), "round: 9") {
			t.Errorf("wrong round number for member [%v]", member.id)
		}
	}

	// Assert that each message is formed correctly.
	for memberID, message := range tssRoundNineMessages {
		assertOutgoingMessageGeneralParameters(
			t,
			message.senderID,
			message.sessionID,
			memberID,
		)

		assertOutgoingMessageBroadcastPayload(
			t,
			message.payload,
			memberID,
		)
	}
}

func TestTssRoundNine_IncomingMessageCorrupted_WrongPayload(t *testing.T) {
	members, messages, err := initializeTssRoundNineMembersGroup(
		dishonestThreshold,
		groupSize,
	)
	if err != nil {
		t.Fatal(err)
	}

	corruptedPayload, err := hex.DecodeString("ffeeaabb")
	if err != nil {
		t.Fatal(err)
	}

	// Perform TSS round nine for each group member.
	for _, member := range members {
		var receivedMessages []*tssRoundEightMessage
		for _, message := range messages {
			if message.senderID != member.id {
				// Corrupt the message's payload.
				message.payload = corruptedPayload
				receivedMessages = append(receivedMessages, message)
			}
		}

		ctx, cancelCtx := context.WithTimeout(context.Background(), 10*time.Second)

		_, err := member.tssRoundNine(ctx, receivedMessages)

		if !strings.Contains(
			err.Error(),
			"cannot update using TSS round eight message",
		) {
			t.Errorf("wrong error for member [%v]: [%v]", member.id, err)
		}

		cancelCtx()
	}
}

func TestTssRoundNine_IncomingMessageMissing(t *testing.T) {
	members, messages, err := initializeTssRoundNineMembersGroup(
		dishonestThreshold,
		groupSize,
	)
	if err != nil {
		t.Fatal(err)
	}

	// Perform TSS round nine for each group member.
	for _, member := range members {
		var receivedMessages []*tssRoundEightMessage
		for _, message := range messages {
			if message.senderID != member.id {
				receivedMessages = append(receivedMessages, message)
			}
		}

		ctx, cancelCtx := context.WithTimeout(context.Background(), 1*time.Second)
		// Pass only one incoming message from TSS round eight for processing.
		_, err := member.tssRoundNine(ctx, receivedMessages[:1])

		expectedErr := fmt.Errorf(
			"TSS round nine outgoing message was not generated on time",
		)
		if !reflect.DeepEqual(expectedErr, err) {
			t.Errorf(
				"unexpected error for member [%v]\n"+
					"expected: %v\n"+
					"actual:   %v\n",
				member.id,
				expectedErr,
				err,
			)
		}

		cancelCtx()
	}
}

func TestTssRoundNine_OutgoingMessageTimeout(t *testing.T) {
	members, messages, err := initializeTssRoundNineMembersGroup(
		dishonestThreshold,
		groupSize,
	)
	if err != nil {
		t.Fatal(err)
	}

	// Perform TSS round nine for each group member.
	for _, member := range members {
		var receivedMessages []*tssRoundEightMessage
		for _, message := range messages {
			if message.senderID != member.id {
				receivedMessages = append(receivedMessages, message)
			}
		}

		// To simulate the outgoing message timeout we do two things:
		// - we pass an already cancelled context
		// - we make sure no message is emitted from the channel by overwriting
		//   the existing channel with a new one that won't receive any
		//   messages from the underlying TSS local party
		ctx, cancelCtx := context.WithCancel(context.Background())
		cancelCtx()
		member.tssOutgoingMessagesChan = make(<-chan tss.Message)

		_, err := member.tssRoundNine(ctx, receivedMessages)

		expectedErr := fmt.Errorf(
			"TSS round nine outgoing message was not generated on time",
		)
		if !reflect.DeepEqual(expectedErr, err) {
			t.Errorf(
				"unexpected error for member [%v]\n"+
					"expected: %v\n"+
					"actual:   %v\n",
				member.id,
				expectedErr,
				err,
			)
		}
	}
}

func TestTssFinalize(t *testing.T) {
	members, tssRoundNineMessages, err := initializeFinalizingMembersGroup(
		dishonestThreshold,
		groupSize,
	)
	if err != nil {
		t.Fatal(err)
	}

	// Perform TSS finalization for each group member.
	for _, member := range members {
		var receivedTssRoundNineMessages []*tssRoundNineMessage
		for _, tssRoundNineMessage := range tssRoundNineMessages {
			if tssRoundNineMessage.senderID != member.id {
				receivedTssRoundNineMessages = append(
					receivedTssRoundNineMessages,
					tssRoundNineMessage,
				)
			}
		}

		ctx, cancelCtx := context.WithTimeout(
			context.Background(),
			10*time.Second,
		)

		err := member.tssFinalize(
			ctx,
			receivedTssRoundNineMessages,
		)
		if err != nil {
			cancelCtx()
			t.Fatal(err)
		}

		cancelCtx()
	}

	message := members[0].message
	publicKey := members[0].privateKeyShare.PublicKey()
	signatures := make(map[string]bool)

	// Assert that each member has a correct state.
	for _, member := range members {
		signature := member.Result().Signature

		if signature == nil {
			t.Errorf(
				"member [%v] has not produced a signature",
				member.id,
			)
		}

		if signature.R == nil {
			t.Errorf(
				"member [%v] has produced a nil R parameter",
				member.id,
			)
		}

		if signature.S == nil {
			t.Errorf(
				"member [%v] has produced a nil S parameter",
				member.id,
			)
		}

		// Proper recovery ID is always one of {0, 1, 2, 3}.
		if signature.RecoveryID < 0 || signature.RecoveryID > 3 {
			t.Errorf(
				"member [%v] has produced a wrong recovery ID parameter",
				member.id,
			)
		}

		if !ecdsa.Verify(publicKey, message.Bytes(), signature.R, signature.S) {
			t.Errorf(
				"member [%v] signature verification failed",
				member.id,
			)
		}

		signatures[signature.String()] = true
	}

	testutils.AssertIntsEqual(
		t,
		"count of distinct signatures produced by the group",
		1,
		len(signatures),
	)
}

func TestTssFinalize_IncomingMessageCorrupted_WrongPayload(t *testing.T) {
	members, messages, err := initializeFinalizingMembersGroup(
		dishonestThreshold,
		groupSize,
	)
	if err != nil {
		t.Fatal(err)
	}

	corruptedPayload, err := hex.DecodeString("ffeeaabb")
	if err != nil {
		t.Fatal(err)
	}

	// Perform TSS finalization for each group member.
	for _, member := range members {
		var receivedMessages []*tssRoundNineMessage
		for _, message := range messages {
			if message.senderID != member.id {
				// Corrupt the message's payload.
				message.payload = corruptedPayload
				receivedMessages = append(receivedMessages, message)
			}
		}

		ctx, cancelCtx := context.WithTimeout(context.Background(), 10*time.Second)

		err := member.tssFinalize(ctx, receivedMessages)

		if !strings.Contains(
			err.Error(),
			"cannot update using TSS round nine message",
		) {
			t.Errorf("wrong error for member [%v]: [%v]", member.id, err)
		}

		cancelCtx()
	}
}

func TestTssFinalize_IncomingMessageMissing(t *testing.T) {
	members, messages, err := initializeFinalizingMembersGroup(
		dishonestThreshold,
		groupSize,
	)
	if err != nil {
		t.Fatal(err)
	}

	// Perform TSS finalization for each group member.
	for _, member := range members {
		var receivedMessages []*tssRoundNineMessage
		for _, message := range messages {
			if message.senderID != member.id {
				receivedMessages = append(receivedMessages, message)
			}
		}

		ctx, cancelCtx := context.WithTimeout(context.Background(), 1*time.Second)
		// Pass only one incoming message from TSS round nine for processing.
		err := member.tssFinalize(ctx, receivedMessages[:1])

		expectedErr := fmt.Errorf(
			"TSS result was not generated on time",
		)
		if !reflect.DeepEqual(expectedErr, err) {
			t.Errorf(
				"unexpected error for member [%v]\n"+
					"expected: %v\n"+
					"actual:   %v\n",
				member.id,
				expectedErr,
				err,
			)
		}

		cancelCtx()
	}
}

func TestTssFinalize_ResultTimeout(t *testing.T) {
	members, messages, err := initializeFinalizingMembersGroup(
		dishonestThreshold,
		groupSize,
	)
	if err != nil {
		t.Fatal(err)
	}

	// Perform TSS finalization for each group member.
	for _, member := range members {
		var receivedMessages []*tssRoundNineMessage
		for _, message := range messages {
			if message.senderID != member.id {
				receivedMessages = append(receivedMessages, message)
			}
		}

		// To simulate the outgoing message timeout we do two things:
		// - we pass an already cancelled context
		// - we make sure no result is emitted from the channel by overwriting
		//   the existing channel with a new one that won't receive the
		//   result from the underlying TSS local party
		ctx, cancelCtx := context.WithCancel(context.Background())
		cancelCtx()
		member.tssResultChan = make(<-chan common.SignatureData)

		err := member.tssFinalize(ctx, receivedMessages)

		expectedErr := fmt.Errorf(
			"TSS result was not generated on time",
		)
		if !reflect.DeepEqual(expectedErr, err) {
			t.Errorf(
				"unexpected error for member [%v]\n"+
					"expected: %v\n"+
					"actual:   %v\n",
				member.id,
				expectedErr,
				err,
			)
		}
	}
}

func assertOutgoingMessageGeneralParameters(
	t *testing.T,
	messageSenderID group.MemberIndex,
	messageSessionID string,
	memberID group.MemberIndex,
) {
	// We should always be the sender of our own messages.
	testutils.AssertIntsEqual(
		t,
		fmt.Sprintf(
			"message sender in message generated by member [%v]",
			memberID,
		),
		int(memberID),
		int(messageSenderID),
	)

	// We should always use the proper session ID.
	testutils.AssertStringsEqual(
		t,
		fmt.Sprintf(
			"session ID in message generated by member [%v]",
			memberID,
		),
		sessionID,
		messageSessionID,
	)
}

func assertOutgoingMessageBroadcastPayload(
	t *testing.T,
	messageBroadcastPayload []byte,
	memberID group.MemberIndex,
) {
	if len(messageBroadcastPayload) == 0 {
		t.Errorf(
			"empty broadcast payload in message generated by member [%v]",
			memberID,
		)
	}
}

func assertOutgoingMessagePeersPayload(
	t *testing.T,
	messagePeersPayload map[group.MemberIndex][]byte,
	memberID group.MemberIndex,
	memberSymmetricKeys map[group.MemberIndex]ephemeral.SymmetricKey,
) {
	// We should generate groupSize-1 of peers payloads.
	testutils.AssertIntsEqual(
		t,
		fmt.Sprintf(
			"count of peers payloads in message "+
				"generated by member [%v]",
			memberID,
		),
		groupSize-1,
		len(messagePeersPayload),
	)

	// Each P2P payload should be encrypted using the proper symmetric key.
	for receiverID, encryptedPayload := range messagePeersPayload {
		symmetricKey := memberSymmetricKeys[receiverID]
		if _, err := symmetricKey.Decrypt(encryptedPayload); err != nil {
			t.Errorf(
				"payload for member [%v] in message generated "+
					"by member [%v] is encrypted using "+
					"the wrong symmetric key: [%v]",
				receiverID,
				memberID,
				err,
			)
		}
	}
}

func initializeEphemeralKeyPairGeneratingMembersGroup(
	dishonestThreshold int,
	groupSize int,
) ([]*ephemeralKeyPairGeneratingMember, error) {
	signingGroup := group.NewGroup(dishonestThreshold, groupSize)

	testData, err := tecdsatest.LoadPrivateKeyShareTestFixtures(groupSize)
	if err != nil {
		return nil, fmt.Errorf("failed to load test data: [%v]", err)
	}

	var members []*ephemeralKeyPairGeneratingMember
	for i := 1; i <= groupSize; i++ {
		id := group.MemberIndex(i)

		members = append(members, &ephemeralKeyPairGeneratingMember{
			member: &member{
				logger:          &testutils.MockLogger{},
				id:              id,
				group:           signingGroup,
				sessionID:       sessionID,
				message:         big.NewInt(100),
				privateKeyShare: tecdsa.NewPrivateKeyShare(testData[i-1]),
			},
			ephemeralKeyPairs: make(map[group.MemberIndex]*ephemeral.KeyPair),
		})
	}

	return members, nil
}
func initializeSymmetricKeyGeneratingMembersGroup(
	dishonestThreshold int,
	groupSize int,
) (
	[]*symmetricKeyGeneratingMember,
	[]*ephemeralPublicKeyMessage,
	error,
) {
	var symmetricKeyGeneratingMembers []*symmetricKeyGeneratingMember
	var ephemeralPublicKeyMessages []*ephemeralPublicKeyMessage

	ephemeralKeyPairGeneratingMembers, err :=
		initializeEphemeralKeyPairGeneratingMembersGroup(
			dishonestThreshold,
			groupSize,
		)
	if err != nil {
		return nil, nil, fmt.Errorf(
			"cannot generate ephemeral key pair generating "+
				"members group: [%v]",
			err,
		)
	}

	for _, member := range ephemeralKeyPairGeneratingMembers {
		message, err := member.generateEphemeralKeyPair()
		if err != nil {
			return nil, nil, fmt.Errorf(
				"cannot generate ephemeral key pair for member [%v]: [%v]",
				member.id,
				err,
			)
		}

		symmetricKeyGeneratingMembers = append(
			symmetricKeyGeneratingMembers,
			member.initializeSymmetricKeyGeneration(),
		)
		ephemeralPublicKeyMessages = append(ephemeralPublicKeyMessages, message)
	}

	return symmetricKeyGeneratingMembers, ephemeralPublicKeyMessages, nil
}

func initializeTssRoundOneMembersGroup(
	dishonestThreshold int,
	groupSize int,
) (
	[]*tssRoundOneMember,
	error,
) {
	var tssRoundOneMembers []*tssRoundOneMember

	symmetricKeyGeneratingMembers, ephemeralPublicKeyMessages, err :=
		initializeSymmetricKeyGeneratingMembersGroup(
			dishonestThreshold,
			groupSize,
		)
	if err != nil {
		return nil, fmt.Errorf(
			"cannot generate symmetric key generating members group: [%v]",
			err,
		)
	}

	for _, member := range symmetricKeyGeneratingMembers {
		var receivedMessages []*ephemeralPublicKeyMessage
		for _, message := range ephemeralPublicKeyMessages {
			if message.senderID != member.id {
				receivedMessages = append(receivedMessages, message)
			}
		}

		err := member.generateSymmetricKeys(receivedMessages)
		if err != nil {
			return nil, fmt.Errorf(
				"cannot generate symmetric keys for member [%v]: [%v]",
				member.id,
				err,
			)
		}

		tssRoundOneMembers = append(
			tssRoundOneMembers,
			member.initializeTssRoundOne(),
		)
	}

	return tssRoundOneMembers, nil
}

func initializeTssRoundTwoMembersGroup(
	dishonestThreshold int,
	groupSize int,
) (
	[]*tssRoundTwoMember,
	[]*tssRoundOneMessage,
	error,
) {
	var tssRoundTwoMembers []*tssRoundTwoMember
	var tssRoundOneMessages []*tssRoundOneMessage

	tssRoundOneMembers, err :=
		initializeTssRoundOneMembersGroup(
			dishonestThreshold,
			groupSize,
		)
	if err != nil {
		return nil, nil, fmt.Errorf(
			"cannot generate TSS round one members group: [%v]",
			err,
		)
	}

	for _, member := range tssRoundOneMembers {
		ctx, cancelCtx := context.WithTimeout(
			context.Background(),
			10*time.Second,
		)

		message, err := member.tssRoundOne(ctx)
		if err != nil {
			cancelCtx()
			return nil, nil, fmt.Errorf(
				"cannot do TSS round one for member [%v]: [%v]",
				member.id,
				err,
			)
		}

		tssRoundTwoMembers = append(
			tssRoundTwoMembers,
			member.initializeTssRoundTwo(),
		)
		tssRoundOneMessages = append(tssRoundOneMessages, message)

		cancelCtx()
	}

	return tssRoundTwoMembers, tssRoundOneMessages, nil
}

func initializeTssRoundThreeMembersGroup(
	dishonestThreshold int,
	groupSize int,
) (
	[]*tssRoundThreeMember,
	[]*tssRoundTwoMessage,
	error,
) {
	var tssRoundThreeMembers []*tssRoundThreeMember
	var tssRoundTwoMessages []*tssRoundTwoMessage

	tssRoundTwoMembers, tssRoundOneMessages, err :=
		initializeTssRoundTwoMembersGroup(
			dishonestThreshold,
			groupSize,
		)
	if err != nil {
		return nil, nil, fmt.Errorf(
			"cannot generate TSS round two members group: [%v]",
			err,
		)
	}

	for _, member := range tssRoundTwoMembers {
		var receivedTssRoundOneMessages []*tssRoundOneMessage
		for _, tssRoundOneMessage := range tssRoundOneMessages {
			if tssRoundOneMessage.senderID != member.id {
				receivedTssRoundOneMessages = append(
					receivedTssRoundOneMessages,
					tssRoundOneMessage,
				)
			}
		}

		ctx, cancelCtx := context.WithTimeout(
			context.Background(),
			10*time.Second,
		)

		tssRoundTwoMessage, err := member.tssRoundTwo(
			ctx,
			receivedTssRoundOneMessages,
		)
		if err != nil {
			cancelCtx()
			return nil, nil, fmt.Errorf(
				"cannot do TSS round two for member [%v]: [%v]",
				member.id,
				err,
			)
		}

		tssRoundThreeMembers = append(
			tssRoundThreeMembers,
			member.initializeTssRoundThree(),
		)
		tssRoundTwoMessages = append(tssRoundTwoMessages, tssRoundTwoMessage)

		cancelCtx()
	}

	return tssRoundThreeMembers, tssRoundTwoMessages, nil
}

func initializeTssRoundFourMembersGroup(
	dishonestThreshold int,
	groupSize int,
) (
	[]*tssRoundFourMember,
	[]*tssRoundThreeMessage,
	error,
) {
	var tssRoundFourMembers []*tssRoundFourMember
	var tssRoundThreeMessages []*tssRoundThreeMessage

	tssRoundThreeMembers, tssRoundTwoMessages, err :=
		initializeTssRoundThreeMembersGroup(
			dishonestThreshold,
			groupSize,
		)
	if err != nil {
		return nil, nil, fmt.Errorf(
			"cannot generate TSS round three members group: [%v]",
			err,
		)
	}

	for _, member := range tssRoundThreeMembers {
		var receivedTssRoundTwoMessages []*tssRoundTwoMessage
		for _, tssRoundTwoMessage := range tssRoundTwoMessages {
			if tssRoundTwoMessage.senderID != member.id {
				receivedTssRoundTwoMessages = append(
					receivedTssRoundTwoMessages,
					tssRoundTwoMessage,
				)
			}
		}

		ctx, cancelCtx := context.WithTimeout(
			context.Background(),
			10*time.Second,
		)

		tssRoundThreeMessage, err := member.tssRoundThree(
			ctx,
			receivedTssRoundTwoMessages,
		)
		if err != nil {
			cancelCtx()
			return nil, nil, fmt.Errorf(
				"cannot do TSS round three for member [%v]: [%v]",
				member.id,
				err,
			)
		}

		tssRoundFourMembers = append(
			tssRoundFourMembers,
			member.initializeTssRoundFour(),
		)
		tssRoundThreeMessages = append(tssRoundThreeMessages, tssRoundThreeMessage)

		cancelCtx()
	}

	return tssRoundFourMembers, tssRoundThreeMessages, nil
}

func initializeTssRoundFiveMembersGroup(
	dishonestThreshold int,
	groupSize int,
) (
	[]*tssRoundFiveMember,
	[]*tssRoundFourMessage,
	error,
) {
	var tssRoundFiveMembers []*tssRoundFiveMember
	var tssRoundFourMessages []*tssRoundFourMessage

	tssRoundFourMembers, tssRoundThreeMessages, err :=
		initializeTssRoundFourMembersGroup(
			dishonestThreshold,
			groupSize,
		)
	if err != nil {
		return nil, nil, fmt.Errorf(
			"cannot generate TSS round four members group: [%v]",
			err,
		)
	}

	for _, member := range tssRoundFourMembers {
		var receivedTssRoundThreeMessages []*tssRoundThreeMessage
		for _, tssRoundThreeMessage := range tssRoundThreeMessages {
			if tssRoundThreeMessage.senderID != member.id {
				receivedTssRoundThreeMessages = append(
					receivedTssRoundThreeMessages,
					tssRoundThreeMessage,
				)
			}
		}

		ctx, cancelCtx := context.WithTimeout(
			context.Background(),
			10*time.Second,
		)

		tssRoundFourMessage, err := member.tssRoundFour(
			ctx,
			receivedTssRoundThreeMessages,
		)
		if err != nil {
			cancelCtx()
			return nil, nil, fmt.Errorf(
				"cannot do TSS round four for member [%v]: [%v]",
				member.id,
				err,
			)
		}

		tssRoundFiveMembers = append(
			tssRoundFiveMembers,
			member.initializeTssRoundFive(),
		)
		tssRoundFourMessages = append(tssRoundFourMessages, tssRoundFourMessage)

		cancelCtx()
	}

	return tssRoundFiveMembers, tssRoundFourMessages, nil
}

func initializeTssRoundSixMembersGroup(
	dishonestThreshold int,
	groupSize int,
) (
	[]*tssRoundSixMember,
	[]*tssRoundFiveMessage,
	error,
) {
	var tssRoundSixMembers []*tssRoundSixMember
	var tssRoundFiveMessages []*tssRoundFiveMessage

	tssRoundFiveMembers, tssRoundFourMessages, err :=
		initializeTssRoundFiveMembersGroup(
			dishonestThreshold,
			groupSize,
		)
	if err != nil {
		return nil, nil, fmt.Errorf(
			"cannot generate TSS round five members group: [%v]",
			err,
		)
	}

	for _, member := range tssRoundFiveMembers {
		var receivedTssRoundFourMessages []*tssRoundFourMessage
		for _, tssRoundFourMessage := range tssRoundFourMessages {
			if tssRoundFourMessage.senderID != member.id {
				receivedTssRoundFourMessages = append(
					receivedTssRoundFourMessages,
					tssRoundFourMessage,
				)
			}
		}

		ctx, cancelCtx := context.WithTimeout(
			context.Background(),
			10*time.Second,
		)

		tssRoundFiveMessage, err := member.tssRoundFive(
			ctx,
			receivedTssRoundFourMessages,
		)
		if err != nil {
			cancelCtx()
			return nil, nil, fmt.Errorf(
				"cannot do TSS round five for member [%v]: [%v]",
				member.id,
				err,
			)
		}

		tssRoundSixMembers = append(
			tssRoundSixMembers,
			member.initializeTssRoundSix(),
		)
		tssRoundFiveMessages = append(tssRoundFiveMessages, tssRoundFiveMessage)

		cancelCtx()
	}

	return tssRoundSixMembers, tssRoundFiveMessages, nil
}

func initializeTssRoundSevenMembersGroup(
	dishonestThreshold int,
	groupSize int,
) (
	[]*tssRoundSevenMember,
	[]*tssRoundSixMessage,
	error,
) {
	var tssRoundSevenMembers []*tssRoundSevenMember
	var tssRoundSixMessages []*tssRoundSixMessage

	tssRoundSixMembers, tssRoundFiveMessages, err :=
		initializeTssRoundSixMembersGroup(
			dishonestThreshold,
			groupSize,
		)
	if err != nil {
		return nil, nil, fmt.Errorf(
			"cannot generate TSS round six members group: [%v]",
			err,
		)
	}

	for _, member := range tssRoundSixMembers {
		var receivedTssRoundFiveMessages []*tssRoundFiveMessage
		for _, tssRoundFiveMessage := range tssRoundFiveMessages {
			if tssRoundFiveMessage.senderID != member.id {
				receivedTssRoundFiveMessages = append(
					receivedTssRoundFiveMessages,
					tssRoundFiveMessage,
				)
			}
		}

		ctx, cancelCtx := context.WithTimeout(
			context.Background(),
			10*time.Second,
		)

		tssRoundSixMessage, err := member.tssRoundSix(
			ctx,
			receivedTssRoundFiveMessages,
		)
		if err != nil {
			cancelCtx()
			return nil, nil, fmt.Errorf(
				"cannot do TSS round six for member [%v]: [%v]",
				member.id,
				err,
			)
		}

		tssRoundSevenMembers = append(
			tssRoundSevenMembers,
			member.initializeTssRoundSeven(),
		)
		tssRoundSixMessages = append(tssRoundSixMessages, tssRoundSixMessage)

		cancelCtx()
	}

	return tssRoundSevenMembers, tssRoundSixMessages, nil
}

func initializeTssRoundEightMembersGroup(
	dishonestThreshold int,
	groupSize int,
) (
	[]*tssRoundEightMember,
	[]*tssRoundSevenMessage,
	error,
) {
	var tssRoundEightMembers []*tssRoundEightMember
	var tssRoundSevenMessages []*tssRoundSevenMessage

	tssRoundSevenMembers, tssRoundSixMessages, err :=
		initializeTssRoundSevenMembersGroup(
			dishonestThreshold,
			groupSize,
		)
	if err != nil {
		return nil, nil, fmt.Errorf(
			"cannot generate TSS round seven members group: [%v]",
			err,
		)
	}

	for _, member := range tssRoundSevenMembers {
		var receivedTssRoundSixMessages []*tssRoundSixMessage
		for _, tssRoundSixMessage := range tssRoundSixMessages {
			if tssRoundSixMessage.senderID != member.id {
				receivedTssRoundSixMessages = append(
					receivedTssRoundSixMessages,
					tssRoundSixMessage,
				)
			}
		}

		ctx, cancelCtx := context.WithTimeout(
			context.Background(),
			10*time.Second,
		)

		tssRoundSevenMessage, err := member.tssRoundSeven(
			ctx,
			receivedTssRoundSixMessages,
		)
		if err != nil {
			cancelCtx()
			return nil, nil, fmt.Errorf(
				"cannot do TSS round seven for member [%v]: [%v]",
				member.id,
				err,
			)
		}

		tssRoundEightMembers = append(
			tssRoundEightMembers,
			member.initializeTssRoundEight(),
		)
		tssRoundSevenMessages = append(tssRoundSevenMessages, tssRoundSevenMessage)

		cancelCtx()
	}

	return tssRoundEightMembers, tssRoundSevenMessages, nil
}

func initializeTssRoundNineMembersGroup(
	dishonestThreshold int,
	groupSize int,
) (
	[]*tssRoundNineMember,
	[]*tssRoundEightMessage,
	error,
) {
	var tssRoundNineMembers []*tssRoundNineMember
	var tssRoundEightMessages []*tssRoundEightMessage

	tssRoundEightMembers, tssRoundSevenMessages, err :=
		initializeTssRoundEightMembersGroup(
			dishonestThreshold,
			groupSize,
		)
	if err != nil {
		return nil, nil, fmt.Errorf(
			"cannot generate TSS round eight members group: [%v]",
			err,
		)
	}

	for _, member := range tssRoundEightMembers {
		var receivedTssRoundSevenMessages []*tssRoundSevenMessage
		for _, tssRoundSevenMessage := range tssRoundSevenMessages {
			if tssRoundSevenMessage.senderID != member.id {
				receivedTssRoundSevenMessages = append(
					receivedTssRoundSevenMessages,
					tssRoundSevenMessage,
				)
			}
		}

		ctx, cancelCtx := context.WithTimeout(
			context.Background(),
			10*time.Second,
		)

		tssRoundEightMessage, err := member.tssRoundEight(
			ctx,
			receivedTssRoundSevenMessages,
		)
		if err != nil {
			cancelCtx()
			return nil, nil, fmt.Errorf(
				"cannot do TSS round eight for member [%v]: [%v]",
				member.id,
				err,
			)
		}

		tssRoundNineMembers = append(
			tssRoundNineMembers,
			member.initializeTssRoundNine(),
		)
		tssRoundEightMessages = append(tssRoundEightMessages, tssRoundEightMessage)

		cancelCtx()
	}

	return tssRoundNineMembers, tssRoundEightMessages, nil
}

func initializeFinalizingMembersGroup(
	dishonestThreshold int,
	groupSize int,
) (
	[]*finalizingMember,
	[]*tssRoundNineMessage,
	error,
) {
	var finalizingMembers []*finalizingMember
	var tssRoundNineMessages []*tssRoundNineMessage

	tssRoundNineMembers, tssRoundEightMessages, err :=
		initializeTssRoundNineMembersGroup(
			dishonestThreshold,
			groupSize,
		)
	if err != nil {
		return nil, nil, fmt.Errorf(
			"cannot generate TSS round nine members group: [%v]",
			err,
		)
	}

	for _, member := range tssRoundNineMembers {
		var receivedTssRoundEightMessages []*tssRoundEightMessage
		for _, tssRoundEightMessage := range tssRoundEightMessages {
			if tssRoundEightMessage.senderID != member.id {
				receivedTssRoundEightMessages = append(
					receivedTssRoundEightMessages,
					tssRoundEightMessage,
				)
			}
		}

		ctx, cancelCtx := context.WithTimeout(
			context.Background(),
			10*time.Second,
		)

		tssRoundNineMessage, err := member.tssRoundNine(
			ctx,
			receivedTssRoundEightMessages,
		)
		if err != nil {
			cancelCtx()
			return nil, nil, fmt.Errorf(
				"cannot do TSS round nine for member [%v]: [%v]",
				member.id,
				err,
			)
		}

		finalizingMembers = append(
			finalizingMembers,
			member.initializeFinalization(),
		)
		tssRoundNineMessages = append(tssRoundNineMessages, tssRoundNineMessage)

		cancelCtx()
	}

	return finalizingMembers, tssRoundNineMessages, nil
}
