package signing

import (
	"context"
	"fmt"

	"github.com/bnb-chain/tss-lib/tss"
	"github.com/keep-network/keep-core/pkg/crypto/ephemeral"
	"github.com/keep-network/keep-core/pkg/protocol/group"
	"github.com/keep-network/keep-core/pkg/tecdsa/common"
)

// generateEphemeralKeyPair takes the group member list and generates an
// ephemeral ECDH keypair for every other group member. Generated public
// ephemeral keys are broadcasted within the group.
func (ekpgm *ephemeralKeyPairGeneratingMember) generateEphemeralKeyPair() (
	*ephemeralPublicKeyMessage,
	error,
) {
	ephemeralKeys := make(map[group.MemberIndex]*ephemeral.PublicKey)

	// Calculate ephemeral key pair for every other group member
	for _, member := range ekpgm.group.MemberIDs() {
		if member == ekpgm.id {
			// donâ€™t actually generate a key with ourselves
			continue
		}

		ephemeralKeyPair, err := ephemeral.GenerateKeyPair()
		if err != nil {
			return nil, err
		}

		// save the generated ephemeral key to our state
		ekpgm.ephemeralKeyPairs[member] = ephemeralKeyPair

		// store the public key to the map for the message
		ephemeralKeys[member] = ephemeralKeyPair.PublicKey
	}

	return &ephemeralPublicKeyMessage{
		senderID:            ekpgm.id,
		ephemeralPublicKeys: ephemeralKeys,
		sessionID:           ekpgm.sessionID,
	}, nil
}

// generateSymmetricKeys attempts to generate symmetric keys for all remote group
// members via ECDH. It generates this symmetric key for each remote group member
// by doing an ECDH between the ephemeral private key generated for a remote
// group member, and the public key for this member, generated and broadcasted by
// the remote group member.
func (skgm *symmetricKeyGeneratingMember) generateSymmetricKeys(
	ephemeralPubKeyMessages []*ephemeralPublicKeyMessage,
) error {
	for _, ephemeralPubKeyMessage := range ephemeralPubKeyMessages {
		otherMember := ephemeralPubKeyMessage.senderID

		if !skgm.isValidEphemeralPublicKeyMessage(ephemeralPubKeyMessage) {
			return fmt.Errorf(
				"member [%v] sent invalid ephemeral public key message",
				otherMember,
			)
		}

		// Find the ephemeral key pair generated by this group member for
		// the other group member.
		ephemeralKeyPair, ok := skgm.ephemeralKeyPairs[otherMember]
		if !ok {
			return fmt.Errorf(
				"ephemeral key pair does not exist for member [%v]",
				otherMember,
			)
		}

		// Get the ephemeral private key generated by this group member for
		// the other group member.
		thisMemberEphemeralPrivateKey := ephemeralKeyPair.PrivateKey

		// Get the ephemeral public key broadcasted by the other group member,
		// which was intended for this group member.
		otherMemberEphemeralPublicKey :=
			ephemeralPubKeyMessage.ephemeralPublicKeys[skgm.id]

		// Create symmetric key for the current group member and the other
		// group member by ECDH'ing the public and private key.
		symmetricKey := thisMemberEphemeralPrivateKey.Ecdh(
			otherMemberEphemeralPublicKey,
		)
		skgm.symmetricKeys[otherMember] = symmetricKey
	}

	return nil
}

// isValidEphemeralPublicKeyMessage validates a given EphemeralPublicKeyMessage.
// Message is considered valid if it contains ephemeral public keys for
// all other group members.
func (skgm *symmetricKeyGeneratingMember) isValidEphemeralPublicKeyMessage(
	message *ephemeralPublicKeyMessage,
) bool {
	for _, memberID := range skgm.group.MemberIDs() {
		if memberID == message.senderID {
			// Message contains ephemeral public keys only for other group members
			continue
		}

		if _, ok := message.ephemeralPublicKeys[memberID]; !ok {
			skgm.logger.Warnf(
				"[member:%v] ephemeral public key message from member [%v] "+
					"does not contain public key for member [%v]",
				skgm.id,
				message.senderID,
				memberID,
			)
			return false
		}
	}

	return true
}

// tssRoundOne starts the TSS process by executing its first round. The
// outcome of that round is a message containing TSS round one components.
// This function performs the first round of TSS for all messages being signed,
// sequentially.
func (trom *tssRoundOneMember) tssRoundOne(
	ctx context.Context,
) (*tssRoundOneCompositeMessage, error) {
	// All TSS round one messages grouped by the data being signed
	tssRoundOneMessages := make(map[string]*tssRoundOneMessage)

	for messageToSign, tssState := range trom.tssStates {
		tssMessage, err := trom.tssRoundOneInternal(ctx, tssState)
		if err != nil {
			return nil, err
		}

		tssRoundOneMessages[messageToSign] = tssMessage
	}

	return &tssRoundOneCompositeMessage{
		senderID:            trom.id,
		sessionID:           trom.sessionID,
		tssRoundOneMessages: tssRoundOneMessages,
	}, nil
}

// tssRoundOneInternal starts the TSS process by executing its first round. The
// outcome of that round is a message containing TSS round one components.
// This function is called in a context of a single message being signed for
// the given TSS state.
func (trom *tssRoundOneMember) tssRoundOneInternal(
	ctx context.Context,
	tssState *tssState,
) (*tssRoundOneMessage, error) {
	if err := tssState.tssParty.Start(); err != nil {
		return nil, fmt.Errorf(
			"failed to start TSS round one: [%v]",
			err,
		)
	}

	// Listen for TSS outgoing messages. We expect N-1 P2P messages (where N
	// is the number of properly operating members) and 1 broadcast message.
	var tssMessages []tss.Message
outgoingMessagesLoop:
	for {
		select {
		case tssMessage := <-tssState.tssOutgoingMessagesChan:
			tssMessages = append(tssMessages, tssMessage)

			if len(tssMessages) == len(trom.group.OperatingMemberIDs()) {
				break outgoingMessagesLoop
			}
		case <-ctx.Done():
			return nil, fmt.Errorf(
				"TSS round one outgoing messages were not " +
					"generated on time",
			)
		}
	}

	broadcastPayload, peersPayload, err := common.AggregateTssMessages(
		tssMessages,
		trom.symmetricKeys,
		trom.identityConverter,
	)
	if err != nil {
		return nil, fmt.Errorf(
			"cannot aggregate TSS round one outgoing messages: [%w]",
			err,
		)
	}

	ok := len(broadcastPayload) > 0 &&
		len(peersPayload) == len(trom.group.OperatingMemberIDs())-1
	if !ok {
		return nil, fmt.Errorf("cannot produce a proper TSS round one message")
	}

	return &tssRoundOneMessage{
		broadcastPayload: broadcastPayload,
		peersPayload:     peersPayload,
	}, nil
}

// tssRoundTwo performs the second round of the TSS process. The outcome of
// that round is a message containing TSS round two components.
// This function performs the second round of TSS for all messages being signed,
// sequentially.
func (trtm *tssRoundTwoMember) tssRoundTwo(
	ctx context.Context,
	tssRoundOneCompositeMessages []*tssRoundOneCompositeMessage,
) (*tssRoundTwoCompositeMessage, error) {
	tssRoundTwoMessages := make(map[string]*tssRoundTwoMessage)

	// For every message being signed...
	for messageToSign, tssState := range trtm.tssStates {

		// First, flatten the composite TSS messages. We go through all composite
		// TSS messages, find the ones for the given message being signed and
		// group them in a map, keyed by the sender member index.
		tssRoundOneMessages := make(map[group.MemberIndex]*tssRoundOneMessage)

		for _, tssRoundOneCompositeMessage := range tssRoundOneCompositeMessages {
			message, ok := tssRoundOneCompositeMessage.tssRoundOneMessages[messageToSign]
			if !ok {
				return nil, fmt.Errorf(
					"missing tss round one message from member [%v] to sign message [%v]",
					tssRoundOneCompositeMessage.senderID,
					messageToSign,
				)
			}

			tssRoundOneMessages[tssRoundOneCompositeMessage.senderID] = message
		}

		tssRoundTwoMessage, err := trtm.tssRoundTwoInternal(
			ctx,
			tssState,
			tssRoundOneMessages,
		)
		if err != nil {
			return nil, err
		}

		tssRoundTwoMessages[messageToSign] = tssRoundTwoMessage
	}

	return &tssRoundTwoCompositeMessage{
		senderID:            trtm.id,
		sessionID:           trtm.sessionID,
		tssRoundTwoMessages: tssRoundTwoMessages,
	}, nil
}

// tssRoundTwoInternal performs the second round of the TSS process. The outcome
// of that round is a message containing TSS round two components.
// This function is called in a context of a single message being signed for
// the given TSS state.
func (trtm *tssRoundTwoMember) tssRoundTwoInternal(
	ctx context.Context,
	tssState *tssState,
	tssRoundOneMessages map[group.MemberIndex]*tssRoundOneMessage,
) (*tssRoundTwoMessage, error) {
	// Use messages from round one to update the local party and advance
	// to round two.
	for senderID, tssRoundOneMessage := range tssRoundOneMessages {
		senderTssPartyID := common.ResolveSortedTssPartyID(
			tssState.tssParameters,
			senderID,
			trtm.identityConverter,
		)

		// Update the local TSS party using the broadcast part of the message
		// produced in round one.
		_, tssErr := tssState.tssParty.UpdateFromBytes(
			tssRoundOneMessage.broadcastPayload,
			senderTssPartyID,
			true,
		)
		if tssErr != nil {
			return nil, fmt.Errorf(
				"cannot update using the broadcast part of the "+
					"TSS round one message from member [%v]: [%v]",
				senderID,
				tssErr,
			)
		}

		// Check if the sender produced a P2P part of the TSS round one message
		// for this member.
		encryptedPeerPayload, ok := tssRoundOneMessage.peersPayload[trtm.id]
		if !ok {
			return nil, fmt.Errorf(
				"no P2P part in the TSS round one message from member [%v]",
				senderID,
			)
		}
		// Get the symmetric key with the sender. If the symmetric key
		// cannot be found, something awful happened.
		symmetricKey, ok := trtm.symmetricKeys[senderID]
		if !ok {
			return nil, fmt.Errorf(
				"cannot get symmetric key with member [%v]",
				senderID,
			)
		}
		// Decrypt the P2P part of the TSS round one message.
		peerPayload, err := symmetricKey.Decrypt(encryptedPeerPayload)
		if err != nil {
			return nil, fmt.Errorf(
				"cannot decrypt P2P part of the TSS round one "+
					"message from member [%v]: [%v]",
				senderID,
				err,
			)
		}
		// Update the local TSS party using the P2P part of the message
		// produced in round one.
		_, tssErr = tssState.tssParty.UpdateFromBytes(
			peerPayload,
			senderTssPartyID,
			false,
		)
		if tssErr != nil {
			return nil, fmt.Errorf(
				"cannot update using the P2P part of the TSS round "+
					"one message from member [%v]: [%v]",
				senderID,
				tssErr,
			)
		}
	}

	// Listen for TSS outgoing messages. We expect N-1 P2P messages (where N
	// is the number of properly operating members) and 0 broadcast messages.
	var tssMessages []tss.Message
outgoingMessagesLoop:
	for {
		select {
		case tssMessage := <-tssState.tssOutgoingMessagesChan:
			tssMessages = append(tssMessages, tssMessage)

			if len(tssMessages) == len(trtm.group.OperatingMemberIDs())-1 {
				break outgoingMessagesLoop
			}
		case <-ctx.Done():
			return nil, fmt.Errorf(
				"TSS round two outgoing messages were not " +
					"generated on time",
			)
		}
	}

	broadcastPayload, peersPayload, err := common.AggregateTssMessages(
		tssMessages,
		trtm.symmetricKeys,
		trtm.identityConverter,
	)
	if err != nil {
		return nil, fmt.Errorf(
			"cannot aggregate TSS round two outgoing messages: [%w]",
			err,
		)
	}

	// Unlike the previous phase (TSS round 1), we don't expect a broadcast
	// payload here.
	ok := len(broadcastPayload) == 0 &&
		len(peersPayload) == len(trtm.group.OperatingMemberIDs())-1
	if !ok {
		return nil, fmt.Errorf("cannot produce a proper TSS round two message")
	}

	return &tssRoundTwoMessage{
		peersPayload: peersPayload,
	}, nil
}

// tssRoundThree performs the third round of the TSS process. The outcome of
// that round is a message containing TSS round three components.
// This function performs the third round of TSS for all messages being signed,
// sequentially.
func (trtm *tssRoundThreeMember) tssRoundThree(
	ctx context.Context,
	tssRoundTwoCompositeMessages []*tssRoundTwoCompositeMessage,
) (*tssRoundThreeCompositeMessage, error) {
	tssRoundThreeMessages := make(map[string]*tssRoundThreeMessage)

	// For every message being signed...
	for messageToSign, tssState := range trtm.tssStates {

		// First, flatten the composite TSS messages. We go through all composite
		// TSS messages, find the ones for the given message being signed and
		// group them in a map, keyed by the sender member index.
		tssRoundTwoMessages := make(map[group.MemberIndex]*tssRoundTwoMessage)

		for _, tssRoundTwoCompositeMessage := range tssRoundTwoCompositeMessages {
			message, ok := tssRoundTwoCompositeMessage.tssRoundTwoMessages[messageToSign]
			if !ok {
				return nil, fmt.Errorf(
					"missing tss round two message from member [%v] to sign message [%v]",
					tssRoundTwoCompositeMessage.senderID,
					messageToSign,
				)
			}

			tssRoundTwoMessages[tssRoundTwoCompositeMessage.senderID] = message
		}

		tssRoundThreeMessage, err := trtm.tssRoundThreeInternal(
			ctx,
			tssState,
			tssRoundTwoMessages,
		)
		if err != nil {
			return nil, err
		}

		tssRoundThreeMessages[messageToSign] = tssRoundThreeMessage
	}

	return &tssRoundThreeCompositeMessage{
		senderID:              trtm.id,
		sessionID:             trtm.sessionID,
		tssRoundThreeMessages: tssRoundThreeMessages,
	}, nil
}

// tssRoundThreeInternal performs the third round of the TSS process. The outcome
// of that round is a message containing TSS round three components.
// This function is called in a context of a single message being signed for
// the given TSS state.
func (trtm *tssRoundThreeMember) tssRoundThreeInternal(
	ctx context.Context,
	tssState *tssState,
	tssRoundTwoMessages map[group.MemberIndex]*tssRoundTwoMessage,
) (*tssRoundThreeMessage, error) {
	// Use messages from round two to update the local party and advance
	// to round three.
	for senderID, tssRoundTwoMessage := range tssRoundTwoMessages {
		senderTssPartyID := common.ResolveSortedTssPartyID(
			tssState.tssParameters,
			senderID,
			trtm.identityConverter,
		)

		// Check if the sender produced a P2P part of the TSS round two message
		// for this member.
		encryptedPeerPayload, ok := tssRoundTwoMessage.peersPayload[trtm.id]
		if !ok {
			return nil, fmt.Errorf(
				"no P2P part in the TSS round two message from member [%v]",
				senderID,
			)
		}
		// Get the symmetric key with the sender. If the symmetric key
		// cannot be found, something awful happened.
		symmetricKey, ok := trtm.symmetricKeys[senderID]
		if !ok {
			return nil, fmt.Errorf(
				"cannot get symmetric key with member [%v]",
				senderID,
			)
		}
		// Decrypt the P2P part of the TSS round two message.
		peerPayload, err := symmetricKey.Decrypt(encryptedPeerPayload)
		if err != nil {
			return nil, fmt.Errorf(
				"cannot decrypt P2P part of the TSS round two "+
					"message from member [%v]: [%v]",
				senderID,
				err,
			)
		}
		// Update the local TSS party using the P2P part of the message
		// produced in round two.
		_, tssErr := tssState.tssParty.UpdateFromBytes(
			peerPayload,
			senderTssPartyID,
			false,
		)
		if tssErr != nil {
			return nil, fmt.Errorf(
				"cannot update using the P2P part of the TSS round "+
					"two message from member [%v]: [%v]",
				senderID,
				tssErr,
			)
		}
	}

	// We expect exactly one TSS message to be produced in this phase.
	select {
	case tssMessage := <-tssState.tssOutgoingMessagesChan:
		tssMessageBytes, _, err := tssMessage.WireBytes()
		if err != nil {
			return nil, fmt.Errorf(
				"failed to encode TSS round three message: [%v]",
				err,
			)
		}

		return &tssRoundThreeMessage{broadcastPayload: tssMessageBytes}, nil
	case <-ctx.Done():
		return nil, fmt.Errorf(
			"TSS round three outgoing message was not generated on time",
		)
	}
}

// tssRoundFour performs the fourth round of the TSS process. The outcome of
// that round is a message containing TSS round four components.
// This function performs the fourth round of TSS for all messages being signed,
// sequentially.
func (trfm *tssRoundFourMember) tssRoundFour(
	ctx context.Context,
	tssRoundThreeCompositeMessages []*tssRoundThreeCompositeMessage,
) (*tssRoundFourCompositeMessage, error) {
	tssRoundFourMessages := make(map[string]*tssRoundFourMessage)

	// For every message being signed...
	for messageToSign, tssState := range trfm.tssStates {

		// First, flatten the composite TSS messages. We go through all composite
		// TSS messages, find the ones for the given message being signed and
		// group them in a map, keyed by the sender member index.
		tssRoundThreeMessages := make(map[group.MemberIndex]*tssRoundThreeMessage)

		for _, tssRoundThreeCompositeMessage := range tssRoundThreeCompositeMessages {
			message, ok := tssRoundThreeCompositeMessage.tssRoundThreeMessages[messageToSign]
			if !ok {
				return nil, fmt.Errorf(
					"missing tss round three message from member [%v] to sign message [%v]",
					tssRoundThreeCompositeMessage.senderID,
					messageToSign,
				)
			}

			tssRoundThreeMessages[tssRoundThreeCompositeMessage.senderID] = message
		}

		tssRoundFourMessage, err := trfm.tssRoundFourInternal(
			ctx,
			tssState,
			tssRoundThreeMessages,
		)
		if err != nil {
			return nil, err
		}

		tssRoundFourMessages[messageToSign] = tssRoundFourMessage
	}

	return &tssRoundFourCompositeMessage{
		senderID:             trfm.id,
		sessionID:            trfm.sessionID,
		tssRoundFourMessages: tssRoundFourMessages,
	}, nil
}

// tssRoundFourInternal performs the fourth round of the TSS process. The outcome
// of that round is a message containing TSS round four components.
// This function is called in a context of a single message being signed for
// the given TSS state.
func (trfm *tssRoundFourMember) tssRoundFourInternal(
	ctx context.Context,
	tssState *tssState,
	tssRoundThreeMessages map[group.MemberIndex]*tssRoundThreeMessage,
) (*tssRoundFourMessage, error) {
	// Use messages from round three to update the local party and advance
	// to round four.
	for senderID, tssRoundThreeMessage := range tssRoundThreeMessages {
		_, tssErr := tssState.tssParty.UpdateFromBytes(
			tssRoundThreeMessage.broadcastPayload,
			common.ResolveSortedTssPartyID(
				tssState.tssParameters,
				senderID,
				trfm.identityConverter,
			),
			true,
		)
		if tssErr != nil {
			return nil, fmt.Errorf(
				"cannot update using TSS round three message "+
					"from member [%v]: [%v]",
				senderID,
				tssErr,
			)
		}
	}

	// We expect exactly one TSS message to be produced in this phase.
	select {
	case tssMessage := <-tssState.tssOutgoingMessagesChan:
		tssMessageBytes, _, err := tssMessage.WireBytes()
		if err != nil {
			return nil, fmt.Errorf(
				"failed to encode TSS round four message: [%v]",
				err,
			)
		}

		return &tssRoundFourMessage{
			broadcastPayload: tssMessageBytes,
		}, nil
	case <-ctx.Done():
		return nil, fmt.Errorf(
			"TSS round four outgoing message was not generated on time",
		)
	}
}

// tssRoundFive performs the fifth round of the TSS process. The outcome of
// that round is a message containing TSS round five components.
// This function performs the fifth round of TSS for all messages being signed,
// sequentially.
func (trfm *tssRoundFiveMember) tssRoundFive(
	ctx context.Context,
	tssRoundFourCompositeMessages []*tssRoundFourCompositeMessage,
) (*tssRoundFiveCompositeMessage, error) {
	tssRoundFiveMessages := make(map[string]*tssRoundFiveMessage)

	// For every message being signed...
	for messageToSign, tssState := range trfm.tssStates {

		// First, flatten the composite TSS messages. We go through all composite
		// TSS messages, find the ones for the given message being signed and
		// group them in a map, keyed by the sender member index.
		tssRoundFourMessages := make(map[group.MemberIndex]*tssRoundFourMessage)

		for _, tssRoundFourCompositeMessage := range tssRoundFourCompositeMessages {
			message, ok := tssRoundFourCompositeMessage.tssRoundFourMessages[messageToSign]
			if !ok {
				return nil, fmt.Errorf(
					"missing tss round four message from member [%v] to sign message [%v]",
					tssRoundFourCompositeMessage.senderID,
					messageToSign,
				)
			}

			tssRoundFourMessages[tssRoundFourCompositeMessage.senderID] = message
		}

		tssRoundFiveMessage, err := trfm.tssRoundFiveInternal(
			ctx,
			tssState,
			tssRoundFourMessages,
		)
		if err != nil {
			return nil, err
		}

		tssRoundFiveMessages[messageToSign] = tssRoundFiveMessage
	}

	return &tssRoundFiveCompositeMessage{
		senderID:             trfm.id,
		sessionID:            trfm.sessionID,
		tssRoundFiveMessages: tssRoundFiveMessages,
	}, nil
}

// tssRoundFive performs the fifth round of the TSS process. The outcome of
// that round is a message containing TSS round five components.
// This function is called in a context of a single message being signed for
// the given TSS state.
func (trfm *tssRoundFiveMember) tssRoundFiveInternal(
	ctx context.Context,
	tssState *tssState,
	tssRoundFourMessages map[group.MemberIndex]*tssRoundFourMessage,
) (*tssRoundFiveMessage, error) {
	// Use messages from round four to update the local party and advance
	// to round five.
	for senderID, tssRoundFourMessage := range tssRoundFourMessages {

		_, tssErr := tssState.tssParty.UpdateFromBytes(
			tssRoundFourMessage.broadcastPayload,
			common.ResolveSortedTssPartyID(
				tssState.tssParameters,
				senderID,
				trfm.identityConverter,
			),
			true,
		)
		if tssErr != nil {
			return nil, fmt.Errorf(
				"cannot update using TSS round four message "+
					"from member [%v]: [%v]",
				senderID,
				tssErr,
			)
		}
	}

	// We expect exactly one TSS message to be produced in this phase.
	select {
	case tssMessage := <-tssState.tssOutgoingMessagesChan:
		tssMessageBytes, _, err := tssMessage.WireBytes()
		if err != nil {
			return nil, fmt.Errorf(
				"failed to encode TSS round five message: [%v]",
				err,
			)
		}

		return &tssRoundFiveMessage{
			broadcastPayload: tssMessageBytes,
		}, nil
	case <-ctx.Done():
		return nil, fmt.Errorf(
			"TSS round five outgoing message was not generated on time",
		)
	}
}

// tssRoundSix performs the sixth round of the TSS process. The outcome of
// that round is a message containing TSS round six components.
// This function performs the first round of TSS for all messages being signed,
// sequentially.
func (trsm *tssRoundSixMember) tssRoundSix(
	ctx context.Context,
	tssRoundFiveCompositeMessages []*tssRoundFiveCompositeMessage,
) (*tssRoundSixCompositeMessage, error) {
	tssRoundSixMessages := make(map[string]*tssRoundSixMessage)

	// For every message being signed...
	for messageToSign, tssState := range trsm.tssStates {

		// First, flatten the composite TSS messages. We go through all composite
		// TSS messages, find the ones for the given message being signed and
		// group them in a map, keyed by the sender member index.
		tssRoundFiveMessages := make(map[group.MemberIndex]*tssRoundFiveMessage)

		for _, tssRoundFiveCompositeMessage := range tssRoundFiveCompositeMessages {
			message, ok := tssRoundFiveCompositeMessage.tssRoundFiveMessages[messageToSign]
			if !ok {
				return nil, fmt.Errorf(
					"missing tss round five message from member [%v] to sign message [%v]",
					tssRoundFiveCompositeMessage.senderID,
					messageToSign,
				)
			}

			tssRoundFiveMessages[tssRoundFiveCompositeMessage.senderID] = message
		}

		tssRoundSixMessage, err := trsm.tssRoundSixInternal(
			ctx,
			tssState,
			tssRoundFiveMessages,
		)
		if err != nil {
			return nil, err
		}

		tssRoundSixMessages[messageToSign] = tssRoundSixMessage
	}

	return &tssRoundSixCompositeMessage{
		senderID:            trsm.id,
		sessionID:           trsm.sessionID,
		tssRoundSixMessages: tssRoundSixMessages,
	}, nil
}

// tssRoundSixInternal performs the sixth round of the TSS process. The outcome
// of that round is a message containing TSS round six components.
// This function is called in a context of a single message being signed for
// the given TSS state.
func (trsm *tssRoundSixMember) tssRoundSixInternal(
	ctx context.Context,
	tssState *tssState,
	tssRoundFiveMessages map[group.MemberIndex]*tssRoundFiveMessage,
) (*tssRoundSixMessage, error) {
	// Use messages from round five to update the local party and advance
	// to round six.
	for senderID, tssRoundFiveMessage := range tssRoundFiveMessages {
		_, tssErr := tssState.tssParty.UpdateFromBytes(
			tssRoundFiveMessage.broadcastPayload,
			common.ResolveSortedTssPartyID(
				tssState.tssParameters,
				senderID,
				trsm.identityConverter,
			),
			true,
		)
		if tssErr != nil {
			return nil, fmt.Errorf(
				"cannot update using TSS round five message "+
					"from member [%v]: [%v]",
				senderID,
				tssErr,
			)
		}
	}

	// We expect exactly one TSS message to be produced in this phase.
	select {
	case tssMessage := <-tssState.tssOutgoingMessagesChan:
		tssMessageBytes, _, err := tssMessage.WireBytes()
		if err != nil {
			return nil, fmt.Errorf(
				"failed to encode TSS round six message: [%v]",
				err,
			)
		}

		return &tssRoundSixMessage{
			broadcastPayload: tssMessageBytes,
		}, nil
	case <-ctx.Done():
		return nil, fmt.Errorf(
			"TSS round six outgoing message was not generated on time",
		)
	}
}

// tssRoundSeven performs the seventh round of the TSS process. The outcome of
// that round is a message containing TSS round seven components.
// This function performs the seventh round of TSS for all messages being signed,
// sequentially.
func (trsm *tssRoundSevenMember) tssRoundSeven(
	ctx context.Context,
	tssRoundSixCompositeMessages []*tssRoundSixCompositeMessage,
) (*tssRoundSevenCompositeMessage, error) {
	tssRoundSevenMessages := make(map[string]*tssRoundSevenMessage)

	// For every message being signed...
	for messageToSign, tssState := range trsm.tssStates {

		// First, flatten the composite TSS messages. We go through all composite
		// TSS messages, find the ones for the given message being signed and
		// group them in a map, keyed by the sender member index.
		tssRoundSixMessages := make(map[group.MemberIndex]*tssRoundSixMessage)

		for _, tssRoundSixCompositeMessage := range tssRoundSixCompositeMessages {
			message, ok := tssRoundSixCompositeMessage.tssRoundSixMessages[messageToSign]
			if !ok {
				return nil, fmt.Errorf(
					"missing tss round six message from member [%v] to sign message [%v]",
					tssRoundSixCompositeMessage.senderID,
					messageToSign,
				)
			}

			tssRoundSixMessages[tssRoundSixCompositeMessage.senderID] = message
		}

		tssRoundSevenMessage, err := trsm.tssRoundSevenInternal(
			ctx,
			tssState,
			tssRoundSixMessages,
		)
		if err != nil {
			return nil, err
		}

		tssRoundSevenMessages[messageToSign] = tssRoundSevenMessage
	}

	return &tssRoundSevenCompositeMessage{
		senderID:              trsm.id,
		sessionID:             trsm.sessionID,
		tssRoundSevenMessages: tssRoundSevenMessages,
	}, nil
}

// tssRoundSeven performs the seventh round of the TSS process. The outcome of
// that round is a message containing TSS round seven components.
// This function is called in a context of a single message being signed for
// the given TSS state.
func (trsm *tssRoundSevenMember) tssRoundSevenInternal(
	ctx context.Context,
	tssState *tssState,
	tssRoundSixMessages map[group.MemberIndex]*tssRoundSixMessage,
) (*tssRoundSevenMessage, error) {
	// Use messages from round six to update the local party and advance
	// to round seven.
	for senderID, tssRoundSixMessage := range tssRoundSixMessages {
		_, tssErr := tssState.tssParty.UpdateFromBytes(
			tssRoundSixMessage.broadcastPayload,
			common.ResolveSortedTssPartyID(
				tssState.tssParameters,
				senderID,
				trsm.identityConverter,
			),
			true,
		)
		if tssErr != nil {
			return nil, fmt.Errorf(
				"cannot update using TSS round six message "+
					"from member [%v]: [%v]",
				senderID,
				tssErr,
			)
		}
	}

	// We expect exactly one TSS message to be produced in this phase.
	select {
	case tssMessage := <-tssState.tssOutgoingMessagesChan:
		tssMessageBytes, _, err := tssMessage.WireBytes()
		if err != nil {
			return nil, fmt.Errorf(
				"failed to encode TSS round seven message: [%v]",
				err,
			)
		}

		return &tssRoundSevenMessage{
			broadcastPayload: tssMessageBytes,
		}, nil
	case <-ctx.Done():
		return nil, fmt.Errorf(
			"TSS round seven outgoing message was not generated on time",
		)
	}
}

// tssRoundEight performs the eighth round of the TSS process. The outcome of
// that round is a message containing TSS round eight components.
// This function performs the eighth round of TSS for all messages being signed,
// sequentially.
func (trem *tssRoundEightMember) tssRoundEight(
	ctx context.Context,
	tssRoundSevenCompositeMessages []*tssRoundSevenCompositeMessage,
) (*tssRoundEightCompositeMessage, error) {
	tssRoundEightMessages := make(map[string]*tssRoundEightMessage)

	// For every message being signed...
	for messageToSign, tssState := range trem.tssStates {

		// First, flatten the composite TSS messages. We go through all composite
		// TSS messages, find the ones for the given message being signed and
		// group them in a map, keyed by the sender member index.
		tssRoundSevenMessages := make(map[group.MemberIndex]*tssRoundSevenMessage)

		for _, tssRoundSevenCompositeMessage := range tssRoundSevenCompositeMessages {
			message, ok := tssRoundSevenCompositeMessage.tssRoundSevenMessages[messageToSign]
			if !ok {
				return nil, fmt.Errorf(
					"missing tss round seven message from member [%v] to sign message [%v]",
					tssRoundSevenCompositeMessage.senderID,
					messageToSign,
				)
			}

			tssRoundSevenMessages[tssRoundSevenCompositeMessage.senderID] = message
		}

		tssRoundEightMessage, err := trem.tssRoundEightInternal(
			ctx,
			tssState,
			tssRoundSevenMessages,
		)
		if err != nil {
			return nil, err
		}

		tssRoundEightMessages[messageToSign] = tssRoundEightMessage
	}

	return &tssRoundEightCompositeMessage{
		senderID:              trem.id,
		sessionID:             trem.sessionID,
		tssRoundEightMessages: tssRoundEightMessages,
	}, nil
}

// tssRoundEightInternal performs the eighth round of the TSS process. The outcome
// of that round is a message containing TSS round eight components.
// This function is called in a context of a single message being signed for
// the given TSS state.
func (trem *tssRoundEightMember) tssRoundEightInternal(
	ctx context.Context,
	tssState *tssState,
	tssRoundSevenMessages map[group.MemberIndex]*tssRoundSevenMessage,
) (*tssRoundEightMessage, error) {
	// Use messages from round seven to update the local party and advance
	// to round eight.
	for senderID, tssRoundSevenMessage := range tssRoundSevenMessages {
		_, tssErr := tssState.tssParty.UpdateFromBytes(
			tssRoundSevenMessage.broadcastPayload,
			common.ResolveSortedTssPartyID(
				tssState.tssParameters,
				senderID,
				trem.identityConverter,
			),
			true,
		)
		if tssErr != nil {
			return nil, fmt.Errorf(
				"cannot update using TSS round seven message "+
					"from member [%v]: [%v]",
				senderID,
				tssErr,
			)
		}
	}

	// We expect exactly one TSS message to be produced in this phase.
	select {
	case tssMessage := <-tssState.tssOutgoingMessagesChan:
		tssMessageBytes, _, err := tssMessage.WireBytes()
		if err != nil {
			return nil, fmt.Errorf(
				"failed to encode TSS round eight message: [%v]",
				err,
			)
		}

		return &tssRoundEightMessage{
			broadcastPayload: tssMessageBytes,
		}, nil
	case <-ctx.Done():
		return nil, fmt.Errorf(
			"TSS round eight outgoing message was not generated on time",
		)
	}
}

// tssRoundNine performs the ninth round of the TSS process. The outcome of
// that round is a message containing TSS round nine components.
// This function performs the ninth round of TSS for all messages being signed,
// sequentially.
func (trnm *tssRoundNineMember) tssRoundNine(
	ctx context.Context,
	tssRoundEightCompositeMessages []*tssRoundEightCompositeMessage,
) (*tssRoundNineCompositeMessage, error) {
	tssRoundNineMessages := make(map[string]*tssRoundNineMessage)

	// For every message being signed...
	for messageToSign, tssState := range trnm.tssStates {

		// First, flatten the composite TSS messages. We go through all composite
		// TSS messages, find the ones for the given message being signed and
		// group them in a map, keyed by the sender member index.
		tssRoundEightMessages := make(map[group.MemberIndex]*tssRoundEightMessage)

		for _, tssRoundEightCompositeMessage := range tssRoundEightCompositeMessages {
			message, ok := tssRoundEightCompositeMessage.tssRoundEightMessages[messageToSign]
			if !ok {
				return nil, fmt.Errorf(
					"missing tss round eight message from member [%v] to sign message [%v]",
					tssRoundEightCompositeMessage.senderID,
					messageToSign,
				)
			}

			tssRoundEightMessages[tssRoundEightCompositeMessage.senderID] = message
		}

		tssRoundNineMessage, err := trnm.tssRoundNineInternal(
			ctx,
			tssState,
			tssRoundEightMessages,
		)
		if err != nil {
			return nil, err
		}

		tssRoundNineMessages[messageToSign] = tssRoundNineMessage
	}

	return &tssRoundNineCompositeMessage{
		senderID:             trnm.id,
		sessionID:            trnm.sessionID,
		tssRoundNineMessages: tssRoundNineMessages,
	}, nil
}

// tssRoundNineInternal performs the ninth round of the TSS process. The outcome
// of that round is a message containing TSS round nine components.
// This function is called in a context of a single message being signed for
// the given TSS state.
func (trnm *tssRoundNineMember) tssRoundNineInternal(
	ctx context.Context,
	tssState *tssState,
	tssRoundEightMessages map[group.MemberIndex]*tssRoundEightMessage,
) (*tssRoundNineMessage, error) {
	// Use messages from round eight to update the local party and advance
	// to round nine.
	for senderID, tssRoundEightMessage := range tssRoundEightMessages {
		_, tssErr := tssState.tssParty.UpdateFromBytes(
			tssRoundEightMessage.broadcastPayload,
			common.ResolveSortedTssPartyID(
				tssState.tssParameters,
				senderID,
				trnm.identityConverter,
			),
			true,
		)
		if tssErr != nil {
			return nil, fmt.Errorf(
				"cannot update using TSS round eight message "+
					"from member [%v]: [%v]",
				senderID,
				tssErr,
			)
		}
	}

	// We expect exactly one TSS message to be produced in this phase.
	select {
	case tssMessage := <-tssState.tssOutgoingMessagesChan:
		tssMessageBytes, _, err := tssMessage.WireBytes()
		if err != nil {
			return nil, fmt.Errorf(
				"failed to encode TSS round nine message: [%v]",
				err,
			)
		}

		return &tssRoundNineMessage{
			broadcastPayload: tssMessageBytes,
		}, nil
	case <-ctx.Done():
		return nil, fmt.Errorf(
			"TSS round nine outgoing message was not generated on time",
		)
	}
}

// tssFinalize finalizes the TSS process by producing a result.
// This function finalizes TSS process for all messages being signed,
// sequentially.
func (fm *finalizingMember) tssFinalize(
	ctx context.Context,
	tssRoundNineCompositeMessages []*tssRoundNineCompositeMessage,
) error {
	// For every message being signed...
	for messageToSign, tssState := range fm.tssStates {

		// First, flatten the composite TSS messages. We go through all composite
		// TSS messages, find the ones for the given message being signed and
		// group them in a map, keyed by the sender member index.
		tssRoundNineMessages := make(map[group.MemberIndex]*tssRoundNineMessage)

		for _, tssRoundNineCompositeMessage := range tssRoundNineCompositeMessages {
			message, ok := tssRoundNineCompositeMessage.tssRoundNineMessages[messageToSign]
			if !ok {
				return fmt.Errorf(
					"missing tss round nine message from member [%v] to sign message [%v]",
					tssRoundNineCompositeMessage.senderID,
					messageToSign,
				)
			}

			tssRoundNineMessages[tssRoundNineCompositeMessage.senderID] = message
		}

		err := fm.tssFinalizeInternal(
			ctx,
			tssState,
			tssRoundNineMessages,
		)
		if err != nil {
			return err
		}
	}

	return nil
}

// tssFinalize finalizes the TSS process by producing a result.
// This function is called in a context of a single message being signed for
// the given TSS state.
func (fm *finalizingMember) tssFinalizeInternal(
	ctx context.Context,
	tssState *tssState,
	tssRoundNineMessages map[group.MemberIndex]*tssRoundNineMessage,
) error {
	// Use messages from round nine to update the local party and get the
	// result.
	for senderID, tssRoundNineMessage := range tssRoundNineMessages {
		_, tssErr := tssState.tssParty.UpdateFromBytes(
			tssRoundNineMessage.broadcastPayload,
			common.ResolveSortedTssPartyID(
				tssState.tssParameters,
				senderID,
				fm.identityConverter,
			),
			true,
		)
		if tssErr != nil {
			return fmt.Errorf(
				"cannot update using TSS round nine message "+
					"from member [%v]: [%v]",
				senderID,
				tssErr,
			)
		}
	}

	select {
	case tssResult := <-tssState.tssResultChan:
		fm.tssResult = &tssResult
		return nil
	case <-ctx.Done():
		return fmt.Errorf(
			"TSS result was not generated on time",
		)
	}
}
