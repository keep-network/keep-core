package generator

import (
	"context"
	"fmt"
	"math/big"
	"runtime"
	"sort"
	"sync"
	"testing"
	"time"

	"github.com/keep-network/keep-core/pkg/internal/testutils"
)

// TestGetNow covers the most basic path - calling `GetNow()` function multiple
// times and making sure result is always returned, assuming there are no errors
// from the persistence layer.
func TestGetNow(t *testing.T) {
	pool, scheduler, _ := newTestPool(5)
	defer scheduler.stop()

	for {
		if pool.ParametersCount() == 5 {
			break
		}
		// Yield the processor so that the generation goroutines could do their
		// work. This is here "just in case".
		runtime.Gosched()
	}

	for i := 0; i < 5; i++ {
		e, err := pool.GetNow()
		if err != nil {
			t.Errorf("unexpected error: [%v]", err)
		}
		if e == nil {
			t.Errorf("expected not-nil parameter")
		}
	}
}

// TestGetNow_EmptyPool covers the basic unhappy path when the parameter
// pool is empty and the `GetNow` function should break the execution
// and return an appropriate error.
func TestGetNow_EmptyPool(t *testing.T) {
	pool, scheduler, _ := newTestPool(
		5,
		func(ctx context.Context) *big.Int {
			<-ctx.Done()
			return nil
		},
	)
	defer scheduler.stop()

	_, err := pool.GetNow()

	testutils.AssertErrorsSame(t, ErrEmptyPool, err)
}

// TestStop ensures the pool honors the stop signal send to the scheduler and it
// does not keep generating params in some internal loop.
func TestStop(t *testing.T) {
	pool, scheduler, _ := newTestPool(50000)

	// give some time to generate parameters and stop
	time.Sleep(25 * time.Millisecond)
	scheduler.stop()

	// give some time for the generation process to stop and capture the number
	// of parameters generated
	time.Sleep(10 * time.Millisecond)
	parametersCount := pool.ParametersCount()

	// wait some time and make sure no new parameters are generated
	time.Sleep(20 * time.Millisecond)
	if parametersCount != pool.ParametersCount() {
		t.Errorf("expected no new parameters to be generated")
	}
}

// TestStopBlocked ensures the pool honors the stop signal send to the scheduler
// and it does not keep generating parameters even if at the time of receiving
// the stop signal, the pool was blocked on its capacity.
func TestStopBlocked(t *testing.T) {
	// the pool has a capacity of only one parameter
	const poolSize = 1
	pool, scheduler, _ := newTestPool(poolSize)

	// give some time to generate the parameter and stop
	time.Sleep(25 * time.Millisecond)
	scheduler.stop()

	// give some time for the generation process to stop and capture the number
	// of parameters generated
	time.Sleep(10 * time.Millisecond)
	parametersCount := pool.ParametersCount()
	testutils.AssertIntsEqual(
		t,
		"number of parameters in the pool",
		poolSize,
		parametersCount,
	)

	// take one parameter from the pool
	pool.GetNow()

	// no new parameters should be generated, the process is stopped
	// even if the new parameter was generated, it should not be added to
	// the pool
	parametersCount = pool.ParametersCount()
	testutils.AssertIntsEqual(
		t,
		"number of parameters in the pool",
		0,
		parametersCount,
	)
}

// TestStopNoNils ensures no nil result is added to the pool when the context
// passed to the generate function is done. The generateFn returns nil when the
// context is done and we should not add nil elements to the pool.
func TestStopNoNils(t *testing.T) {
	pool, scheduler, _ := newTestPool(50000, func(ctx context.Context) *big.Int {
		<-ctx.Done()
		return nil
	})

	// give some time to generate parameters and stop
	time.Sleep(25 * time.Millisecond)
	scheduler.stop()

	// give some time for the generation process to stop
	time.Sleep(10 * time.Millisecond)

	if pool.ParametersCount() != 0 {
		t.Errorf("expected no parameters to be generated")
	}
}

// TestPersist ensures parameters generated by the pool are persisted.
func TestPersist(t *testing.T) {
	pool, scheduler, persistence := newTestPool(50000)

	// give some time to generate parameters and stop
	time.Sleep(25 * time.Millisecond)
	scheduler.stop()

	// give some time for the generation process to stop
	time.Sleep(10 * time.Millisecond)

	// There are only two possible valid states:
	// 1. All parameters that have been generated are persisted and available
	//    in the pool. It happens when the context was stopped at the time of
	//    generating the next parameter.
	// 2. There is one more parameter persisted than available in the pool.
	//    It happens when the context was stopped during persisting the
	//    generated parameter.
	//
	// Both states are valid. We are fine if the generated parameter is
	// persisted and not added to the pool but it would not be correct to add
	// a parameter to the pool before first persisting it given how GetNow() is
	// constructed: get from the pool, then delete from persistence, and return.
	poolParametersCount := pool.ParametersCount()
	persistenceParametersCount := persistence.parameterCount()
	if poolParametersCount != persistenceParametersCount &&
		poolParametersCount+1 != persistenceParametersCount {
		t.Errorf("too few parameters have been persisted")
	}
}

// TestReadAll ensures pool reads parameters from the persistence before
// generating new ones.
func TestReadAll(t *testing.T) {
	persistence := &mockPersistence{storage: map[string]*big.Int{
		"100": big.NewInt(100),
		"200": big.NewInt(200),
	}}

	pool, scheduler := newTestPoolWithPersistence(100, persistence)
	defer scheduler.stop()

	e, err := pool.GetNow()
	if err != nil {
		t.Errorf("unexpected error: [%v]", err)
	}
	testutils.AssertBigIntsEqual(t, "parameter value", big.NewInt(100), e)

	e, err = pool.GetNow()
	if err != nil {
		t.Errorf("unexpected error: [%v]", err)
	}
	testutils.AssertBigIntsEqual(t, "parameter value", big.NewInt(200), e)

}

// TestDelete ensures parameters fetched from the pool are deleted from the
// persistence layer.
func TestDelete(t *testing.T) {
	persistence := &mockPersistence{storage: map[string]*big.Int{
		"100": big.NewInt(100),
	}}

	pool, scheduler := newTestPoolWithPersistence(100, persistence)
	defer scheduler.stop()

	e, err := pool.GetNow()
	if err != nil {
		t.Errorf("unexpected error: [%v]", err)
	}
	if persistence.isPresent(e) {
		t.Errorf("element should be deleted from persistence: [%v]", e)
	}
}

func newTestPool(
	targetSize int,
	optionalGenerateFn ...func(context.Context) *big.Int,
) (*ParameterPool[big.Int], *Scheduler, *mockPersistence) {
	persistence := &mockPersistence{storage: make(map[string]*big.Int)}
	pool, scheduler := newTestPoolWithPersistence(
		targetSize,
		persistence,
		optionalGenerateFn...,
	)
	return pool, scheduler, persistence
}

func newTestPoolWithPersistence(
	targetSize int,
	persistence *mockPersistence,
	optionalGenerateFn ...func(context.Context) *big.Int,
) (*ParameterPool[big.Int], *Scheduler) {
	var generateFn func(context.Context) *big.Int

	if len(optionalGenerateFn) == 1 {
		generateFn = optionalGenerateFn[0]
	} else {
		generateFn = func(context.Context) *big.Int {
			time.Sleep(5 * time.Millisecond)
			return big.NewInt(time.Now().UnixMilli())
		}
	}

	scheduler := &Scheduler{}

	return NewParameterPool[big.Int](
		logger,
		scheduler,
		persistence,
		targetSize,
		generateFn,
		time.Duration(0), // no delay
	), scheduler
}

type mockPersistence struct {
	storage map[string]*big.Int
	mutex   sync.RWMutex
}

func (mp *mockPersistence) Save(element *big.Int) (*Persisted[big.Int], error) {
	mp.mutex.Lock()
	defer mp.mutex.Unlock()

	id := calcID(element)
	mp.storage[id] = element
	return &Persisted[big.Int]{*element, id}, nil
}

func (mp *mockPersistence) Delete(persisted *Persisted[big.Int]) error {
	mp.mutex.Lock()
	defer mp.mutex.Unlock()

	delete(mp.storage, persisted.ID)
	return nil
}

func (mp *mockPersistence) ReadAll() ([]*Persisted[big.Int], error) {
	mp.mutex.RLock()
	defer mp.mutex.RUnlock()

	all := make([]*Persisted[big.Int], 0, len(mp.storage))
	for _, v := range mp.storage {
		all = append(all, &Persisted[big.Int]{*v, calcID(v)})
	}
	// sorting is needed for TestReadAll
	sort.Slice(all, func(i, j int) bool {
		return all[i].Data.Cmp(&all[j].Data) < 0
	})
	return all, nil
}

func (mp *mockPersistence) parameterCount() int {
	mp.mutex.RLock()
	defer mp.mutex.RUnlock()

	return len(mp.storage)
}

func (mp *mockPersistence) isPresent(element *big.Int) bool {
	mp.mutex.RLock()
	defer mp.mutex.RUnlock()

	_, ok := mp.storage[calcID(element)]
	return ok
}

func calcID(element *big.Int) string {
	return fmt.Sprintf("id_%s", element.Text(16))
}
