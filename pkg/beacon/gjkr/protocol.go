// Package gjkr contains code that implements Distributed Key Generation protocol
// described in [GJKR 99].
//
// See http://docs.keep.network/random-beacon/dkg.html
//
//     [GJKR 99]: Gennaro R., Jarecki S., Krawczyk H., Rabin T. (1999) Secure
//         Distributed Key Generation for Discrete-Log Based Cryptosystems. In:
//         Stern J. (eds) Advances in Cryptology — EUROCRYPT ’99. EUROCRYPT 1999.
//         Lecture Notes in Computer Science, vol 1592. Springer, Berlin, Heidelberg
//         http://groups.csail.mit.edu/cis/pubs/stasio/vss.ps.gz
package gjkr

import (
	crand "crypto/rand"
	"fmt"
	"github.com/ipfs/go-log"
	"math/big"

	bn256 "github.com/ethereum/go-ethereum/crypto/bn256/cloudflare"
	"github.com/keep-network/keep-core/pkg/crypto/ephemeral"
	"github.com/keep-network/keep-core/pkg/protocol/group"
)

// GenerateEphemeralKeyPair takes the group member list and generates an
// ephemeral ECDH keypair for every other group member. Generated public
// ephemeral keys are broadcasted within the group.
//
// See Phase 1 of the protocol specification.
func (em *EphemeralKeyPairGeneratingMember) GenerateEphemeralKeyPair() (
	*EphemeralPublicKeyMessage,
	error,
) {
	ephemeralKeys := make(map[group.MemberIndex]*ephemeral.PublicKey)

	// Calculate ephemeral key pair for every other group member
	for _, member := range em.group.MemberIDs() {
		if member == em.ID {
			// don’t actually generate a key with ourselves
			continue
		}

		ephemeralKeyPair, err := ephemeral.GenerateKeyPair()
		if err != nil {
			return nil, err
		}

		// save the generated ephemeral key to our state
		em.ephemeralKeyPairs[member] = ephemeralKeyPair

		// store the public key to the map for the message
		ephemeralKeys[member] = ephemeralKeyPair.PublicKey
	}

	return &EphemeralPublicKeyMessage{
		senderID:            em.ID,
		ephemeralPublicKeys: ephemeralKeys,
	}, nil
}

// GenerateSymmetricKeys attempts to generate symmetric keys for all remote group
// members via ECDH. It generates this symmetric key for each remote group member
// by doing an ECDH between the ephemeral private key generated for a remote
// group member, and the public key for this member, generated and broadcasted by
// the remote group member.
//
// See Phase 2 of the protocol specification.
func (sm *SymmetricKeyGeneratingMember) GenerateSymmetricKeys(
	ephemeralPubKeyMessages []*EphemeralPublicKeyMessage,
) error {
	for _, ephemeralPubKeyMessage := range ephemeralPubKeyMessages {
		otherMember := ephemeralPubKeyMessage.senderID

		if !sm.isValidEphemeralPublicKeyMessage(ephemeralPubKeyMessage) {
			sm.logger.Warningf(
				"[member:%v] member [%v] disqualified because of "+
					"sending invalid ephemeral public key message",
				sm.ID,
				otherMember,
			)
			sm.group.MarkMemberAsDisqualified(otherMember)
			continue
		}

		err := sm.evidenceLog.PutEphemeralMessage(ephemeralPubKeyMessage)
		if err != nil {
			sm.logger.Errorf(
				"[member:%v] could not put ephemeral key message " +
					"from member [%v] to the evidence log: [%v]",
				sm.ID,
				otherMember,
				err,
			)
		}

		// Find the ephemeral key pair generated by this group member for
		// the other group member.
		ephemeralKeyPair, ok := sm.ephemeralKeyPairs[otherMember]
		if !ok {
			return fmt.Errorf(
				"ephemeral key pair does not exist for member %v",
				otherMember,
			)
		}

		// Get the ephemeral private key generated by this group member for
		// the other group member.
		thisMemberEphemeralPrivateKey := ephemeralKeyPair.PrivateKey

		// Get the ephemeral public key broadcasted by the other group member,
		// which was intended for this group member.
		otherMemberEphemeralPublicKey := ephemeralPubKeyMessage.ephemeralPublicKeys[sm.ID]

		// Create symmetric key for the current group member and the other
		// group member by ECDH'ing the public and private key.
		symmetricKey := thisMemberEphemeralPrivateKey.Ecdh(
			otherMemberEphemeralPublicKey,
		)
		sm.symmetricKeys[otherMember] = symmetricKey
	}

	return nil
}

// isValidEphemeralPublicKeyMessage validates a given EphemeralPublicKeyMessage.
// Message is considered valid if it contains ephemeral public keys for
// all other group members.
func (sm *SymmetricKeyGeneratingMember) isValidEphemeralPublicKeyMessage(
	message *EphemeralPublicKeyMessage,
) bool {
	for _, memberID := range sm.group.MemberIDs() {
		if memberID == message.senderID {
			// Message contains ephemeral public keys only for other group members
			continue
		}

		if _, ok := message.ephemeralPublicKeys[memberID]; !ok {
			sm.logger.Warningf(
				"[member:%v] ephemeral public key message from member [%v] "+
					"does not contain public key for member [%v]",
				sm.ID,
				message.senderID,
				memberID,
			)
			return false
		}
	}

	return true
}

// CalculateMembersSharesAndCommitments starts with generating coefficients for
// two polynomials. It then calculates shares for all group member and packs
// them into a broadcast message. Individual shares inside the message are
// encrypted with the symmetric key of the indended share receiver.
// Additionally, it calculates commitments to `a` coefficients of first
// polynomial using second's polynomial `b` coefficients.
//
// If there are no symmetric keys established with all other group members,
// function yields an error.
//
// See Phase 3 of the protocol specification.
func (cm *CommittingMember) CalculateMembersSharesAndCommitments() (
	*PeerSharesMessage,
	*MemberCommitmentsMessage,
	error,
) {
	polynomialDegree := cm.group.DishonestThreshold()
	coefficientsA, err := generatePolynomial(polynomialDegree)
	if err != nil {
		return nil, nil, fmt.Errorf(
			"could not generate shares polynomial [%v]",
			err,
		)
	}
	coefficientsB, err := generatePolynomial(polynomialDegree)
	if err != nil {
		return nil, nil, fmt.Errorf(
			"could not generate hiding polynomial [%v]",
			err,
		)
	}

	cm.secretCoefficients = coefficientsA

	// Calculate shares for other group members by evaluating polynomials
	// defined by coefficients `a_i` and `b_i`
	var sharesMessage = newPeerSharesMessage(cm.ID)
	for _, receiverID := range cm.group.MemberIDs() {
		// s_j = f_(j) mod q
		memberShareS := cm.evaluateMemberShare(receiverID, coefficientsA)
		// t_j = g_(j) mod q
		memberShareT := cm.evaluateMemberShare(receiverID, coefficientsB)

		// Check if calculated shares for the current member.
		// If so, store them without sharing in a message.
		if cm.ID == receiverID {
			cm.selfSecretShareS = memberShareS
			cm.selfSecretShareT = memberShareT
			continue
		}

		// If there is no symmetric key established with the receiver,
		// yield an error.
		symmetricKey, hasKey := cm.symmetricKeys[receiverID]
		if !hasKey {
			cm.logger.Warningf(
				"[member:%v] no symmetric key for receiver: [%v]",
				cm.ID,
				receiverID,
			)
			continue
		}

		err := sharesMessage.addShares(
			receiverID,
			memberShareS,
			memberShareT,
			symmetricKey,
		)
		if err != nil {
			return nil, nil, fmt.Errorf(
				"could not add shares for receiver %v [%v]",
				receiverID,
				err,
			)
		}
	}

	commitments := make([]*bn256.G1, len(coefficientsA))
	for k := range commitments {
		commitments[k] = cm.calculateCommitment(coefficientsA[k], coefficientsB[k])
	}
	commitmentsMessage := &MemberCommitmentsMessage{
		senderID:    cm.ID,
		commitments: commitments,
	}

	return sharesMessage, commitmentsMessage, nil
}

// calculateCommitment generates a Pedersen commitment to a secret value
// `secret` with a blinding factor `t`.
func (cm *CommittingMember) calculateCommitment(
	secret *big.Int,
	t *big.Int,
) *bn256.G1 {
	gs := new(bn256.G1).ScalarBaseMult(secret)                 // G * secret
	ht := new(bn256.G1).ScalarMult(cm.protocolParameters.H, t) // H * t

	return new(bn256.G1).Add(gs, ht) // G * secret + H * t
}

// generatePolynomial generates a random polynomial over `Z_q` of a given degree.
// This function will generate a slice of `degree + 1` coefficients (+1 for
// a constant coefficient). Each value will be a random `big.Int` in range
// `(0, q)` where `q` is the cardinality of alt_bn128 elliptic curve.
func generatePolynomial(degree int) ([]*big.Int, error) {
	generateCoefficient := func() (c *big.Int, err error) {
		for {
			c, err = crand.Int(crand.Reader, bn256.Order)
			if c.Sign() > 0 || err != nil {
				return
			}
		}
	}

	coefficients := make([]*big.Int, degree+1)
	for i := range coefficients {
		coefficient, err := generateCoefficient()
		if err != nil {
			return nil, err
		}

		coefficients[i] = coefficient
	}

	return coefficients, nil
}

// evaluateMemberShare calculates a share for given memberID.
//
// It calculates `s_j = Σ a_k * j^k mod q`for k in [0..T], where:
// - `a_k` is k coefficient
// - `j` is memberID
// - `T` is dishonest threshold, so there are T+1 coefficients
// - `q` is the order of cyclic group formed over the alt_bn128 curve
func (cm *CommittingMember) evaluateMemberShare(
	memberID group.MemberIndex,
	coefficients []*big.Int,
) *big.Int {
	result := big.NewInt(0)
	for k, a := range coefficients {
		result = new(big.Int).Mod(
			new(big.Int).Add(
				result,
				new(big.Int).Mul(
					a,
					pow(memberID, k),
				),
			),
			bn256.Order,
		)
	}
	return result
}

// VerifyReceivedSharesAndCommitmentsMessages verifies shares and commitments
// received in messages from other group members. Returns accusation message
// with IDs of members for which the verification failed. All those members are
// disqualified by the current member in this function.
//
// Function returns error only if it is fatal to the protocol. Such situation
// should never happen.
//
// Member is disqualified if:
// - messages contain invalid number of shares or commitments
// - shares can not be decrypted
// - shares are not valid against commitments
//
// See Phase 4 of the protocol specification.
func (cvm *CommitmentsVerifyingMember) VerifyReceivedSharesAndCommitmentsMessages(
	sharesMessages []*PeerSharesMessage,
	commitmentsMessages []*MemberCommitmentsMessage,
) (*SecretSharesAccusationsMessage, error) {
	for _, sharesMessage := range sharesMessages {
		err := cvm.evidenceLog.PutPeerSharesMessage(sharesMessage)
		if err != nil {
			cvm.logger.Errorf(
				"[member:%v] could not put peer shares message " +
					"from member [%v] to the evidence log: [%v]",
				cvm.ID,
				sharesMessage.senderID,
				err,
			)
		}
	}

	accusedMembersKeys := make(map[group.MemberIndex]*ephemeral.PrivateKey)
	for _, commitmentsMessage := range commitmentsMessages {
		if !cvm.isValidMemberCommitmentsMessage(commitmentsMessage) {
			cvm.logger.Warningf(
				"[member:%v] member [%v] disqualified because of "+
					"sending invalid member commitments message",
				cvm.ID,
				commitmentsMessage.senderID,
			)
			cvm.group.MarkMemberAsDisqualified(commitmentsMessage.senderID)
			continue
		}

		cvm.receivedPeerCommitments[commitmentsMessage.senderID] =
			commitmentsMessage.commitments

		// Find share message sent by the same member who sent commitment message
		sharesMessageFound := false
		for _, sharesMessage := range sharesMessages {
			if sharesMessage.senderID == commitmentsMessage.senderID {
				sharesMessageFound = true

				if !cvm.isValidPeerSharesMessage(sharesMessage) {
					cvm.logger.Warningf(
						"[member:%v] member [%v] disqualified because of "+
							"sending invalid peer shares message",
						cvm.ID,
						sharesMessage.senderID,
					)
					cvm.group.MarkMemberAsDisqualified(sharesMessage.senderID)
					break
				}

				// If there is no symmetric key established with the sender of
				// the message, error is returned.
				// This should never happen - member which did not establish
				// symmetric key with the current member is marked as inactive
				// in the second phase and we no longer accept messages from them.
				// If the symmetric key is not available, we consider it as a
				// fatal error. Such a situation should never happen.
				symmetricKey, hasKey := cvm.symmetricKeys[sharesMessage.senderID]
				if !hasKey {
					return nil, fmt.Errorf(
						"no symmetric key for sender %v",
						sharesMessage.senderID,
					)
				}

				// Decrypt shares using symmetric key established with sender.
				// Message validation performed earlier in this phase ensures
				// that shares for all group members (including the current one)
				// are in the message.
				// The only reason possible why shares could not be decrypted
				// here is because they are broken. If shares are broken,
				// sender is disqualified and an accusation against the sender
				// is published.
				shareS, shareT, err := sharesMessage.decryptShares(
					cvm.ID,
					symmetricKey,
				)
				if err != nil {
					cvm.logger.Warningf(
						"[member:%v] member [%v] disqualified because "+
							"could not decrypt shares received from them",
						cvm.ID,
						sharesMessage.senderID,
					)
					cvm.group.MarkMemberAsDisqualified(sharesMessage.senderID)
					accusedMembersKeys[sharesMessage.senderID] =
						cvm.ephemeralKeyPairs[sharesMessage.senderID].PrivateKey
					break
				}

				if !cvm.areSharesValidAgainstCommitments(
					shareS,                         // s_ji
					shareT,                         // t_ji
					commitmentsMessage.commitments, // C_j
					cvm.ID,                         // i
				) {
					cvm.logger.Warningf(
						"[member:%v] shares from member [%v] invalid against "+
							"commitments; disqualifying and accusing the member",
						cvm.ID,
						commitmentsMessage.senderID,
					)
					cvm.group.MarkMemberAsDisqualified(commitmentsMessage.senderID)
					accusedMembersKeys[commitmentsMessage.senderID] =
						cvm.ephemeralKeyPairs[commitmentsMessage.senderID].PrivateKey
					break
				}
				cvm.receivedQualifiedSharesS[commitmentsMessage.senderID] = shareS
				cvm.receivedQualifiedSharesT[commitmentsMessage.senderID] = shareT
				break
			}
		}
		if !sharesMessageFound {
			cvm.logger.Warningf(
				"[member:%v] cannot find shares message from member: [%v]",
				cvm.ID,
				commitmentsMessage.senderID,
			)
		}
	}

	return &SecretSharesAccusationsMessage{
		senderID:           cvm.ID,
		accusedMembersKeys: accusedMembersKeys,
	}, nil
}

// isValidMemberCommitmentsMessage validates a given MemberCommitmentsMessage.
// Message is considered valid if it contains an expected number of commitments.
func (cvm *CommitmentsVerifyingMember) isValidMemberCommitmentsMessage(
	message *MemberCommitmentsMessage,
) bool {
	// A commitment is generated for each coefficient of the polynomial.
	// The polynomial is of degree equal to the dishonest threshold, thus we
	// have dishonest threshold + 1 coefficients in the polynomial including a
	// constant coefficient. It implicates the same count of commitments.
	expectedCommitmentsCount := cvm.group.DishonestThreshold() + 1
	if len(message.commitments) != expectedCommitmentsCount {
		cvm.logger.Warningf(
			"[member:%v] member [%v] sent a message with a wrong number "+
				"of commitments: [%v] instead of expected [%v]",
			cvm.ID,
			message.senderID,
			len(message.commitments),
			expectedCommitmentsCount,
		)
		return false
	}

	return true
}

// isValidPeerSharesMessage validates a given PeerSharesMessage.
// Message is considered valid if it contains shares for all other group members.
func (cvm *CommitmentsVerifyingMember) isValidPeerSharesMessage(
	message *PeerSharesMessage,
) bool {
	for _, memberID := range cvm.group.OperatingMemberIDs() {
		if memberID == message.senderID {
			// Message contains shares only for other group members.
			continue
		}

		if _, ok := message.shares[memberID]; !ok {
			cvm.logger.Warningf(
				"[member:%v] peer shares message from member [%v] does not "+
					"contain shares for member [%v]",
				cvm.ID,
				message.senderID,
				memberID,
			)
			return false
		}
	}

	return true
}

// areSharesValidAgainstCommitments verifies if commitments are valid for passed
// shares.
//
// The `j` member generated a polynomial with `k` coefficients before. Then they
// calculated a commitments to the polynomial's coefficients `C_j` and individual
// shares `s_ji` and `t_ji` with a polynomial for a member `i`. In this function
// the verifier checks if the shares are valid against the commitments.
//
// The verifier checks whether [GJKR 99] 1.(b) holds:
// `(g ^ s_ji) * (h ^ t_ji) mod p == Π (C_j[k] ^ (i^k)) mod p` for `k` in `[0..T]`
//
// What, using elliptic curve, is the same as:
// `G * s_ji + H * t_ji == Σ (C_j[k] * (i^k))` for `k` in `[0..T]`
func (cm *CommittingMember) areSharesValidAgainstCommitments(
	shareS, shareT *big.Int, // s_ji, t_ji
	commitments []*bn256.G1, // C_j
	memberID group.MemberIndex, // i
) bool {
	if len(commitments) == 0 {
		return false
	}

	var sum *bn256.G1                // Σ (C_j[k] * (i^k)) for k in [0..T]
	for k, ck := range commitments { // k, C_j[k]
		ci := new(bn256.G1).ScalarMult(ck, pow(memberID, k)) // C_j[k] * (i^k)
		if sum == nil {
			sum = ci
		} else {
			sum = new(bn256.G1).Add(sum, ci)
		}
	}

	commitment := cm.calculateCommitment(shareS, shareT) // G * s_ji + H * t_ji

	return commitment.String() == sum.String()
}

// ResolveSecretSharesAccusationsMessages resolves complaints received in
// secret shares accusations messages. The member calls this function to judge
// which party of the dispute is misbehaving.
//
// Function should not receive accusation message sent by the current member.
// Members accused by the current member are disqualified in the previous phase,
// at the same time when an accusation against them is published.
//
// If the current member is accused, it marks the accuser as disqualified
// without checking self shares. Each member consider itself as an honest
// participant.
//
// This function needs to decrypt shares sent previously by the accused member
// to the accuser in an encrypted form. To do that it needs to recover a symmetric
// key used for data encryption. It takes private key revealed by the accuser
// and public key broadcasted by the accused and performs Elliptic Curve Diffie-
// Hellman operation on them.
//
// Function returns error only if it is fatal to the protocol. Such situation
// should never happen.
//
// Accuser is disqualified if:
// - accused the current member
// - the revealed private key does not match the public key previously broadcast
//   by the accuser
// - accused inactive or already disqualified member and as a result, we do not
//   have enough information to resolve that accusation
// - shares of the accused member are valid against commitments
// - accused member ID does not exist
//
// Accused member is disqualified if:
// - shares of the accused member can not be decrypted
// - shares of the accused member are not valid against commitments
//
// See Phase 5 of the protocol specification.
func (sjm *SharesJustifyingMember) ResolveSecretSharesAccusationsMessages(
	messages []*SecretSharesAccusationsMessage,
) error {
	for _, message := range messages {
		accuserID := message.senderID
		for accusedID, revealedAccuserPrivateKey := range message.accusedMembersKeys {
			isAccusedIDValid := accusedID > 0 && int(accusedID) <= sjm.group.GroupSize()
			if sjm.ID == accusedID || !isAccusedIDValid {
				// The member does not resolve the dispute as an accused
				// or the accussed member ID is not valid.
				// Mark the accuser as disqualified immediately,
				// as each member consider itself as a honest participant.
				sjm.group.MarkMemberAsDisqualified(accuserID)
				sjm.discardReceivedShares(accuserID)
				continue
			}

			accuserPublicKey := findPublicKey(
				sjm.logger,
				sjm.evidenceLog,
				accuserID,
				accusedID,
			)
			if accuserPublicKey == nil {
				// Ephemeral public key of the accuser, generated for the sake
				// of communication with the accused member should be present
				// in the evidence log. The key is not there only if it was not
				// sent by the accuser in the first phase of the protocol and
				// such behaviour results in marking that member as disqualified
				// in the second phase. As a result, we no longer accept
				// messages from that member and it is not possible we will
				// receive an accusation from an inactive member in this phase.
				// If the public key could not be found we consider this a
				// fatal error. Such a situation should never happen.
				return fmt.Errorf(
					"could not find public key sent by [%v] to [%v]",
					accuserID,
					accusedID,
				)
			}

			if !accuserPublicKey.IsKeyMatching(revealedAccuserPrivateKey) {
				sjm.logger.Warningf(
					"[member:%v] member [%v] disqualified because of "+
						"revealing private key not matching the public key",
					sjm.ID,
					accuserID,
				)
				sjm.group.MarkMemberAsDisqualified(accuserID)
				sjm.discardReceivedShares(accuserID)
				continue
			}

			// Recover symmetric key based on ephemeral public key message sent
			// by the accused member. If the message is not present in the
			// evidence log, it means the accused member did not sent us
			// their public key in the first phase of the protocol and we
			// marked the accused member as inactive in the second phase of the
			// protocol. Assuming everyone in the group has the same view on
			// who is inactive, it means the accuser sent and accusation against
			// inactive member, knowing we can not resolve that accusation.
			// As a result, we should mark the accuser as disqualified.
			//
			// If the message is present in the evidence log but it does not
			// contain a public key generated for the accuser, it means we have
			// already marked the accused party as disqualified when performing
			// a validation of a message with public keys in the first phase of
			// the protocol. Assuming everyone in the group has the same view on
			// who is disqualified after the second phase of the protocol, it
			// means the accuser sent an accusation against a disqualified
			// member, knowing we can not resolve that accusation.
			// As a result, we should mark the accuser as disqualified.
			accusedPublicKey := findPublicKey(
				sjm.logger,
				sjm.evidenceLog,
				accusedID,
				accuserID,
			)
			if accusedPublicKey == nil {
				sjm.logger.Warningf(
					"[member:%v] member [%v] disqualified because could not "+
						"recover symmetric key; accused member [%v] is already "+
						"marked as inactive or disqualified ",
					sjm.ID,
					accuserID,
					accusedID,
				)
				sjm.group.MarkMemberAsDisqualified(accuserID)
				sjm.discardReceivedShares(accuserID)
				continue
			}
			symmetricKey := revealedAccuserPrivateKey.Ecdh(accusedPublicKey)

			// Get from evidence log peer shares message sent by the accused
			// member. If the message is not present, this means the accused
			// member has been already marked as inactive in phase 4.
			// Assuming that each other member consider the accused member as
			// inactive, the accuser should be disqualified because of
			// accusing an inactive member knowing we can not resolve this
			// accusation.
			accusedSharesMessage := sjm.evidenceLog.peerSharesMessage(accusedID)
			if accusedSharesMessage == nil {
				sjm.logger.Warningf(
					"[member:%v] member [%v] disqualified because could not "+
						"get peer shares message from evidence log; "+
						"accused member [%v] is already marked as inactive",
					sjm.ID,
					accuserID,
					accusedID,
				)
				sjm.group.MarkMemberAsDisqualified(accuserID)
				sjm.discardReceivedShares(accuserID)
				continue
			}

			// Message validation performed in the fourth phase ensures
			// that shares for all group members (including the accused one)
			// are in the message.
			// The only reason possible why shares could not be decrypted
			// here is because they are broken. If shares are broken,
			// the accused member is disqualified.
			shareS, shareT, err := accusedSharesMessage.decryptShares(
				accuserID,
				symmetricKey,
			)
			if err != nil {
				sjm.logger.Warningf(
					"[member:%v] member [%v] disqualified because of sending "+
						"to member [%v] shares that could not be decrypted",
					sjm.ID,
					accusedID,
					accuserID,
				)
				sjm.group.MarkMemberAsDisqualified(accusedID)
				sjm.discardReceivedShares(accusedID)
				continue
			}

			if sjm.areSharesValidAgainstCommitments(
				shareS, shareT, // s_mj, t_mj
				sjm.receivedPeerCommitments[accusedID], // C_m
				accuserID,                              // j
			) {
				sjm.logger.Warningf(
					"[member:%v] member [%v] disqualified because of "+
						"false accusation against member [%v] ",
					sjm.ID,
					accuserID,
					accusedID,
				)
				sjm.group.MarkMemberAsDisqualified(accuserID)
				sjm.discardReceivedShares(accuserID)
			} else {
				sjm.logger.Warningf(
					"[member:%v] member [%v] disqualified because of "+
						"confirmed misbehaviour against member [%v] ",
					sjm.ID,
					accusedID,
					accuserID,
				)
				sjm.group.MarkMemberAsDisqualified(accusedID)
				sjm.discardReceivedShares(accusedID)
			}
		}
	}
	return nil
}

// Once phase 5 completes, all group members should have the same view
// on who is disqualified and who is inactive. All properly behaving group
// members belong to QUAL set.
//
// In the last phase of GJKR (phase 12), we reconstruct group public key
// from public key share points of all members from QUAL set. We need
// exactly the same number of public key share points as the number of QUAL
// members.
//
// Since it is possible that one or more members of QUAL will misbehave
// after phase 5 completed and QUAL established, we need to store shares S
// from all QUAL members. From those shares, we can recover public key share
// point of a misbehaving member from QUAL set.
//
// For the recovery of a missing public key share point, we must use shares of
// QUAL members only. For this reason, we discard all the shares we received
// from other group members which - because of their misbehaviour - do not
// qualified to QUAL.
func (sjm *SharesJustifyingMember) discardReceivedShares(
	memberID group.MemberIndex,
) {
	delete(sjm.receivedQualifiedSharesS, memberID)
	delete(sjm.receivedQualifiedSharesT, memberID)
}

// Inspects evidence log looking for ephemeral public key message sent in phase
// 1 of the protocol by the sender with the given ID and retrieves from that
// message public key generated by that sender for the given receiver ID.
//
// The function fails if ephemeral public key message for the given sender ID
// could not be found or if the public key for the given received ID was not
// present in that message.
//
// There are two assumptions made here:
// 1. If the given sender did not deliver ephemeral public key message in phase
//    1, it should be marked as inactive, hence, this function should never be
//    called for that sender ID,
// 2. If the given sender delivered ephemeral public key message in phase 1
//    but that message did not contain a public key for all group members
//    including the one passed as receiver to this function, sender should be
//    disqualified in phase 2, and this function should never be called for that
//    sender ID.
func findPublicKey(
	logger log.StandardLogger,
	evidenceLog evidenceLog,
	senderID, receiverID group.MemberIndex,
) *ephemeral.PublicKey {
	ephemeralPublicKeyMessage := evidenceLog.ephemeralPublicKeyMessage(senderID)
	if ephemeralPublicKeyMessage == nil {
		logger.Warningf(
			"no ephemeral public key message for sender [%v]",
			senderID,
		)
		return nil
	}

	senderPublicKey, ok := ephemeralPublicKeyMessage.ephemeralPublicKeys[receiverID]
	if !ok {
		logger.Warningf(
			"no ephemeral public key generated for receiver [%v]",
			receiverID,
		)
		return nil
	}

	return senderPublicKey
}

// CombineMemberShares sums up all `s` shares intended for this member.
// Combines secret shares calculated by current member `i` for itself `s_ii`
// with shares calculated by peer members `j` for this member `s_ji`.
//
// `x_i = Σ s_ji mod q` for `j` in a group of players who passed secret shares
// accusations stage. `q` is the order of cyclic group formed over the alt_bn128
// curve.
//
// See Phase 6 of the protocol specification.
func (qm *QualifiedMember) CombineMemberShares() {
	combinedSharesS := qm.selfSecretShareS // s_ii
	for _, s := range qm.receivedQualifiedSharesS {
		combinedSharesS = new(big.Int).Mod(
			new(big.Int).Add(combinedSharesS, s),
			bn256.Order,
		)
	}

	qm.groupPrivateKeyShare = combinedSharesS
}

// CalculatePublicKeySharePoints calculates public values for member's
// coefficients.
//
// It calculates:
// `A_k = g^a_k` for `k` in `[0..T]`.
//
// What, using elliptic curve, is the same as:
// `A_k = G * a_k` for `k` in `[0..T]`.
// where `G` is curve's generator.
//
// See Phase 7 of the protocol specification.
func (sm *SharingMember) CalculatePublicKeySharePoints() *MemberPublicKeySharePointsMessage {
	sm.publicKeySharePoints = make([]*bn256.G2, len(sm.secretCoefficients))
	for i, a := range sm.secretCoefficients {
		sm.publicKeySharePoints[i] = new(bn256.G2).ScalarBaseMult(a)
	}

	return &MemberPublicKeySharePointsMessage{
		senderID:             sm.ID,
		publicKeySharePoints: sm.publicKeySharePoints,
	}
}

// VerifyPublicKeySharePoints validates public key share points received in
// messages from peer group members.
// It returns accusation message with ID of members for which the verification
// failed.
//
// See Phase 8 of the protocol specification.
func (sm *SharingMember) VerifyPublicKeySharePoints(
	messages []*MemberPublicKeySharePointsMessage,
) (*PointsAccusationsMessage, error) {
	accusedMembersKeys := make(map[group.MemberIndex]*ephemeral.PrivateKey)
	// `product = Π (A_j[k] ^ (i^k)) mod p` for k in [0..T],
	// where: j is sender's ID, i is current member ID, T is dishonest threshold.
	for _, message := range messages {
		if !sm.isValidMemberPublicKeySharePointsMessage(message) {
			sm.logger.Warningf(
				"[member:%v] member [%v] disqualified because of "+
					"sending invalid member public key share points message",
				sm.ID,
				message.senderID,
			)
			sm.group.MarkMemberAsDisqualified(message.senderID)
			continue
		}

		if !sm.isShareValidAgainstPublicKeySharePoints(
			sm.ID,
			sm.receivedQualifiedSharesS[message.senderID],
			message.publicKeySharePoints,
		) {
			sm.logger.Warningf(
				"[member:%v] member [%v] disqualified because of "+
					"invalid public key share points",
				sm.ID,
				message.senderID,
			)
			sm.group.MarkMemberAsDisqualified(message.senderID)
			accusedMembersKeys[message.senderID] = sm.ephemeralKeyPairs[message.senderID].PrivateKey
			continue
		}
		sm.receivedValidPeerPublicKeySharePoints[message.senderID] = message.publicKeySharePoints
	}

	return &PointsAccusationsMessage{
		senderID:           sm.ID,
		accusedMembersKeys: accusedMembersKeys,
	}, nil
}

// isValidMemberPublicKeySharePointsMessage validates a given
// MemberPublicKeySharePointsMessage. Message is considered valid if it
// contains an expected number of public key share points.
func (sm *SharingMember) isValidMemberPublicKeySharePointsMessage(
	message *MemberPublicKeySharePointsMessage,
) bool {
	// A public key share point is generated for each coefficient of the
	// polynomial. The polynomial is of degree equal to the dishonest threshold,
	// thus we have dishonest threshold + 1 coefficients in the polynomial
	// including a constant coefficient. It implicates the same count of
	// public key share points.
	expectedPointsCount := sm.group.DishonestThreshold() + 1
	if len(message.publicKeySharePoints) != expectedPointsCount {
		sm.logger.Warningf(
			"[member:%v] member [%v] sent a message with a wrong number "+
				"of public key share points: [%v] instead of expected [%v]",
			sm.ID,
			message.senderID,
			len(message.publicKeySharePoints),
			expectedPointsCount,
		)
		return false
	}

	return true
}

// isShareValidAgainstPublicKeySharePoints verifies if public key share points
// are valid for passed share S generated for the specific member, denoted as
// a share receiver.
//
// The `j` member calculated public key share points for their polynomial
// coefficients and share `s_ji` with a polynomial for a member `i`. In this
// function the verifier checks if the public key share points are valid against
// the share S.
//
// The verifier checks whether [GJKR 99] 4.(b) holds:
// `g^s_ji mod p == Π (A_j[k] ^ (i^k)) mod p` for `k` in `[0..T]`
//
// What, using elliptic curve, is the same as:
// G * s_ji == Σ ( A_j[k] * (i^k) ) for `k` in `[0..T]`
func (sm *SharingMember) isShareValidAgainstPublicKeySharePoints(
	shareReceiverID group.MemberIndex,
	shareS *big.Int,
	publicKeySharePoints []*bn256.G2,
) bool {
	if len(publicKeySharePoints) == 0 {
		return false
	}

	sum := sm.publicKeyShare(shareReceiverID, publicKeySharePoints)
	gs := new(bn256.G2).ScalarBaseMult(shareS) // G * s_ji

	return gs.String() == sum.String()
}

// publicKeyShare returns public key share for given share receiver based on
// given public key share points.
func (sm *SharingMember) publicKeyShare(
	shareReceiverID group.MemberIndex,
	publicKeySharePoints []*bn256.G2,
) *bn256.G2 {
	var sum *bn256.G2
	// Σ ( A_j[k] * (i^k) ) for `k` in `[0..T]`
	for k, a := range publicKeySharePoints {
		aj := new(bn256.G2).ScalarMult(a, pow(shareReceiverID, k)) // A_j[k] * (i^k)
		if sum == nil {
			sum = aj
		} else {
			sum = new(bn256.G2).Add(sum, aj)
		}
	}
	return sum
}

// ResolvePublicKeySharePointsAccusationsMessages resolves complaints received
// in points accusations messages. The member calls this function to judge
// which party of the dispute is misbehaving.
//
// Function should not receive accusation message sent by the current member.
// Members accused by the current member are disqualified in the previous phase,
// at the same time when an accusation against them is published.
//
// If the current member is accused, it marks the accuser as disqualified
// without checking self shares. Each member consider itself as an honest
// participant.
//
// This function needs to decrypt shares sent previously by the accused member
// to the accuser in an encrypted form. To do that it needs to recover a symmetric
// key used for data encryption. It takes private key revealed by the accuser
// and public key broadcasted by the accused and performs Elliptic Curve Diffie-
// Hellman operation between them.
//
// Function returns error only if it is fatal to the protocol. Such situation
// should never happen.
//
// Accuser is disqualified if:
// - accused the current member
// - the revealed private key does not match the public key previously broadcast
//   by the accuser
// - accused inactive or already disqualified member and as a result, we do not
//   have enough information to resolve that accusation
// - shares of the accused member are valid against public key share points
// - shares of the accused member can not be decrypted and the accuser didn't
//   complain about this fact in phase 4 (protocol violation)
// - accused member ID does not exist
//
// Accused member is disqualified if:
// - shares of the accused member can not be decrypted
// - shares of the accused member are not valid against public key share points
//
// See Phase 9 of the protocol specification.
func (pjm *PointsJustifyingMember) ResolvePublicKeySharePointsAccusationsMessages(
	messages []*PointsAccusationsMessage,
) error {
	for _, message := range messages {
		accuserID := message.senderID
		for accusedID, revealedAccuserPrivateKey := range message.accusedMembersKeys {
			isAccusedIDValid := accusedID > 0 && int(accusedID) <= pjm.group.GroupSize()
			if pjm.ID == accusedID || !isAccusedIDValid {
				// The member does not resolve the dispute as an accused
				// or the accussed member ID is not valid.
				// Mark the accuser as disqualified immediately,
				// as each member consider itself as a honest participant.
				pjm.group.MarkMemberAsDisqualified(accuserID)
				continue
			}

			evidenceLog := pjm.evidenceLog

			accuserPublicKey := findPublicKey(
				pjm.logger,
				evidenceLog,
				accuserID,
				accusedID,
			)
			if accuserPublicKey == nil {
				// Ephemeral public key of the accuser, generated for the sake
				// of communication with the accused member should be present
				// in the evidence log. The key is not there only if it was not
				// sent by the accuser in the first phase of the protocol and
				// such behaviour results in marking that member as disqualified
				// in the second phase. As a result, we no longer accept
				// messages from that member and it is not possible we will
				// receive an accusation from an inactive member in this phase.
				// If the public key could not be found we consider this a
				// fatal error. Such a situation should never happen.
				return fmt.Errorf(
					"could not find public key sent by [%v] to [%v]",
					accuserID,
					accusedID,
				)
			}

			if !accuserPublicKey.IsKeyMatching(revealedAccuserPrivateKey) {
				pjm.logger.Warningf(
					"[member:%v] member [%v] disqualified because of "+
						"revealing private key not matching the public key",
					pjm.ID,
					accuserID,
				)
				pjm.group.MarkMemberAsDisqualified(accuserID)
				continue
			}

			// Recover symmetric key based on ephemeral public key message sent
			// by the accused member. If the message is not present in the
			// evidence log, it means the accused member did not sent us
			// their public key in the first phase of the protocol and we
			// marked the accused member as inactive in the second phase of the
			// protocol. Assuming everyone in the group has the same view on
			// who is inactive, it means the accuser sent and accusation against
			// inactive member, knowing we can not resolve that accusation.
			// As a result, we should mark the accuser as disqualified.
			//
			// If the message is present in the evidence log but it does not
			// contain a public key generated for the accuser, it means we have
			// already marked the accused party as disqualified when performing
			// a validation of a message with public keys in the first phase of
			// the protocol. Assuming everyone in the group has the same view on
			// who is disqualified after the second phase of the protocol, it
			// means the accuser sent an accusation against a disqualified
			// member, knowing we can not resolve that accusation.
			// As a result, we should mark the accuser as disqualified.
			accusedPublicKey := findPublicKey(
				pjm.logger,
				evidenceLog,
				accusedID,
				accuserID,
			)
			if accusedPublicKey == nil {
				pjm.logger.Warningf(
					"[member:%v] member [%v] disqualified because could not "+
						"recover symmetric key; accused member [%v] is already "+
						"marked as inactive or disqualified ",
					pjm.ID,
					accuserID,
					accusedID,
				)
				pjm.group.MarkMemberAsDisqualified(accuserID)
				continue
			}
			recoveredSymmetricKey := revealedAccuserPrivateKey.Ecdh(accusedPublicKey)

			// Get from evidence log peer shares message sent by the accused
			// member. If the message is not present, this means the accused
			// member has been already marked as inactive in phase 4.
			// Assuming that each other member consider the accused member as
			// inactive, the accuser should be disqualified because of
			// accusing an inactive member knowing we can not resolve this
			// accusation.
			accusedSharesMessage := evidenceLog.peerSharesMessage(accusedID)
			if accusedSharesMessage == nil {
				pjm.logger.Warningf(
					"[member:%v] member [%v] disqualified because could not "+
						"get peer shares message from evidence log; "+
						"accused member [%v] is already marked as inactive",
					pjm.ID,
					accuserID,
					accusedID,
				)
				pjm.group.MarkMemberAsDisqualified(accuserID)
				continue
			}

			// Message validation performed in the fourth phase ensures
			// that shares for all group members (including the accused one)
			// are in the message.
			// The only reason possible why shares could not be decrypted
			// here is because they are broken. If shares are broken,
			// the accused member is disqualified.
			// Accuser should be also marked as disqualified because they didn't
			// complain earlier about invalid shares so they violated the protocol.
			shareS, _, err := accusedSharesMessage.decryptShares(
				accuserID,
				recoveredSymmetricKey,
			)
			if err != nil {
				pjm.logger.Warningf(
					"[member:%v] member [%v] disqualified because of sending "+
						"shares that could not be decrypted; "+
						"member [%v] disqualified because did not complain "+
						"about invalid shares earlier",
					pjm.ID,
					accusedID,
					accuserID,
				)
				pjm.group.MarkMemberAsDisqualified(accuserID)
				pjm.group.MarkMemberAsDisqualified(accusedID)
				continue
			}

			if pjm.isShareValidAgainstPublicKeySharePoints(
				message.senderID,
				shareS,
				pjm.receivedValidPeerPublicKeySharePoints[accusedID],
			) {
				pjm.logger.Warningf(
					"[member:%v] member [%v] disqualified because of "+
						"false accusation against member [%v] ",
					pjm.ID,
					accuserID,
					accusedID,
				)
				pjm.group.MarkMemberAsDisqualified(accuserID)
			} else {
				pjm.logger.Warningf(
					"[member:%v] member [%v] disqualified because of "+
						"confirmed misbehaviour against member [%v] ",
					pjm.ID,
					accusedID,
					accuserID,
				)
				pjm.group.MarkMemberAsDisqualified(accusedID)
			}
		}
	}
	return nil
}

// RevealMisbehavedMembersKeys reveals ephemeral private keys used to create an
// ephemeral symmetric key with members whose shares needs to be reconstructed.
// Those are members who provided valid shares in Phase 3 and qualified to QUAL set
// but were either marked as inactive or disqualified later.
// It returns a message containing a map of ephemeral private key for each member.
//
// See Phase 10 of the protocol specification.
func (rm *RevealingMember) RevealMisbehavedMembersKeys() (
	*MisbehavedEphemeralKeysMessage,
	error,
) {
	privateKeys := make(map[group.MemberIndex]*ephemeral.PrivateKey)

	rm.expectedMembersForReconstruction = rm.membersForReconstruction()

	for _, memberID := range rm.expectedMembersForReconstruction {
		ephemeralKeyPair, ok := rm.ephemeralKeyPairs[memberID]
		if !ok {
			return nil, fmt.Errorf(
				"no ephemeral key pair for member %v",
				memberID,
			)
		}
		privateKeys[memberID] = ephemeralKeyPair.PrivateKey
	}

	return &MisbehavedEphemeralKeysMessage{
		senderID:    rm.ID,
		privateKeys: privateKeys,
	}, nil
}

// membersForReconstruction returns all members whose shares needs to be
// reconstructed. Specifically, returns all members from QUAL set disqualified
// or marked as inactive in later phases, after QUAL set has been established.
//
// Once phase 5 completes, all group members should have the same view
// on who is disqualified and who is inactive. All properly behaving group
// members at that point belong to QUAL set.
func (rm *RevealingMember) membersForReconstruction() []group.MemberIndex {
	members := make([]group.MemberIndex, 0)

	// Member shares needs reconstruction if two conditions are met:
	// - member provided valid shares in Phase 3 and is in QUAL set
	// - member DID NOT provide valid public key share in phase 7
	needsReconstruction := func(member group.MemberIndex) bool {
		_, providedQualifiedShares := rm.receivedQualifiedSharesS[member]
		_, providedValidPublicKeyShare := rm.receivedValidPeerPublicKeySharePoints[member]

		return providedQualifiedShares && !providedValidPublicKeyShare
	}

	// From disqualified members list filter those
	// whose shares need to be reconstructed.
	for _, disqualifiedMemberID := range rm.group.DisqualifiedMemberIDs() {
		if needsReconstruction(disqualifiedMemberID) {
			members = append(members, disqualifiedMemberID)
		}
	}

	// From inactive members list filter those
	// whose shares need to be reconstructed.
	for _, inactiveMemberID := range rm.group.InactiveMemberIDs() {
		if needsReconstruction(inactiveMemberID) {
			members = append(members, inactiveMemberID)
		}
	}

	return members
}

// ReconstructMisbehavedIndividualKeys reconstructs individual private key
// `z_m` and  public key `y_m` of every disqualified or inactive member `m` from
// QUAL set. QUAL contains all group members which provided valid shares in
// Phase 3. To do that, it first needs to recover shares calculated by IA/DQ QUAL
// members `m` in Phase 3 for other members `k`. The shares were encrypted
// before broadcast, so ephemeral symmetric key needs to be recovered. This
// requires messages containing ephemeral private key revealed by member `k`
// used in communication with misbehaved member `m`.
//
// See Phase 11 of the protocol specification.
func (rm *ReconstructingMember) ReconstructMisbehavedIndividualKeys(
	messages []*MisbehavedEphemeralKeysMessage,
) error {
	for _, message := range messages {
		// Validate received message. If message is invalid, sender should
		// be considered as misbehaving and marked as disqualified.
		if !rm.isValidMisbehavedEphemeralKeysMessage(message) {
			rm.logger.Warningf(
				"[member:%v] member [%v] disqualified because of "+
					"sending invalid misbehaved ephemeral keys message",
				rm.ID,
				message.senderID,
			)
			rm.group.MarkMemberAsDisqualified(message.senderID)
		}
	}

	revealedMisbehavedMembersShares, err := rm.revealMisbehavedMembersShares(messages)
	if err != nil {
		return fmt.Errorf("revealing misbehaved shares failed [%v]", err)
	}
	// Store for the purpose of combining group public key shares in phase 12.
	rm.revealedMisbehavedMembersShares = revealedMisbehavedMembersShares

	rm.reconstructIndividualPrivateKeys(revealedMisbehavedMembersShares) // z_m
	rm.reconstructIndividualPublicKeys()                                 // y_m
	return nil
}

// Reveal shares calculated by QUAL members disqualified or marked as inactive
// in previous phases. First, perform shares recovery based on received
// MisbehavedEphemeralKeysMessage. Then, add misbehaved member shares generated
// for the current member. In result, a complete slice of shares is returned and
// reconstruction of individual private keys is possible.
func (rm *ReconstructingMember) revealMisbehavedMembersShares(
	messages []*MisbehavedEphemeralKeysMessage,
) ([]*misbehavedShares, error) {
	recoveredShares, err := rm.recoverMisbehavedShares(messages)
	if err != nil {
		return nil, err
	}

	// Add reconstructed member shares generated for the current member.
	for _, memberID := range rm.expectedMembersForReconstruction {
		for _, shares := range recoveredShares {
			if shares.misbehavedMemberID == memberID {
				if currentMemberShare, ok := rm.receivedQualifiedSharesS[memberID]; ok {
					shares.peerSharesS[rm.ID] = currentMemberShare
				}
				break
			}
		}
	}

	return recoveredShares, nil
}

// Recover shares `s_mk` calculated by members `m` being in QUAL set and marked
// as disqualified or inactive.
// The shares were evaluated in Phase 3 by `m` for other members `k` and
// broadcasted in an encrypted fashion, hence reconstructing member has to
// recover a symmetric key to decode the shares messages. It returns a slice
// containing shares `s_mk` recovered for each member `m` whose ephemeral key
// was revealed in provided MisbehavedEphemeralKeysMessage.
func (rm *ReconstructingMember) recoverMisbehavedShares(
	messages []*MisbehavedEphemeralKeysMessage,
) ([]*misbehavedShares, error) {
	revealedMisbehavedShares := make([]*misbehavedShares, 0)

	// For misbehaved member `m` add shares `s_mk` the member calculated for
	// other members `k` who revealed the ephemeral key.
	addShare := func(
		misbehavedMemberID, revealingMemberID group.MemberIndex, // m, k
		shareS *big.Int, // s_mk
	) {
		// If a `misbehavedShares` entry already exists in the slice for given
		// misbehaved member add the share.
		for _, misbehavedShares := range revealedMisbehavedShares {
			if misbehavedShares.misbehavedMemberID == misbehavedMemberID {
				misbehavedShares.peerSharesS[revealingMemberID] = shareS
				return
			}
		}

		// When a `misbehavedShares` entry doesn't exist yet in the slice for given
		// misbehaved member initialize it with the share.
		newMisbehavedShares := &misbehavedShares{
			misbehavedMemberID: misbehavedMemberID,
			peerSharesS:        make(map[group.MemberIndex]*big.Int),
		}
		newMisbehavedShares.peerSharesS[revealingMemberID] = shareS

		revealedMisbehavedShares = append(
			revealedMisbehavedShares,
			newMisbehavedShares,
		)
	}

	for _, message := range messages {
		revealingMemberID := message.senderID

		for misbehavedMemberID, revealedPrivateKey := range message.privateKeys {
			if rm.ID == misbehavedMemberID {
				// Mark the revealing member as disqualified immediately,
				// as each member consider itself as a honest participant.
				// Continue as there is no sense to recover own shares.
				rm.group.MarkMemberAsDisqualified(revealingMemberID)
				continue
			}

			// After phase 9, all group members should have the same view on
			// who is disqualified. Revealing key of non-misbehaved members
			// is forbidden and leads to disqualifying the revealing member.
			// This situation should be already handled by message validation
			// so we just skip and continue.
			if rm.group.IsOperating(misbehavedMemberID) {
				continue
			}

			revealingMemberPublicKey := findPublicKey(
				rm.logger,
				rm.evidenceLog,
				revealingMemberID,
				misbehavedMemberID,
			)
			if revealingMemberPublicKey == nil {
				// Ephemeral public key of the revealing member, generated for
				// the sake of communication with the misbehaved member should
				// be present in the evidence log. The key is not there only if
				// it was not sent by the revealing member in the first phase of
				// the protocol and such behaviour results in marking that
				// member as disqualified in the second phase. As a result, we
				// no longer accept messages from that member and it is not
				// possible we will receive a MisbehavedEphemeralKeysMessage
				// from an inactive member in this phase. If the public key
				// could not be found we consider this a fatal error.
				// Such a situation should never happen.
				return nil, fmt.Errorf(
					"could not find public key sent by [%v] to [%v]",
					revealingMemberID,
					misbehavedMemberID,
				)
			}

			if !revealingMemberPublicKey.IsKeyMatching(revealedPrivateKey) {
				rm.logger.Warningf(
					"[member:%v] member [%v] disqualified because of "+
						"revealing private key not matching the public key",
					rm.ID,
					revealingMemberID,
				)
				rm.group.MarkMemberAsDisqualified(revealingMemberID)
				continue
			}

			// Recover symmetric key based on ephemeral public key message sent
			// by the disqualified or inactive QUAL member.
			//
			// If the message is not present in the evidence log it means the
			// member is not in QUAL.
			// That member was marked as inactive in phase 2 because they did
			// not broadcast ephemeral public key message.
			//
			// If the message is present in the evidence log but it does not
			// contain public key generated for the sake of communication
			// with the revealing member, it means the member which sent that
			// message is not QUAL.
			// That member was marked as disqualified in phase 2 because their
			// ephemeral public key message did not contain public keys for all
			// group members.
			//
			// Revealing private key generated for the sake of communication
			// with a member out of the DQ/IA QUAL members group is
			// considered as misbehavior and leads to disqualification of
			// the revealing member. This was already checked during the
			// validation of the message and disqualification - if needed - was
			// performed there, so in the case when we can not find ephemeral
			// public key, we just skip and continue.
			misbehavedMemberPublicKey := findPublicKey(
				rm.logger,
				rm.evidenceLog,
				misbehavedMemberID,
				revealingMemberID,
			)
			if misbehavedMemberPublicKey == nil {
				rm.logger.Warningf(
					"[member:%v] member [%v] disqualified because could not "+
						"recover symmetric key; misbehaved member [%v] is "+
						"already marked as inactive or disqualified in phase 2",
					rm.ID,
					revealingMemberID,
					misbehavedMemberID,
				)
				rm.group.MarkMemberAsDisqualified(revealingMemberID)
				continue
			}
			recoveredSymmetricKey := revealedPrivateKey.Ecdh(misbehavedMemberPublicKey)

			// Get from the evidence log peer shares message sent by the member
			// for which the private key has been revealed.
			// If the message is not present there, it means that member has
			// been marked as inactive in phase 4. Since we expect the revealing
			// member to reveal private keys generated for the sake of
			// communication only with inactive and disqualified members of QUAL
			// set, this situation is a misbehaviour. Member which has been
			// disqualified in phase 4 does not belong to QUAL set.
			misbehavedMemberSharesMessage := rm.evidenceLog.peerSharesMessage(misbehavedMemberID)
			if misbehavedMemberSharesMessage == nil {
				rm.logger.Warningf(
					"[member:%v] member [%v] disqualified because of revealing "+
						"private key of a member which did not provide shares in phase 3",
					rm.ID,
					revealingMemberID,
				)
				rm.group.MarkMemberAsDisqualified(revealingMemberID)
				continue
			}

			// If shares can not be decrypted, it means the revealing member
			// knew about this fact in phase 3 and did not complain in phase 4.
			// As a result, we did not mark the member for which the private key
			// has been revealed as disqualified earlier, in phase 5.
			// Not reporting misbehaviour is also a protocol violation, so we
			// disqualify the revealing member.
			shareS, shareT, err := misbehavedMemberSharesMessage.decryptShares(
				revealingMemberID,
				recoveredSymmetricKey,
			)
			if err != nil {
				rm.logger.Warningf(
					"[member:%v] member [%v] disqualified because of not "+
						"reporting protocol violation in phase 3 by member [%v] - "+
						"shares can not be decrypted",
					rm.ID,
					revealingMemberID,
					misbehavedMemberID,
				)
				rm.group.MarkMemberAsDisqualified(revealingMemberID)
				continue
			}

			if rm.areSharesValidAgainstCommitments(
				shareS, shareT,
				rm.receivedPeerCommitments[misbehavedMemberID],
				revealingMemberID,
			) {
				addShare(misbehavedMemberID, revealingMemberID, shareS)
			} else {
				// Similar situation as for shares that can not be decrypted.
				// The revealing member knew about the fact shares are
				// inconsistent in phase 3 and did not complain in phase 4.
				// As a result, we did not mark the member for which the private
				// key has been revealed as disqualified earlier, in phase 5.
				// Not reporting misbehavior is also a protocol violation, so we
				// disqualify the revealing member.
				rm.logger.Warningf(
					"[member:%v] member [%v] disqualified because of not "+
						"reporting protocol violation in phase 3 by member [%v] - "+
						"shares are inconsistent",
					rm.ID,
					revealingMemberID,
					misbehavedMemberID,
				)
				rm.group.MarkMemberAsDisqualified(revealingMemberID)
			}
		}
	}
	return revealedMisbehavedShares, nil
}

// isValidMisbehavedEphemeralKeysMessage validates a given
// MisbehavedEphemeralKeysMessage. Message is considered valid if it reveals
// all private keys generated for the sake of communication with all IA/DQ
// QUAL (sharing) members whose shares needs to be reconstructed.
func (rm *ReconstructingMember) isValidMisbehavedEphemeralKeysMessage(
	message *MisbehavedEphemeralKeysMessage,
) bool {
	for _, memberForReconstruction := range rm.expectedMembersForReconstruction {
		isKeyForMemberRevealed := false
		for memberID := range message.privateKeys {
			if memberID == memberForReconstruction {
				isKeyForMemberRevealed = true
				break
			}
		}

		if !isKeyForMemberRevealed {
			rm.logger.Warningf(
				"[member:%v] member [%v] sent message which does not "+
					"reveal private key of inactive/disqualified QUAL member [%v]",
				rm.ID,
				message.senderID,
				memberForReconstruction,
			)
			return false
		}
	}

	for memberID := range message.privateKeys {
		if rm.group.IsOperating(memberID) {
			rm.logger.Warningf(
				"[member:%v] member [%v] sent message which reveals "+
					"private key of an operating member [%v]",
				rm.ID,
				message.senderID,
				memberID,
			)
			return false
		}
	}

	return true
}

// misbehavedShares contains shares `s_mk` calculated by the misbehaved
// member `m` for peer members `k`. The shares were revealed due to
// disqualification or inactivity of the member `m` from the protocol execution.
type misbehavedShares struct {
	misbehavedMemberID group.MemberIndex              // m
	peerSharesS        map[group.MemberIndex]*big.Int // <k, s_mk>
}

// reconstructIndividualPrivateKeys reconstructs misbehaved members' individual
// private keys `z_m` from provided revealed shares calculated by misbehaved
// members for peer members.
//
// Function need to be executed for QUAL members marked as disqualified or inactive.
//
// It stores a map of reconstructed individual private keys for each misbehaved
// member in a current member's reconstructedIndividualPrivateKeys field:
// <misbehavedMemberID, privateKeyShare>
func (rm *ReconstructingMember) reconstructIndividualPrivateKeys(
	revealedMisbehavedShares []*misbehavedShares,
) {
	rm.reconstructedIndividualPrivateKeys = make(map[group.MemberIndex]*big.Int, len(revealedMisbehavedShares))

	for _, ds := range revealedMisbehavedShares { // for each misbehaved member
		// Reconstruct individual private key `z_m = Σ (s_mk * a_mk) mod q` where:
		// - `z_m` is misbehaved member's individual private key
		// - `s_mk` is a share calculated by misbehaved member `m` for peer member `k`
		// - `a_mk` is lagrange coefficient for peer member k (see below)
		individualPrivateKey := big.NewInt(0)
		// Get IDs of all peer members from misbehaved shares.
		var peerIDs []group.MemberIndex
		for k := range ds.peerSharesS {
			peerIDs = append(peerIDs, k)
		}
		// For each peerID `k` and peerShareS `s_mk` calculate `s_mk * a_mk`
		for peerID, peerShareS := range ds.peerSharesS {
			// a_mk
			lagrangeCoefficient := rm.calculateLagrangeCoefficient(peerID, peerIDs)

			// Σ (s_mk * a_mk) mod q
			individualPrivateKey = new(big.Int).Mod(
				new(big.Int).Add(
					individualPrivateKey,
					// s_mk * a_mk
					new(big.Int).Mul(peerShareS, lagrangeCoefficient),
				),
				bn256.Order,
			)
		}
		// <m, z_m>
		rm.reconstructedIndividualPrivateKeys[ds.misbehavedMemberID] =
			individualPrivateKey
	}
}

// Calculates Lagrange coefficient `a_mk` for member `k` in a group of members.
//
// `a_mk = Π (l / (l - k)) mod q` where:
// - `a_mk` is a lagrange coefficient for the member `k`,
// - `l` are IDs of members who provided shares,
// - `q` is an order of alt_bn128 elliptic curve
// and `l != k`.
func (rm *ReconstructingMember) calculateLagrangeCoefficient(memberID group.MemberIndex, groupMembersIDs []group.MemberIndex) *big.Int {
	lagrangeCoefficient := big.NewInt(1)
	// For each otherID `l` in groupMembersIDs:
	for _, otherID := range groupMembersIDs {
		if otherID != memberID { // l != k
			// l / (l - k)
			quotient := new(big.Int).Mod(
				new(big.Int).Mul(
					big.NewInt(int64(otherID)),
					new(big.Int).ModInverse(
						new(big.Int).Sub(
							big.NewInt(int64(otherID)),
							big.NewInt(int64(memberID)),
						),
						bn256.Order,
					),
				),
				bn256.Order,
			)

			// Π (l / (l - k)) mod q
			lagrangeCoefficient = new(big.Int).Mod(
				new(big.Int).Mul(
					lagrangeCoefficient, quotient,
				),
				bn256.Order,
			)
		}
	}
	return lagrangeCoefficient // a_mk
}

// reconstructIndividualPublicKeys calculates and stores individual public keys
// `y_m` from reconstructed individual private keys `z_m`.
//
// Public key is calculated as `g^privateKey mod p` what, using elliptic curve,
// is the same as `G * privateKey`.
//
// See Phase 11 of the protocol specification.
func (rm *ReconstructingMember) reconstructIndividualPublicKeys() {
	rm.reconstructedIndividualPublicKeys = make(
		map[group.MemberIndex]*bn256.G2,
		len(rm.reconstructedIndividualPrivateKeys),
	)
	for memberID, individualPrivateKey := range rm.reconstructedIndividualPrivateKeys {
		// y_m = G * z_m
		individualPublicKey := new(bn256.G2).ScalarBaseMult(individualPrivateKey)
		rm.reconstructedIndividualPublicKeys[memberID] = individualPublicKey
	}
}

func pow(id group.MemberIndex, y int) *big.Int {
	return new(big.Int).Exp(big.NewInt(int64(id)), big.NewInt(int64(y)), nil)
}

// CombineGroupPublicKey calculates a group public key by combining individual
// public keys. Group public key is calculated as a product of individual public
// keys of all group members including member themself.
//
// `Y = Π y_j mod p` for `j`, where `y_j` is individual public key of each
// qualified group member. With elliptic curve, it is: `Y = Σ y_j`.
//
// This function combines individual public keys of all Qualified Members who were
// approved for Phase 6. Three categories of individual public keys are considered:
// 1. Current member's individual public key.
// 2. Peer members' individual public keys - for members who passed a public key
//    share points validation in Phase 8 and accusations resolution in Phase 9 and
//    are still active group members.
// 3. Misbehaved members' individual public keys - for QUAL members who were
//    marked as disqualified or inactive and theirs individual private and
//    public keys were reconstructed in Phase 11.
//
// See Phase 12 of the protocol specification.
func (cm *CombiningMember) CombineGroupPublicKey() {
	// Current member's individual public key `A_i0`.
	groupPublicKey := cm.individualPublicKey()

	// Add received peer group members' individual public keys `A_j0`.
	for _, peerPublicKey := range cm.receivedValidPeerIndividualPublicKeys() {
		groupPublicKey = new(bn256.G2).Add(groupPublicKey, peerPublicKey)
	}

	// Add reconstructed misbehaved members' individual public keys `G * z_m`.
	for _, peerPublicKey := range cm.reconstructedIndividualPublicKeys {
		groupPublicKey = new(bn256.G2).Add(groupPublicKey, peerPublicKey)
	}

	cm.groupPublicKey = groupPublicKey
}

// ComputeGroupPublicKeyShares computes group public key shares for each
// individual member in the group. Those group public key shares are
// needed to perform the verification of relay entry signature shares coming
// from given group member.
func (cm *CombiningMember) ComputeGroupPublicKeyShares() {
	go func() {
		cm.logger.Infof(
			"[member:%v] starting computation of group public key shares",
			cm.ID,
		)

		groupPublicKeyShares := make(map[group.MemberIndex]*bn256.G2)

		// Calculate group public key shares for all other operating members.
		for _, operatingMemberID := range cm.group.OperatingMemberIDs() {
			if operatingMemberID == cm.ID {
				continue
			}

			// Calculate the first public key share for the given operating
			// member based on the current member public key share points.
			sum := cm.publicKeyShare(operatingMemberID, cm.publicKeySharePoints)

			// Iterate through the `QUAL` set and calculate subsequent
			// public key share for the given operating member based on...
			for qualifiedMemberID := range cm.receivedQualifiedSharesS {
				// ...received and valid member's public key share points...
				if publicKeySharePoints, ok := cm.receivedValidPeerPublicKeySharePoints[qualifiedMemberID]; ok {
					publicKeyShare := cm.publicKeyShare(
						operatingMemberID,
						publicKeySharePoints,
					)
					sum = new(bn256.G2).Add(sum, publicKeyShare)
					// ...OR in case given sender didn't send their public key
					// share points, take their reconstructed share and recover
					// the public key share.
				} else {
					for _, shares := range cm.revealedMisbehavedMembersShares {
						if shares.misbehavedMemberID == qualifiedMemberID {
							publicKeyShare := new(bn256.G2).ScalarBaseMult(
								shares.peerSharesS[operatingMemberID],
							)
							sum = new(bn256.G2).Add(sum, publicKeyShare)
						}
					}
				}
			}

			groupPublicKeyShares[operatingMemberID] = sum
		}

		cm.logger.Infof(
			"[member:%v] completed computation of group public key shares",
			cm.ID,
		)

		cm.groupPublicKeySharesChannel <- groupPublicKeyShares
	}()
}
