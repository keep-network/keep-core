package result

import (
	"bytes"
	"encoding/binary"
	"fmt"
	"math/big"

	"github.com/ethereum/go-ethereum/crypto/sha3"
)

// Result of distributed key generation protocol.
//
// Success means that the protocol execution finished with acceptable number of
// disqualified or inactive members. The group of remaining members should be
// added to the signing groups for the threshold relay.
//
// Failure means that the group creation could not finish, due to either the number
// of inactive or disqualified participants, or the presented results being
// disputed in a way where the correct outcome cannot be ascertained.
type Result struct {
	// Result type of the protocol execution. True if success, false if failure.
	Success bool
	// Group public key generated by protocol execution.
	GroupPublicKey *big.Int `json:"pubkey"`
	// Disqualified members IDs.
	Disqualified []int `json:"disqualified"`
	// Inactive members IDs.
	Inactive []int `json:"inactive"`
	// HashValue the hash // xyzzy
	HashValue []byte // xyzzy
}

// Bytes returns the result as a byte slice.
// TODO: How should we send it to the chain? Should it be sha256 hash, result
// serialized to json or something else?
func (r *Result) Bytes() []byte {
	return []byte(fmt.Sprintf("%v", r))
}

func (r *Result) Hash() []byte {
	// OLD: return []byte(fmt.Sprintf("%v", r))
	bb := SearilizeResultForHash(*r)
	hh := Keccak256(bb)
	return hh
}

func (r Result) Equal(s Result) bool {
	return bytes.Equal(r.HashValue, s.HashValue)
}

func SearilizeResultForHash(rs Result) []byte {
	var buf bytes.Buffer

	//binary.Write(&buf, binary.BigEndian, int64(rs.Type))

	binary.Write(&buf, binary.BigEndian, int64(len(rs.Disqualified)))
	for _, b := range rs.Disqualified {
		if b == 1 {
			buf.Write([]byte{'1'})
		} else {
			buf.Write([]byte{'0'})
		}
	}

	buf.Write([]byte(rs.GroupPublicKey.String()))

	binary.Write(&buf, binary.BigEndian, int64(len(rs.Inactive)))
	for _, b := range rs.Inactive {
		if b == 1 {
			buf.Write([]byte{'1'})
		} else {
			buf.Write([]byte{'0'})
		}
	}

	return buf.Bytes()
}

// Keccak256 use the Ethereum Keccak hashing fucntions to return a hash from a list of values.
func Keccak256(data ...[]byte) []byte {
	d := sha3.NewKeccak256()
	for _, b := range data {
		d.Write(b)
	}
	return d.Sum(nil)
}
