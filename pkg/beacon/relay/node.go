package relay

import (
	"fmt"
	"math/big"
	"os"
	"reflect"
	"sync"

	relaychain "github.com/keep-network/keep-core/pkg/beacon/relay/chain"
	"github.com/keep-network/keep-core/pkg/beacon/relay/config"
	"github.com/keep-network/keep-core/pkg/chain"
	"github.com/keep-network/keep-core/pkg/net"
	"github.com/keep-network/keep-core/pkg/staker"
	"github.com/keep-network/keep-core/pkg/thresholdgroup"
)

// Node represents the current state of a relay node.
type Node struct {
	mutex sync.Mutex

	// StakeID is the ID this node is using to prove its stake in the system.
	StakeID string
	// Staker is an on-chain identity that this node is using to prove its
	// stake in the system.
	Staker staker.Staker

	// External interactors.
	netProvider  net.Provider
	blockCounter chain.BlockCounter
	chainConfig  config.Chain

	// The IDs of the known stakes in the system, including this node's StakeID.
	stakeIDs      []string
	maxStakeIndex int

	groupPublicKeys [][]byte
	seenPublicKeys  map[string]struct{}
	myGroups        map[string]*membership
	pendingGroups   map[string]*membership
}

type membership struct {
	member  *thresholdgroup.Member
	channel net.BroadcastChannel
	index   int
}

// JoinGroupIfEligible takes a threshold relay entry value and undergoes the
// process of joining a group if this node's virtual stakers prove eligible for
// the group generated by that entry. This is an interactive on-chain process,
// and JoinGroupIfEligible can block for an extended period of time while it
// completes the on-chain operation.
//
// Indirectly, the completion of the process is signaled by the formation of an
// on-chain group containing at least one of this node's virtual stakers.
func (n *Node) JoinGroupIfEligible(
	groupChain relaychain.GroupInterface,
	entryValue *big.Int,
) {
	err := n.submitTicketsForGroupSelection(
		entryValue.Bytes(),
		groupChain,
		nil,
	)
	if err != nil {
		fmt.Fprintf(
			os.Stderr,
			"Failed submission of tickets for group selection: [%v].\n",
			err,
		)
		return
	}
}

// AddStaker registers a staker seen on-chain for the node's internal tracking.
func (n *Node) AddStaker(index int, staker string) {
	n.mutex.Lock()
	defer n.mutex.Unlock()

	if cap(n.stakeIDs) <= index { // we index from 0
		// need something larger
		newSlice := make([]string, index*2)
		copy(newSlice, n.stakeIDs)
		n.stakeIDs = newSlice
	}

	n.stakeIDs[index] = staker

	if index > n.maxStakeIndex {
		n.maxStakeIndex = index
	}
}

// SyncStakingList performs an initial sync of the on-chain staker list into
// the node's internal state.
func (n *Node) SyncStakingList(stakingList []string) {
	for index, value := range stakingList {
		n.AddStaker(index, value)
	}
}

// RegisterGroup registers that a group was successfully created by the given
// requestID, and its group public key is groupPublicKey.
func (n *Node) RegisterGroup(requestID string, groupPublicKey []byte) {
	n.mutex.Lock()
	defer n.mutex.Unlock()

	// If we've already registered a group for this request ID, return early.
	if _, exists := n.seenPublicKeys[requestID]; exists {
		return
	}

	n.seenPublicKeys[requestID] = struct{}{}
	n.groupPublicKeys = append(n.groupPublicKeys, groupPublicKey)
	index := len(n.groupPublicKeys) - 1

	if membership, found := n.pendingGroups[requestID]; found && membership != nil {
		membership.index = index
		n.myGroups[requestID] = membership
		delete(n.pendingGroups, requestID)
	}
}

// initializePendingGroup grabs ownership of an attempt at group creation for a
// given goroutine. If it returns false, we're already in progress and failed to
// initialize.
func (n *Node) initializePendingGroup(requestID string) bool {
	n.mutex.Lock()
	defer n.mutex.Unlock()

	// If the pending group exists, we're already active
	if _, found := n.pendingGroups[requestID]; found {
		return false
	}

	// Pending group does not exist, take control
	n.pendingGroups[requestID] = nil

	return true
}

// flushPendingGroup if group creation fails, we clean our references to creating
// a group for a given request ID.
func (n *Node) flushPendingGroup(requestID string) {
	n.mutex.Lock()
	defer n.mutex.Unlock()

	if membership, found := n.pendingGroups[requestID]; found && membership == nil {
		delete(n.pendingGroups, requestID)
	}
}

// registerPendingGroup assigns a new membership for a given request ID.
// We overwrite our placeholder membership set by initializePendingGroup.
func (n *Node) registerPendingGroup(
	requestID string,
	member *thresholdgroup.Member,
	channel net.BroadcastChannel,
) {
	n.mutex.Lock()
	defer n.mutex.Unlock()

	if _, seen := n.seenPublicKeys[requestID]; seen {
		groupPublicKey := member.GroupPublicKeyBytes()
		// Start at the end since it's likely the public key was closer to the
		// end if it happened to come in before we had a chance to register it
		// as pending.
		existingIndex := len(n.groupPublicKeys) - 1
		for ; existingIndex >= 0; existingIndex-- {
			if reflect.DeepEqual(n.groupPublicKeys[existingIndex], groupPublicKey[:]) {
				break
			}
		}

		n.myGroups[requestID] = &membership{
			index:   existingIndex,
			member:  member,
			channel: channel,
		}
		delete(n.pendingGroups, requestID)
	} else {
		n.pendingGroups[requestID] = &membership{
			member:  member,
			channel: channel,
		}
	}
}
