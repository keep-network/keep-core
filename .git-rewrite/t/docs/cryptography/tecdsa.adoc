:toc: macro
:toclevels: 4

= t-ECDSA Protocol

toc::[]

== Phases Description

=== Setup

==== Commitment Master Public Key
[.lead]
_Commitment Master Public Key_ is a value needed for commitment generation.
This setup needs to be performed before each of two phases: <<Key Generation>> and 
<<Signing>>. _Commitment Master Public Key_ is generated by each signer individually 
and sent to all other peer signers. When generating a commitment that will be sent 
to a verifier, committer is required to use the verifier's _Commitment Master Public Key_.

Output::
* _Commitment Master Public Key_

===== Procedure

. A signer generates _Commitment Master Public Key_ and broadcasts it to all peer 
signers in _CommitmentMasterPublicKeyMessage_:
+
.CommitmentMasterPublicKeyShareMessage
[%header]
|=== 
^|Field Name ^|Type ^|Description

|`masterPublicKey` 
|`[]byte`
|Master Public Key
|=== 

=== Key Generation

[.lead]
In this phase signers jointly generate an _ECDSA Key_ which is used in the Signing
phase.

This phase requires all signers in the group to cooperate to produce a valid 
_ECDSA Key_. If malicious behavior is detected from any signer, the whole phase 
is aborted.

==== Round #1

Input::
* _Commitment Master Public Key_

Output::
* _Public Key Share Commitment_

===== Procedure

. Each signer generates _ECDSA Key Share_ which consists of _ECDSA Private Key Share_ 
and _ECDSA Public Key Share_.
+
_ECDSA Private Key Share_ value must be kept secret and never shared in a plaintext 
form.
+
_ECDSA Public Key Share_ value cannot be exposed until all signers in the group 
commit to their values.

. Each signer calculates a commitment to the _ECDSA Public Key Share_ value and 
publishes this commitment in  _PublicKeyShareCommitmentMessage_:

.PublicKeyShareCommitmentMessage
[%header]
|=== 
^|Field Name ^|Type ^|Description

|`publicKeyShareCommitment` 
|`commitment.MultiTrapdoorCommitment`
|Commitment to _ECDSA Public Key Share_
|=== 

==== Round #2

Input::
* _ECDSA Public Key Share Commitment_

Output::
* _ECDSA Key_ {_Encrypted ECDSA Private Key_, _ECDSA Public Key_}

===== Procedure

After commitments from all signers are gathered the second round starts.

. Signers reveal their _ECDSA Key Shares_ and send _KeyShareRevealMessage_. 
+
Since _ECDSA Private Key Share_ should always be kept secret it is first encrypted with
Paillier and this encrypted value is published along with Zero Knowledge Proof 
Π~i~, certifying that:
+
[NOTE]
.Zero Knowledge Proof Π~i~
====
∃ _secretKeyShare_ ∈ [-q^3^, q^3^] such that

_g_^_secretKeyShare_^ = _publicKeyShare_

D(_encryptedSecretKeyShare_) = _secretKeyShare_

where _q_ is an order and _g_ is a generator point of an Elliptic Curve and 
D is a Decrypt function of a Paillier scheme
====
+
_ECDSA Public Key Share_ is published with a decommitment key used in a previous 
round to produce a commitment to _ECDSA Public Key Share_ value.
+
.KeyShareRevealMessage
[%header]
|=== 
^|Field Name ^|Type ^|Description

|`secretKeyShare` 
|`paillier.Cypher`
|Encrypted _ECDSA Private Key Share_

|`publicKeyShare` 
|`curve.Point`
|_ECDSA Public Key Share_

|`publicKeyShareDecommitmentKey` 
|`commitment.DecommitmentKey`
|Decommitment key for _ECDSA Public Key Share_

|`secretKeyProof` 
|`zkp.EcdsaPaillierKeyRangeProof`
|ZKP Π~i~
|=== 

. Each signer validates received _KeyShareRevealMessages_ and combines shares 
to get encrypted _ECDSA Private Key_ and _ECDSA Public Key_ which together form 
_ECDSA Key_. + 
The _ECDSA Private Key_ is created by combining the Paillier-encrypted _ECDSA 
Private Key Shares_ using a threshold variant of Paillier's homomorphic operations.

=== Signing

[.lead]
In this phase the signers jointly generate a _Signature_ for a _Message Hash_.

Signers communicate with each other in 6 rounds, exchanging information
to produce a threshold ECDSA (t-ECDSA) _Signature_ in a {_R_, _S_} format over an
exactly 32-byte _Message Hash_, where R and S are results of signature computation 
algorithm.

Before starting this phase a fresh <<Commitment Master Public Key>> should be generated.

This phase also requires the _ECDSA Key_ generated in the <<Key Generation>> phase.

Not all signers are required to complete this phase; the minimum number of signers needed is specified by the _Threshold_. +
A signer can be expelled from the signing group if they misbehave or don't provide
a message on time.

==== Round #1 [[sign_round_1]]

Input::
* _Encrypted ECDSA Private Key_
* _Commitment Master Public Key_

Output::
* _ECDSA Private Key Factor Share Commitment_

===== Procedure

. Each signer generates _Encrypted ECDSA Private Key Factor Share_ and 
_ECDSA Private Key Multiple Share_. These values are kept private for now. +

. Signer calculates a commitment to both values and publishes the commitment in 
_SignRound1Message_.
+
.SignRound1Message
[%header]
|=== 
^|Field Name ^|Type ^|Description

|`secretKeyFactorShareCommitment` 
|`commitment.MultiTrapdoorCommitment`
|Commitment to _ECDSA Private Key Factor Share_ and _ECDSA Private Key Multiple Share_
|=== 

==== Round #2 [[sign_round_2]]

Output::
* _Encrypted ECDSA Private Key Factor Share_
* _ECDSA Private Key Multiple Share_
* Decommitment key for _ECDSA Private Key Factor Share Commitment_
* _Zero Knowledge Proof Π~1,i~_

===== Procedure

. Each signer calculates a Zero Knowledge Proof Π~1,i~ for his individual parameters,
certifying that:
+
[NOTE]
.Zero Knowledge Proof Π~1,i~
====
∃ _secretKeyFactorShare_ ∈ [-q^3^, q^3^] such that

D(_encryptedSecretKeyFactorShare_) = _secretKeyFactorShare_

D(_secretKeyMultipleShare_) = _secretKeyFactorShare_ * D(_secretKey_)

where _q_ is an order of an Elliptic Curve and D is a Decrypt function of a Paillier scheme
====

. Signers publish _SignRound2Message_ containing _ECDSA Private Key Factor Share_, 
_ECDSA Private Key Multiple Share_ and decommitment key for the commitment from 
<<sign_round_1>>.
+
.SignRound2Message
[%header]
|=== 
^|Field Name ^|Type ^|Description

|`secretKeyFactorShare` 
|`paillier.Cypher`
|_ECDSA Private Key Factor Share_

|`secretKeyMultipleShare` 
|`paillier.Cypher`
|_ECDSA Private Key Multiple Share_

|`secretKeyFactorShareDecommitmentKey` 
|`commitment.DecommitmentKey`
|Decommitment key for a commitment to _ECDSA Private Key Factor Share_ and _ECDSA Private Key Multiple Share_

|`secretKeyFactorProof` 
|`zkp.EcdsaPaillierSecretKeyFactorRangeProof`
|ZKP Π~1,i~
|=== 

. Signer validates received _SignRound1Messages_ and _SignRound2Messages_. +
Combines shares to get _ECDSA Private Key Factor_ and _ECDSA Private Key Multiple_.

==== Round #3 [[sign_round_3]]

Input::
* _ECDSA Private Key Factor_
* _ECDSA Private Key Multiple_
* _Commitment Master Public Key_

Output::
* _Signature Factor Share Commitment_

===== Procedure

. Each signer computes a set of parameters: _Signature Factor Public Share_ and 
_Signature Unmask Share_ and calculates a commitment to these
values. All the parameters are kept private for now, they will be used later to
compute the final signature.

. Signer publishes the commitment in a _SignRound3Message_.
+
.SignRound3Message
[%header]
|=== 
^|Field Name ^|Type ^|Description

|`signatureFactorShareCommitment` 
|`commitment.MultiTrapdoorCommitment`
|Commitment to _Signature Factor Public Share_ and _Signature Unmask Share_
|=== 

==== Round #4 [[sign_round_4]]

Output::
* _Signature Factor Public Share_
* _Signature Unmask Share_
* Decommitment key for _Signature Factor Share Commitment_
* _Zero Knowledge Proof Π~2,i~_

===== Procedure

This round starts after all signers share their commitments in <<sign_round_3>>.

. Each signer calculates a Zero Knowledge Proof Π~2,i~ for his individual parameters,
certifying that:
+
[NOTE]
.Zero Knowledge Proof Π~2,i~
====
∃ _signatureFactorSecretShare_ ∈ [-q^3^, q^3^], _signatureFactorPublicShare_ ∈ [-q^8^, q^8^] such that

_g_^_signatureFactorSecretShare_^ = _signatureFactorPublicShare_

D(_signatureUnmaskShare_) = _signatureFactorSecretShare_ × D(_secretKeyFactor_) + _q_ × _signatureFactorMaskShare_

where _q_ is an order and _g_ is a generator point of an Elliptic Curve and 
D is a Decrypt function of a Paillier scheme
====

. Signers publish _SignRound4Message_ containing the Zero Knowledge Proof Π~2,i~,
along with parameters and decommitment key from the <<sign_round_3>>.
+
.SignRound4Message
[%header]
|=== 
^|Field Name ^|Type ^|Description

|`signatureFactorPublicShare` 
|`curve.Point`
|_Signature Factor Public Share_

|`signatureUnmaskShare` 
|`paillier.Cypher`
|_Encrypted Signature Unmask Share_

|`signatureFactorShareDecommitmentKey` 
|`commitment.DecommitmentKey`
|Decommitment key for a commitment from <<sign_round_3>>

|`signatureFactorProof` 
|`zkp.EcdsaSignatureFactorRangeProof`
|ZKP Π~2,i~
|=== 

. Signer validates received _SignRound3Messages_ and _SignRound4Messages_. +
Combines shares to get _Signature Factor Public_ and _Encrypted Signature Unmask_.

==== Round #5 [[sign_round_5]]

Input::
* _Signature Factor Public_
* _Encrypted Signature Unmask_

Output::
* _Signature Unmask Partial Decryption_

===== Procedure

. Each signer computes a hash of _Signature Factor Public_ parameter.

. Signers jointly decrypt _Encrypted Signature Unmask_ with Paillier, so each signer
receives just a partial decryption of _Signature Unmask_.

. Signer publishes _SignRound5Message_.
+
.SignRound5Message
[%header]
|=== 
^|Field Name ^|Type ^|Description

|`signatureUnmaskPartialDecryption` 
|`paillier.PartialDecryption`
|_Signature Unmask_ partial decryption.
|=== 

. Signer validates received _SignRound5Messages_. +
Combines partial decryptions to get _Signature Unmask_.

==== Round #6 [[sign_round_6]]

Input::
* _Signature Unmask_
* _Message Hash_

Output::
* _Signature Partial Decryption_

===== Procedure

. Each signer computes _Encrypted Signature_ value for a _Message Hash_ with 
_Signature Unmask_, _Signature Factor Public Hash_ and encrypted _ECDSA Private Key Factor_ 
and _ECDSA Private Key Multiple_. +
It's possible to perform a computation on Paillier-encrypted parameters because 
it's an additively homomorphic scheme.

. Signers jointly decrypt the computed _Encrypted Signature_, so each signer receives 
a partial decryption of _Signature_.

. Signer publishes _SignRound6Message_.
+
.SignRound6Message
[%header]
|=== 
^|Field Name ^|Type ^|Description

|`signaturePartialDecryption` 
|`paillier.PartialDecryption`
|_Signature.S_ partial decryption.
|=== 

. Signer validates received _SignRound6Messages_ and combines partial decryptions 
to get _Signature_.

. Signer produces a _t-ECDSA Signature_ in {R,S} format where:
[horizontal]
R:: Hash of _Signature Factor Public_
S:: _Signature_

== Threats

* `Master Trapdoor` (`x`) is known to a committer. +
The security of a commitment depends solely on a verifier. `Master Trapdoor` 
generated in a setup phase has to remain secret. Committer cannot be able to evaluate
a value of `Master Trapdoor` in any way (e.g. by brute-forcing if the value is too weak). +
It's described in 
link:https://github.com/keep-network/keep-core/blob/master/docs/cryptography/tecdsa_setup.adoc#master-public-key[Master Public Key setup protocol] 
documentation.

* Signers provide too short `ECDSA Private Key Shares`. +
If the shares have small bit length, then a resulting `ECDSA Private Key` will be weak.
It gives an opportunity to brute-force the `ECDSA Private Key` when knowing 
`ECDSA Public Key`. +
Another scenario is that adversarial Signer provides a share which is close to 
curve's cardinality reduced by another signer's share. This way his share "clears"
the share of another participant. +
It's covered by an issue link:https://github.com/keep-network/keep-core/issues/270[#270]

* Adversary delivers invalid/corrupted partial decryption in round 5 or 6. +
The partial decryption may be corrupted. The decryption may also be valid, but underlying
value may not be evaluated from the previously published parameters. +
It's covered by an issue link:https://github.com/keep-network/keep-core/issues/246[#246]

* Signer provides invalid Commitment, Decommitment Key or Zero Knowledge Proof. +
In case of a misbehavior in Signing phase the signer is removed from the group 
and his shares are not taking a part in calculations anymore. When it happens in
Key Generation phase the protocol is aborted.
