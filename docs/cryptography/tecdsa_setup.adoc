= T-ECDSA setup protocol

== Goal

The goal of this document is to describe our custom approach for T-ECDSA 
protocol setup with no trusted oracle as well as to describe all the required 
modifications to the protocol itself to make the setup possible. This document 
does not cover a dealerless protocol for Paillier threshold key generator.

== Background

The Threshold-optimal DSA/ECDSA protocol described by Gennaro et al. [GGN16]  
assumes a number of initial parameters are provided by a trusted third-party. 
Those parameters need to meet certain strict requirements so that the protocol 
is secure. What's more, numbers used to construct those parameters must remain 
hidden from players executing the protocol. Those two facts eliminate the 
possibility of either randomly generating those parameters using a generic  
random beacon protocol or generating all those parameters by one member of the 
group. 

The mentioned parameters include:

* auxiliary RSA modulus `N_tilde` which is a product of two safe primes and is 
used to construct Zero-Knowledge Proofs `Π_i`, `Π_1i`, `Π_2i`, 
[GGN 16] section 4.4,

* two elements `h1`, `h2` from a multiplicative group of integers modulo `N_tilde` 
constructed according to Fujisaki and Okamoto [FO 97], used to construct range 
commitments in the Zero-Knowledge Proofs `Π_i`, `Π_1i`, `Π_2i`, [GGN 16] section 4.4,

* master public key used to construct multi-trapdoor commitments, [GGN 16] section 2.3,

For the sake of this document, we assume a threshold Paillier key is generated 
elsewhere. 

Since in the original paper, all those parameters are generated in accordance with 
the protocol by a trusted third party and numbers used to construct them are not 
known to the group members, all members use the same parameters and all the 
communication inside the group is public and based on broadcast messages.

== Setup protocol

=== ZKP `Π_i`, `Π_1i`, `Π_2i` parameters

Zero-knowledge proofs `Π` described by Gennaro are based on the work of 
MacKenzie and Reiter [MKR 04].  

According to their paper, soundness requires:

* `N_tilde = p_tilde * q_tilde`, where `p_tilde` and `q_tilde` are strong 
primes unknown for Prover,

* discrete logs of `h1` and `h2` relative to each other modulo `N_tilde` are 
unknown for Prover

Zero-knowledge requires:

* discrete logs of `h1` and `h2` relative to each other modulo `N_tilde` exist

Taking those requirements into account, we expect Verifier to generate `N_tilde`, 
`h1` and `h2` and send those values to Prover. Prover uses those values later to 
create Π proofs.  Along with those parameters, Verifier needs to provide a zero-knowledge 
proof for a discrete logarithm. 

The best solution in terms of security is to generate `N_tilde`, `h1`, and `h2` separately 
for each key-gen and signature protocol execution.

We may use modified Schnorr protocol to construct a zero-knowledge proof of a discrete 
logarithm. The original Schnorr protocol works as follows:

*Schnorr protocol setup*

* Prover chooses a large prime `p` and a generator `g` of the `q` order subgroup of `Z*_p`,

* Prover chooses a secret `x <- Z*_q`, computes `y=g^x` and gives `y` to Verifier.

*Schnorr protocol*

* Prover chooses `r <- Z*_q`, computes `t=g^r` and sends `t` to Verifier,

* Verifier chooses `c <- Z*_q` and sends `c` to Prover,

* Prover computes `s = r + cx` and sends `s` to Verifier,

* Verifier checks whether `g^s = ty^c`.

The original Schnorr protocol is interactive and honest-verifier zero-knowledge. It lets 
a dishonest adversary extract the secret value by executing the protocol twice for a different 
challenge and solving a simple equation:

```
secret = (s - s') / (c - c')
```

We use the Fiat-Shamir heuristic to make it interactive and statistically zero knowledge. 
The setup is the same as in the original version of the protocol.

*Schnorr protocol updated with Fiat-Shamir heuristic*

* Prover chooses `r <- Z*_q` and computes `t=g^r`,

* Prover computes `c = H(g, y, r)` where `H` is a cryptographic hash function,

* Prover computes `s = r + cx`. The resulting proof is the pair `(t, s)`.

* Verifier checks whether `g^s = ty^c`.

Since soundness requires `N_tilde` to be a product of two safe primes with factorization 
unknown for Prover, we can't just group-generate two primes and compute their product. 
For the same reason, we can't just choose `N_tilde` randomly. Since zero-knowledge requires 
discrete logs of `h1` and `h2` relative to each other modulo `N_tilde` to exist and soundness 
requires discrete logs are uknown for Prover, we can't just generate those parameters using 
the random beacon.

==== Alternative (slower) solution

The alternative approach we considered is to have a fixed `h2` and generate `h1` with the 
approach presented in [GJKR 99]. The `NTilde` can be then generated with a distributed algorithm 
described in [ACS 02] or [DM 10]. However, this approach seems to be significantly more 
time-consuming and would downgrade the performance of both key-generation and signing protocol 
if we want to generate those parameters for each signature separately (this is safer) or 
downgrade the performance of key-generation protocol if we want to generate them once 
(less safe approach).

=== Master public key

For `G` being a cyclic group of prime order `q` generated by `g`, the master trapdoor `x` in 
`Z_q` is used to evaluate the master public key `h=g^x` of the multi-trapdoor commitment scheme. 
Party aware of `x` can change the value it committed to before the decommitment phase happens. 
Clearly, none of the nodes should possess such a power. To avoid it, we want each node to generate 
its own multi-trapdoor public key, publish it and use for a verification. All other nodes publishing 
commitments, must use the specific master public key when evaluating and sending a commitment to the 
specific node. In this setup, commitment verifier has a trapdoor. However, since it's in the best 
interest of verifier to have non-alterable commitments, the scheme is safe by a definition.

==== Alternative (vulnerable) solution

The alternative approach we considered is to let each node to generate it's share of `h_i = g^{x_i}` 
and sum all of them together to produce a global master public key, `h = h_1 + h_2 + ... + h_n`. 
However, this approach has a vulnerability allowing the adversary to make all the parties use a 
master key to which the adversary knows a trapdoor: 

Global master public key generation scheme exploit:

* Each group member generates a G2 curve point which is its share for the master public key,
* Adversary waits until all other group members broadcast their shares,
* Adversary chooses secret exponent `x` which is a trapdoor, evaluates `F = g^x`,
* Adversary sums up all shares from other group members `h_{n-1} = h_1 + h_2 + ... + h_{n-1}`,
* Adversary computes `h_a = F - h_{n-1}` and broadcast it to the group,
* All group members computes `h_n = h_1 + h_2 + ... h_n` and `h_n = h_a` produced by adversary
since `h_a = F - h_{n-1}`, then `h_n = h_{n-1} + h_a = F`,
* `F` was evaluated by an adversary as `F = g^x`, so an adversary knows `x` which is a trapdoor.


=== Impact on the communication between group nodes

In the original implementation, all the communication between nodes can be public within a group. 
Every node uses the same value for setup parameters so there is always a single message for all 
nodes with ZKP or commitment. What's more, since the same ZKP and commitment is sent to all nodes, 
misbehavior is easily detected and reconciliation of the list of nodes behaving according to the 
protocol happens automatically between rounds. 

In our modified version, we need to either allow for a unicast communication between nodes or pack 
several one-to-one messages into a broadcast channel with each message possibly encrypted with an 
ephemeral key. This makes the misbehavior more difficult and complaints must be published individually, 
as well as a better reconciliation algorithm is needed. 

Luckily, for each published complaint we may assume at least one of the involved parties is always 
cheating. It means we can just publish private ephemeral keys for this communication channel, allowing 
all other nodes to inspect the content and to give their judgment. The fact that communication channel 
is compromised is fine since one party we'll be always excluded from the group and that channel will 
be no longer needed anyway.

== References

* [GGN 16]: Gennaro R., Goldfeder S., Narayanan A. (2016) Threshold-Optimal
DSA/ECDSA Signatures and an Application to Bitcoin Wallet Security.
In: Manulis M., Sadeghi AR., Schneider S. (eds) Applied Cryptography
and Network Security. ACNS 2016. Lecture Notes in Computer Science,
vol 9696. Springer, Cham

* [FO 97] Fujisaki E. Okamoto T.: Statistical Zero Knowledge Protocols to 
Prove Modular Polynomial Relations. CRYPTO 1997: LNCS Vol.1294, pp.16-30

* [MKR 04] MacKenzie P., Reiter M.: Two-party Generation of DSA Signatures. 
Int. J. Inf. Secur. 2004

* [GJKR 99] Gennaro R., Jarecki S., Krawczyk H., Rabin T. (1999) Secure 
Distributed Key Generation for Discrete-Log Based Cryptosystems. In: Stern J. 
(eds) Advances in Cryptology — EUROCRYPT ’99. EUROCRYPT 1999. Lecture Notes 
in Computer Science, vol 1592. Springer, Berlin, Heidelberg

* [ACS 02] Algesheimer J., Camenisch J., Shoup V. (2002) Efficient Computation 
Modulo a Shared Secret with Application to the Generation of Shared Safe-Prime 
Products. In: Yung M. (eds) Advances in Cryptology — CRYPTO 2002. CRYPTO 2002. 
Lecture Notes in Computer Science, vol 2442. Springer, Berlin, Heidelberg

* [DM 10] Damgård I., Mikkelsen G.L. (2010) Efficient, Robust and Constant-Round 
Distributed RSA Key Generation. In: Micciancio D. (eds) Theory of Cryptography. 
TCC 2010. Lecture Notes in Computer Science, vol 5978. Springer, Berlin, Heidelberg
