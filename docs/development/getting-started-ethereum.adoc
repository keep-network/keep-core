:toc: macro

= Getting started with `geth` on the test network

toc::[]

== Installation and getting set up on the test network

* Install (see https://github.com/ethereum/go-ethereum/wiki/Building-Ethereum[wiki installation instructions])
* `geth --rinkeby account new`
*** For now can use any ol’ password; this is the test network
*** Note the account address
* `geth --rpc --rinkeby --syncmode "light" console`
*** This will take a moment to start syncing (typically on the order of 30s)
*** Sync will take a bit (few minutes), require downloading about 200M
**** While you’re syncing, you can fund your address
**** Publish a post to facebook, twitter, or (my personal favorite due to complete lack of people paying attention) Google+ including your account address from above (prepended by `0x`)
**** Go to https://faucet.rinkeby.io and enter a link to your post, then request 3 (or more!) ether
**** Note that you’ll be able to reuse this post whenever you need more eth
*** You’ll have a https://github.com/ethereum/wiki/wiki/JavaScript-API[JS console] to play with
*** You can also start interacting with the https://github.com/ethereum/wiki/wiki/JSON-RPC[JSON RPC interface]
**** While the sync is happening, you can call `eth_blockNumber` to see the block number going up
* Once sync is complete, use `eth_getBalance` with `address` set to your address above to see your balance as updated by the faucet

== Starting Exercises

=== Transfer some ether

* Note that you transfer ether in wei, a denomination of ether that is equal to 1e-18 ether
** See http://ethdocs.org/en/latest/ether.html=denominations[Denominations docs]
* Set up a second account using `geth —rinkeby account new`
** Note its address
* In your `geth` console, run `personal.unlockAccount("address", "password")` where `address` is the address to your main account from above and `password` is the password you set
** This will unlock your account so that you can actually send eth from it
** If it works, the returned value will be `true`
* Use `eth_sendTransaction` with `from`, `to`, `gas` and `value` to transfer some value from your main account above to the new one you’ve just created
** Start `gas` off low (e.g. `0x100`). You should get errors about low intrinsic gas: intrinsic gas is the minimum gas needed to process a transaction
** Use `eth_estimateGas` (with the same parameters) to get an estimate of how much gas it would take to process your transaction
** Try `eth_sendTransaction` again using that amount of `gas`
* Use `eth_getBalance` with `address` set to the new account’s address to see the transfer once it’s propagated
* Use `eth_getBalance` with `address` set to your main account’s address to see the impact on your own balance
** How does the difference between this and your original balance compare to the gas you set * the gas price? You can find the current gas price using `eth_gasPrice`
*** Note: if you’re seeing small discrepancies between the balance change and what you’d expect, make sure you’re not using JS to subtract big numbers… JS engines can get confused because they treat all numbers as doubles, and inherit all the related precision issues. Try using `irb` or `python`.
** See http://ethdocs.org/en/latest/ether.html=gas-and-ether[Gas and ether docs] for a summary of this concept

=== Simple Dapp for transferring eth

* Install the solidity command-line tools
** On macOS, `brew install solidity`
* Crash course (also see http://solidity.readthedocs.io/en/develop/index.html[the solidity docs]):
** First line defines your solidity version, `pragma solidity ^0.4.0` (the version operators are the same as npm’s, here we mean `0.4.*`, roughly.
** Then you declare your contract, `contract TransferIt {`; the name is your choice
** Then you define any *state variables*: `uint private totalTransferred`
*** These default to being visible to the current contract and any that derive from it
*** `uint` = `uint256`, a 256-bit unsigned integer
*** Make a habit of declaring your state variables `private` unless you know you want them to be otherwise
*** We’ll use `totalTransferred` as a metric for the contract indicating how much total ether has been transferred through it
** Then we can define a *constuctor*, a special function that can be called once when we create a contract: `function TransferIt() public {`
*** Constructors are optional
** We can assign to a state variable in the constructor, and use this to bootstrap our state: `  totalTransferred = 0;`
*** You can inline constant initial values when declaring the state variable and skip the constructor if you prefer
** Make sure to close your braces: `}`
** Then we can define any *functions*: `function sendTo(address to) public payable {`
*** Note that the function is marked `payable`; without this, it cannot receive eth
** Functions have some implicit state and can have preconditions: `    require(msg.sender.balance > 2 * msg.value);`
*** `msg` is a reference to the message that triggered this function call (could be another contract as part of its execution)
*** `msg.sender` is the sender of the message; it is an `address`
*** `msg.value` is the ether value sent with the message (only if the function is `payable`); it is a `uint256`
*** `require` stops execution if the condition fails and wastes no additional gas
*** Here we only allow someone to send money if they have at least twice that amount in reserve
** We can also set a precondition for something we expect to always be true irrespective of caller state: `    assert(this.balance >= msg.value);`
*** `this` is a reference to the current contract; it is an `address`
*** `this.balance` is the balance prior to this call + the `msg.value`
*** `assert` costs the caller all of the gas they allocated to the call if the assertion fails
** `address` has a `transfer` function that can send ether to it: `    to.transfer(msg.value);`
*** `transfer` will halt execution if the transfer fails for whatever reason, wasting no additional gas
** We can update state variables as expected: `    totalTransferred += msg.value;`
** Don’t forget your closing `}` for the `sendTo` function, or the closing `}` for the contract!
* Compilation time
** Run `solc --gas --bin TransferIt.sol`
*** `--gas` spits out estimates for how much gas each function can consume as an upper limit
*** `--bin` spits out the binary version of the compiled contract, in hex
*** Note that the gas that is output for `sendTo` is `infinite`; this is because we’ve used a construct (`transfer`) that can potentially trigger unexpected and unbounded gas usage (through contract fallback functions, amongst other things)
*** You can isolate code that doesn’t trigger infinite estimates into its own `internal` functions for a low-performance-cost way of getting estimates on those sub-parts
** Copy the binary output
** Create the contract on the test network
*** Use `eth_estimateGas`, `from` your main account but without a `to`
**** `data` will contain the binary output from above, preceded by `0x`
*** Create the contract by using `eth_sendTransaction` with the same parameters from above + a `gas` matching the estimated gas
**** Make sure you’ve unlocked your account in `geth` using `personal.unlockAccount`
**** Note the `result` in the response: this is the transaction hash, which we can use to get a receipt for the transaction, which we can use to get the new contract’s address
*** Call `eth_getTransactionReceipt` with the `result` of the previous transaction
**** Typically `contractAddress` will contain the address of our instantiated contract
***** If we’re running in `light` mode (as suggested at the beginning of this walkthrough), the transaction receipt *won’t* have this, but your `geth` should have spit out a log message: `Submitted contract creation… fullhash=… contract=[address]`
***** `[address]` here is the address of the contract
*** Call `eth_getCode` with the contract address and `latest` to see the contract has been installed
**** Compare this output to the value you submitted in `eth_sendTransaction`; is it the same? Are all the parts in the original submission visible in the `getCode` result?
* Now that the contract exists, we can use it to transfer some eth!
** Calling a contract via RPC requires encoding a call to it in binary
** More on this encoding is in the https://solidity.readthedocs.io/en/develop/abi-spec.html[Solidity ABI specification]
** First we need to describe which contract function we’re trying to call
*** This is based on the function’s signature, as per the contract’s ABI (application binary interface)
**** The output is JSON, but what we need to do is construct a string that starts with the function name, then `(`, then the type of each of its parameters separated by `,`, then a `)`
**** We then take the SHA3 hash of this string (also referred to as Keccak after the family of crypto primitives that the SHA3 hash is built on)
*** `solc` can spit out the ABI alongside the other stuff we asked it for, if we pass `--abi` to it
**** If we look at the ABI, we see `"inputs":[{"name":"to","type":"address"}],"name":"sendTo"`. This tells us the name of the function is `sendTo` and the type of the only parameter is `address`
**** The string then is `sendTo(address)`
**** Note that not all types are equal to the ones in your solidity code; for example, `uint` in Solidity will expand to `uint256` in a function signature
**** We can use the `geth` JS console to take the `sha3` hash by running `web3.sha3("sendTo(address)")`
**** The function’s signature in binary is then the first 4 bytes (= the first 8 characters after `0x`); in this case, `0xe6d25245`
*** `solc` can also spit out the function signatures directly, using `--hashes` . That gives a block that starts with `Function signatures:` and shows the signature of each function next to its name
**** Doing this with the above will show `e6d25245: sendTo(address)`, which lines up with our work above
** Once we have the signature, we also ned to pass the function parameters (in this case, just one: the address)
*** In a function call, the signature is the top 4 bytes of the `data` sent to the contract address
*** Immediately after are the encoded parameters
*** For an `address`, that’s a hex string that represents 32 bytes (= 64 characters), padded to the left with zeroes as needed to fill that out
*** You can take your secondary account’s address, drop the `0x`, and put enough 0s before it to make it 64 characters long (e.g. mine is 40 characters, so I have to prepend 24 0s)
*** Finally, we have the full `data` segment for our call: `0x`, followed by the signature above, followed by the address parameter we constructed
** Call `eth_estimateGas` with `from` being your main account, `to` being the contract address, `value` being the amount you want to send, and `data` being the data constructed above
** Call `eth_sendTransaction` with the same parameters + `gas` set to the result of the estimate above
*** Make sure you’ve unlocked your wallet in `geth` using `personal.unlockAccount`!
** Call `eth_getTransactionReceipt` with the result from the above call
** Check the balance of your main and secondary accounts using `eth_getBalance`
*** Does it look like you lost `gas * gasPrice + value` in the main account and gained `value` in the secondary?
*** Is this more or less than what it cost to do the simple transfer from the previous section?

=== Simple event-generating Dapp

So now we have a simple Dapp that transfers eth from one address to another. We’ve seen how gas works, how contracts are created and called, how contract addresses can be sent just eth like non-contract addresses, and how they can be sent other data as well.  The last basic thing to look at is events. Events allow a contract to communicate to those watching the chain in a broadcast-esque way. Let’s make our contract from above announce the total eth it’s transferred each time it makes a transfer, along with the latest transfer that occurred.

* First, let’s declare an event after the start of our contract: ``  event Transferred(``
* On the next three lines, we’ll put our parameters:
** ``    address indexed _to``
*** Up to three parameters can be marked `indexed`. This means we can filter on them in clients that are watching for new events; however, we can’t get to the value once we’ve received an event. We can *only* filter on them—their values go into a filtering index, but they are not included with the event itself.
** ``    uint amount,``
** ``    uint totalTransferred``
* Finally, we close the event: ``  );``
** Now, let’s dispatch the event after the `totalTransferred += msg.value;` line: `Transferred(to, msg.value, totalTransferred)`
* Now let’s compile the solidity file and deploy the hex version of the compiled code
** Remember that this is a *different* contract, so we will end up with a *different* address for it than our previous one! It is *not possible* to upgrade a contract in-place. Any changes are deployed as a completely new contract, and anyone calling it who wants to use the updated version must start calling the new contract.
** We’ll run the compile command: `solc --gas --bin --hashes TransferIt.sol`
*** We should get some new hex, but the gas estimates and function signatures will be the same
** Use `eth_estimateGas` with no `to`, `from` your main account, and with data corresponding to the hash from above preceded by `0x`
** Use `eth_sendTransaction` with `gas` set to the value from the above step to create it
*** Remember to unlock your account!
** Use `eth_getTransactionReceipt` to get the transaction receipt from the returned value
*** Pull the `contractAddress` from the result
*** If you’re running a light client and the address is `null`, remember to check the `geth` log for `contract=`, followed by the contract address
* Now let’s try transacting with the new contract
** We expect this to work the same way as the previous time during a simple transaction send
** Our contract invocation will look the same, since the signature of `sendTo` didn’t actually change; the only thing that will change is the address we send the transaction to, which will update to the new contract address
** Use `eth_estimateGas` with `to` being the new contract address, `data` being the data from the previous contract invocation, `from` being your main account
** Use `eth_sendTransaction` with the above parameters + `gas` set to the value from `eth_estimateGas`
*** Remember to unlock your account!
** Use `eth_getTransactionReceipt` to get your transaction receipt based on the value from `eth_sendTransaction`
*** This receipt should look different than the other transaction receipts we’ve seen.
*** In particular, you should see the `logs` property, which has been empty until now, now contains one entry.
**** `logs` are the way that events are represented in a block
**** The log entry’s `data` corresponds to the data we put into our event
**** The log entry’s `topics` are (1) the SHA3 hash of the event’s signature (the event’s signature is assembled the same way as a function’s signature) followed by (2) for each indexed argument, either its value (if it’s a primitive) or its SHA3 hash (if it’s a string or some other more complex type whose size can exceed 4 bytes)
*** You’ll also notice `logsBloom` is not all zeros. `logsBloom` is a https://en.wikipedia.org/wiki/Bloom_filter[bloom filter] used for efficiently determining which block contains a log matching a given filter
**** Log entries aren’t necessarily stored in the block; instead, the bloom filter is used to determine if a given block has a matching entry, and then the calls in the block are re-executed locally to produce the appropriate logs
**** See the https://github.com/ethereum/yellowpaper[Ethereum yellow paper] if you want more on how the bloom filters and logs work
* Now we see how events are represented, but how do we watch for events?
** We can use the RPC API to subscribe to events by topic, and then we can make a single API call to see any recent changes that match our subscription
** To do this, we use `eth_newFilter`
*** We pass one parameter, an object, with properties:
**** `fromBlock` if specified, you can start your filter at some previous block. If left off, it is `latest`, which means we start looking as of the latest block
***** You can use `pending`  for transactions that haven’t been mined yet
**** `toBlock` if specified, you can stop watching for log entries after a certain block (this is a block number). If left off, it is `latest`, which means we keep looking at the coming blocks until we explicitly uninstall the filter.
**** `address` if specified, one or more (this can be an array) addresses of contracts that could be emitting the event. If left off, any contract can have emitted the event if it matches the topics.
**** `topics` if specified, an array of 32-byte topic hex values. If left off, any topic will be matched.
***** Note that if you specify this, you are specifying a topic match for each log entry. That is, a log entry that has two topics `[A,B]` will not match if your `topics` array here is `[B,A]`. `null` means “don’t care”, and you can omit entries after the last one you are interested in that you don’t care about. Lastly, you can have a nested array if you want an `OR` condition, e.g. `[[A,B],B]` means the first topic can be A or B, but the second topic must be B (and any subsequent topics, if they exist, can be anything).
*** Let’s call `eth_newFilter` with `address` set to our contract address and `topics` set to our event signature’s SHA3
**** We can find our event signature’s SHA3 by using the `geth` console to do: `web3.sha3("Transferred(address,uint256,uint256)")`
**** The `result` of the call is the id of our filter
*** Now we can get the changes in the filter by calling `eth_getFilterChanges`
**** We pass one parameter, the id from the result of `eth_newFilter`
**** Here, `result` will be any matching log entries. It should be empty.
*** Let’s run our last transaction to our contract again
**** Remember to unlock your account!
*** Once that transaction is mined, run `eth_getFilterChanges` again
**** Now, we should have one entry in the results. That entry should have a `data` property. That `data` is the data we passed the event (with the exception of the indexed parameter).
*** Try running `eth_getFilterChanges` again; you’ll find you get an empty result. `eth_getFilterChanges` gives you any matching logs since the last time you ran it, or since the filter was created.
*** If you want to run a log query without being able to use `eth_getFilterChanges` for polling (i.e., as a one-time thing in a range of blocks), you can use `eth_getLogs` with the same parameters you pass to `eth_newFilter`

== KEEP contracts

To be written…
