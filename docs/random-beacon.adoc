:toc: macro

= The Keep Random Beacon: An Implementation of a Threshold Relay

toc::[]

[abstract]
.Abstract
--
The Keep Network requires a trusted source of randomness for the process of
trustless group election. While the network requires that randomness to function
correctly, the source of randomness is itself broadly applicable. This trusted
source of randomness takes the form of a BLS Threshold Relay. We discuss
implementation of this random beacon, including assumptions and mitigations for
bad actors and poor network connectivity.
--


== Overview

 - Goals
 - Organization (core tech, state flow, incentives, ...)
 - Assumptions
 - High-level description

The threshold relay described in this paper is a way of generating verifiable
randomness that is resistant to bad players both in the relay network and on the
anchoring blockchain, assumed here to be Ethereum. The basic functioning of the
relay (further details are in the section on <<System Details>>) is:

 - Some number of groups exist in the relay.
 - An arbitrary seed value `v_s` counts as the first entry in the relay.footnote:[The
   importance, from a security perspective, of the seed value goes away almost
   immediately in a functioning network.]
 - A request `r_i` is dispatched to the chain for a new entry.
 - Information about the request is combined with the previous entry to produce
   a new relay entry seed value `v_r`.
 - `v_r` is used to choose a group to produce the response to the request.
 - `v_r` is signed by at least a subset of the chosen group members, and the
   resulting signature is the entry generated in response to the request. It is
   published to the anchoring blockchain as the entry `v_i`.

The following sections will detail how this basic function is implemented in
practice, including notes on <<Prior Work>> that motivated this design,
the <<Incentive Structures>> used to economically incentivize good behavior by
network participants, <<Core Technologies>> used in the network, and finally the
<<System Details>> that outline the implementation itself. <<Upgrade Management>>
is also discussed.

.Keep Threshold Relay
image::img/generated/relay-diagram.png[Diagram of the Keep threshold relay]

== Prior Work

Dfinity has described their implementation of a random beacon backed by a
threshold relay in their consensus whitepaper
footnote:[https://dfinity.org/pdf-viewer/library/dfinity-consensus.pdf]. The
relay described in this paper is heavily based on the one devised by the Dfinity
team, with certain adjustments for implementation on an existing blockchain. The
key distinction between the Dfinity implementation and the Keep implementation
is that Keep has to contend with blockchains that do not implement the same
primitives as the in-house Dfinity chain targeted in their paper. Concerns such
as transaction costs and payment for beacon entries are therefore a core part of
the incentive system built around the Keep random beacon.

As described in the above paper, at the heart of the relay beacon is the
signature scheme described by Dan Boneh, Ben Lynn, and Hovav Shacham in
footnote:[D. Boneh, B. Lynn and H. Shacham, “Short signatures from the Weil
pairing”, Advances in Cryptology – ASIACRYPT 2001, Lecture Notes in Computer
Science, 2248 (2001), 514–532. Full version: Journal of Cryptology, 17 (2004),
297–319.], termed BLS. Three properties of the scheme are of particular use in
this case: BLS signatures can be used in _threshold_ mode, where _k_ of _n_
participants are sufficient to produce a combined signature; BLS threshold
signatures produce the same final signature irrespective of the participants;
and BLS signatures are typically shorter than those of many other threshold
signature schemes.

Finally, underpinning the process of generating new groups for BLS threshold
signatures in the system is a distributed key generation algorithm based on work
by Gennaro, Jarecki, Krawczyk, and Rabin footnote:[R. Gennaro, S. Jarecki, H.
Krawczyk, and T. Rabin. Advances in Cryptology — EUROCRYPT ’99: International
Conference on the Theory and Application of Cryptographic Techniques Prague,
Czech Republic, May 2–6, 1999 Proceedings, chapter Secure Distributed Key
Generation for Discrete-Log Based Cryptosystems, pages 295–310. Springer Berlin
Heidelberg, Berlin, Heidelberg, 1999 ;
http://groups.csail.mit.edu/cis/pubs/stasio/vss.ps.gz], as also described in the
Dfinity paper above. The Keep relay beacon publishes group public keys to the
anchoring blockchain and does member selection on-chain, but key generation
occurs between nodes.

== Core Technologies

=== Dependency Management?

- Repo pinning
- Commit-hash-based dependencies

=== Networking

- libp2p
- multiaddr
- floodsub?

=== Messaging

- protobuf
- sig/encryption libs for messages

=== Ethereum

- JSON-RPC

=== BLS Implementation

- bn
- go-dfinity-crypto

== System States

 - State diagrams
 - Details of node state, system state, chain state

== Mechanical Attack Mitigations

The Keep threshold relay is designed to mitigate as many instances of malicious
behavior as possible, as well as to encourage stakers to employ well-networked
and highly available systems for their clients. This is done in two parts:
choosing robust technical implementations (like threshold signatures) that are
resilient to high degrees of misbehavior and network failure, and calibrating
the incentive structure to ensure strong punishments for malicious actions. We
discuss several potential attacks that are mitigated via adjustments to the
mechanics of the system here.

=== Miner, Requestor, and Relay Influence

Let us remember that the most basic construction (discussed in the <<Overview>>)
of a request-based threshold relay uses the previous value mod the number of
active groups to determine the next group. This next group then signs the
previous value to produce the next value. This happens every time a relay entry
(that is, a random number) is requested. There are a few key problems that
manifest in this simple construction:

 - The relay can collude to know random numbers an infinite number of steps
   ahead of the requests.
 - Miners who have compromised a group can collude to censor a request until the
   previous entry would select a group they control.
 - Miners who have compromised a group can collude to censor a request that
   would select the group they control if they know the outcome would not be to
   their advantage.
 - A requestor who has compromised a group can wait to put a request in until
   the previous entry would select a group they control.
 - A requestor who has comporomised a group can wait to put a request in if it
   would select the group they control and the outcome would not be to their
   advantage.

We address each of these below. We assume here that controlling one group is
expensive, and controlling all groups is prohibitively so; see the section on
<<Incentives>> for more on what that requires.

==== Relay Frontrunning

One of the disadvantages of the simple construction above is that future entries
can be computed in advance of their use. For example, if it were known that a
lottery was being held in _N_ blocks, the relay could collude to run ahead that
number of entries so as to have the relay's value before the entry came due. The
Keep implementation of the relay mitigates this by using information about the
request to adjust the previous entry before signing it, effectively anchoring
the relay to the request and therefore to the parent chain. In particular, the
relay provides the requestor the ability to specify a _seed_, which is
concatenated with the previous entry to allow the requestor to mitigate against
miner misbehavior.

NOTE: The seed itself must be unpredictable to the relay, or the relay could
still frontrun with the above mitigation; however, the mitigations for miner
censorship below further limits the ability to frontrun.

==== Miner Censorship

Miners can choose not to include a transaction that does not benefit them. For
example, if a given relay request comes in for a lottery the miner is also
participating in, and the group that will be selected is under their control and
they can determine the next entry would not be favorable to them, the miner
could censor the transaction and effectively get a second chance at winning the
lottery.

The frontrunning mitigation in the previous section in particular has a
potential miner censorship downside. Say a requester submits a request with
seed `A`. The miner who mines the block with that request will, while mining the
block, be able to know the relay input. If the miner can know that the selected
group will be one the miner controls, and with relay input in hand, the miner
could decide to not minethe transaction because they know their group's output
for the input will not be beneficial to them.

To mitigate this, the seed is provided in commit-reveal fashion. The original
request contains a hash of the (seed value + hash of requester account pubkey).
This block decides which group is chosen. The requester then submits a second
transaction within 2 blocks that reveals the seed value. This reveal (assuming
it verifies against the commited value) triggers the relay group's signature
process.

NOTE: A miner could still choose to censor any transaction if the previous relay
entry would select a group that they don't control. However, this approach does
not have a provable upside, since you are giving up potential transactions
blindly, without knowing if choosing your group would have been beneficial
anyway.

==== Requestor Cheating

The last player in the set of actors involved in a relay interaction is the
requestor. The requestor is given the ability to add entropy to their request by
providing a seed to make the signing value less predictable. However, this also
gives the requestor the potential to influence the final outcome.

So why go forward 2 blocks for group selection instead of looking at a previous
block? If the group selection were based on a prior block, a requestor would
always be able to know which group their request would go to. Since the
requestor specifies a seed that influences the value signed by the selected
group, the requestor could wait to submit a request until they knew the signing
group would be the group the requestor controls. Thus, by mixing in the miner
censorship mitigation, which makes the signing group unpredictable until after
the request is made, we also reduce the requestor's ability to know who the
signing group will be at request time.

=== Denial of Service

Denial of service attacks can occur at both the network and/or at the protocol
level. The network and specifically the signing protocol are resilient to
griefing from malicious nodes (m) if, given a threshold (t) and group (n),

===
m ≤ n - t and t ∈ [m+1, n-m]
===

Hence our mitigations are focused on ensuring the above properties hold for all
groups through proper implementation and advisory at the network level along with
decisions and incentives at the protocol (relay operation) level.

==== Network

Specific to this section, we will refer to “relay clients”, “group members” as
peers.

The relay beacon leverages https://github.com/libp2p[libp2p] and the associated
gossip sub implementation in https://github.com/libp2p/go-floodsub[go-floodsub].

Of note, we rely on the pubsub implementation to handle the case where a message
gets lost (through retrying). At the implementation layer, we take care to
differentiate between a lost/missed message and a non-participating group member
through deadlines and a capped number of retries.

Furthermore, the relay implementation relies on the Go standard library
(ie.https://golang.org/pkg/net/http/[net/http]). Through using these
implementations, we discuss the possible network-level attacks:

===== Traffic Amplification

Without Topic-level authentication it's trivial for a given malicious actor
to enter a given group (by identifying it from the group registry on chain),
and to target and flood an indiviudal in the group with large and useless
messages. This results in the peer rebroadcasting these messages to their
peers, and their peers, etc. This results in flooding the network, eventually
stalling progress, causing members to potentially abort the protocol.

Mitigations:

  - Topic names (refered to as broadcast channels) are hashed and concatenated
  public keys, specifically the public keys of all valid group members. Each
  valid message is then signed with the associated private key of a group member.
  This can be trivially verified with the supplied proofs (through the
  destructuring of the broadcast channel name, identifying the public key
  associated with the message, verifying the message against the signature).
  All other messages are dropped by the members of the broadcast channel.

  - Valid group members that are attempting traffic amplification attacks will be
  identified by their proofs. Malformed messages, or failing to provide valid
  values, for a phase of either distributed key generation (group creation) or
  the signing phase will result in an honest group member accusing the malicious
  group member. A valid accusation results in the malicious group member's stake
  being slashed. See the section on <<Accusations>> for more.
  
===== Message Silencing

Another possible attack involves silencing messages from an honest actor (by
crafting messages with conflicting ids on behalf of an honest actor, or simply
dropping messages from an honest actor), but the relay combats message silencing
through:

  1. being threshold-based, where t of n shares are required to provide a
  successful result.
  2. we enforce that messages are signed by their authors so a malicious actor
  should have no means to construct a message with a conflicting id/version.

  TODO: revisit this scheme, we potentially need more here.


===== Slow Down (slowloris), resource exhaustion, etc.

We configure clients such that we limit the number of connections a
single IP address is allowed to make, impose restrictions on the minimum transfer
speed a connection is allowed to have, and restrict the length of time a
client is allowed to stay connected. Concretely, this is done through:

  1.Setting http://golang.org/pkg/net/http/#Server[Server.ReadTimeout]. These are
  deadlines that apply to each request.
  2. Configuring the transport's max number of idle connections / per host
  3. Configuring the underlying ConnState.
  TODO: address https://github.com/keep-network/keep-core/pull/68#discussion_r181217303

At a network level, we recommend that ingress and egress are limited to the ports
required to communicate over libp2p, sync with ethereum, and optionally, to
exchange debug information with us. On release, Keep will provide advised
settings for operators.

===== Bot net, macro network attacks

At a macro level, we defend against attacks on the network through enforcing Keep
providers to prove their holdings by staking KEEP. Significant disruption of the
network should lead to a drop in the value of the token, incentivizing provider
honesty, lest they devalue their holdings. It's in the providers best interests
to ensure the network is stable and to report malicious or poor performing actors.

==== Relay Aborts

Denial of service attacks are a problem in two phases of the relay's operation:
group formation and relay response generation. The relay itself can also be DoSed
by too many requests. The first two in particular share the requirement that
either a player outside or inside the relay be able to know enough about the
clients in a group to launch DoS attacks against them.

.Variables
[.variables,table,header,cols="l,n"]
|=========
| Variable | Meaning

| r_t      | Transaction submitter reward
| r_g      | Relay group submission reward
| g        | Members in a group
| E        | Invalid signature punishment for the submitter
| M        | Minimum stake amount (in KEEP)
| P        | Aborted group sig punishment
| f        | Function that executes punishment for aborting group sig
|=========

TODO:
r_g/g is the share of the group reward any member receives

p ∈ [-1, 1] is a real number between -1 and 1, representing a multiplicitive
factor of loss to be applied to r_g as time passes between the relay request and
next block, such that f = p * r_g, where f is the realized group reward.


tx rewards should grow as blockheight grows, group rewards should shrink until
an abort is identified (when they go negative)


===== Group Creation

Currently an attributable Distributed Key Generation algorithm does not exist.
For example, consider the a potential attack where a lazy/malicious actor fails
to provide shares or provides malformed shares to the group. In this case, group
members would provide proofs of maliciousness during the accusation phase of DKG.

A malicious actor with approximately [malicious_node_distribution] nodes
distributed amongst all potential groups can abort the Distributed Key Generation
process which would DoS not only new group creation, but also prevent new relay
entries from being formed, causing relay operation to increasingly become delayed
(missing the block wait time), approaching the limit.

TODO: flesh out more

===== Signing Group

TODO: Aborts which are attributable will be slashed. 


== Incentives

The Keep threshold relay is designed to minimize the amount of trust that needs
to be placed in any individual node in the system. As much as possible, the
mechanics of the relay themselves prevent inappropriate manipulation of the
system, but this can only take us so far, since the individual nodes are run by
unvetted participants. To deal with this, the staking, rewards, and punishment
systems must make honest participation the most lucrative behavior, and make
dishonest behavior as undesirable as possible.

=== Stakes

To participatein the relay, a node must be associated with an account that has
staked a minimum amount of its KEEP. footnote:[The mechanics of discovering and
updating minimum stakes are discussed in the <<System Details>> section.] Note
also that unstaking KEEP intentionally takes an extended period of time (on the
order of weeks). This discourages attacks that will reduce the value of the KEEP
token by leaving the attacker at greater risk of exposure and therefore slashing
of their stake, as well ensuring the staker would themselves incur the reduction
in value of their stake.

The minimum stake is carefully calibrated to be accessible for early network
participants, while still being sufficiently large to present a meaningful
punishment if it is slashed for a misbehaving node. To understand the driving
considerations of the minimum stake value and the intended punishments, we need
to look at the probabilities of various scenarios and their relationships to the
staking values.

To this end, let us refer to the minimum staking amount as `M`, the number of
members in a group as `g`, and the number of groups in the relay as `G`. The
cost `o` of "owning" one single group, meaning the cost of being able to predict
or control its output or key generation and therefore its results, is `t x M`.
`t` here is the threshold, `g / 2 - 1`, and `g` is the number of members in a
group. Owning one group is not necessarily sufficient to be in control of
anything, since the relay is designed to make the next group unpredictable until
it is time to compute the next random number. Additionally, just controlling `t`
stakers is not enough to control a group, since new groups are formed from a
random selection of available stakers.

.Variables
[.variables,table,header,cols="l,n"]
|=========
| Variable | Meaning

| C        | Number of stakers in the network
| G        | Number of groups in the threshold relay
| g        | Number of stakers in a single group
| M        | Minimum stake amount (in KEEP)
|=========

.Derived Variables
[.derived-variables,table,header,cols="l,l,n"]
|=========
| Variable | Defined Value | Meaning

| t        | g / 2 - 1     | Number of stakers needed to control a single group
| o        | t x M         | Amount at stake if one entity owns a single group
|=========

From this information, we can start deriving the probabilities that any given
scenario may occur. Many of these probabilities require the hypergeometric
distribution, which we'll refer to as ``hgeo(N, K, n, k)``footnote:[
`hgeo(N, K, n, k) = choose(K, k) * choose(N - K, n - k) / choose(N, n)`
represents the probability of choosing `k` items with a particular property from
a set of `N` items where `K` of them have that property, after `n` attempts,
where `choose` is the binomial coefficient function,.]. The probabilities we're
most interested in are in the following table:

.System Probabilities
[.probabilities,table,header,cols="h,l"]
|=========
| Aspect | Probability

| A given staker being chosen for a new group
| hgeo(C, 1, g, 1)

| An entity controlling `D` stakers having `t` of those chosen for a new group
| hgeo(C, D, g, t)

| An entity controlling `D` stakers while `N` new groups are created, ending up
  with control over one group
| 1 - ((1 - hgeo(C, D, g, t)) ** N)
// ** Unclear: how do we generalize to probability of controlling >1 group?

| A given group being chosen to create the next relay entry
| 1 / G

| An entity controlling `D` stakers while `N` new groups are created, ending up
  with their group chosen to create the next relay entry
| (1 - ((1 - hgeo(C, D, g, t)) ** N)) / (G + N)
// ** This doesn't take into account over time yet, it's just at the end of N.
|=========

=== Punishments

When designing incentives, we have to consider the distinction between wilfful
misbehavior and accidental misbehavior. In particular, the system should be
structured so as to tolerate some amount of network jitter for a given node,
while not allowing for a group to fail to produce a signature when it is
requested. The key observation here is that what matters is that the network be
able to respond to any request for a random number in a timely fashion. This
means, given the threshold nature of the signature mechanism, that we must
ensure at least half of a given group's nodes are available at any given moment.

Moreover, we must ensure that freeloaders are penalized. This means that a node
should not be capable of joining a relay group and then never do the work to
sign a request.

 - Mitigations to attacks based on incentives
 - Cost of owning a group
 - Cost of owning a majority of groups

== Upgrade Management

- Upgrading nodes
- Upgrading relay configuration
- Upgrading relay contracts
- Upgrade coordination/process

== System Details

The minimum stake required for participation in the relay is configured on
chain, and can be discovered by querying the `KeepRelayBeacon` contract for the
`minimumStake()`. Changes to the minimum stake are broadcast as
`MinimumStakeChanged(uint256 old, uint256 new)` events from the same contract.
The frequency with which the minimum stake will be updated is currently
unspecified, but we expect such a change to be equivalent to a hard-fork in
terms of importance.

- DKG process + messages exchanged (specific format in an appendix?)
- Threshold signature process + messages exchanged (specific format in an appendix?)
- On-chain call structure (appendix?)
- On-chain event structure (appendix?)

== Acknowledgements

- Dfinity
- Advisors

include::glossary.adoc[]
