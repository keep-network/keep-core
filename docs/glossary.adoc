== Glossary

Stake:: An amount of KEEP that is bonded in order to participate in the
  threshold relay and, optionally, the Keep network. Part or all of this can be
  removed from escrow as penalties for misbehavior, while part or all of it can
  be refunded if and when a participant chooses to withdraw in orderly fashion
  from the network and relay.

Staker:: A staking client that has a stake, but may not yet be in a signing
  group.

Minimum Stake Amount:: The minimum stake amount that will make a staking client
  a staker, as required by the staking smart contract.

Stake Amount:: Total KEEP deposited for a single stake.

Signing Member:: One member of one complete signing group in the threshold
  relay.

Signing Group:: One complete signing group in the threshold relay.

Lead Signing Group:: The signing group that will produce the next relay entry
  candidate (due to being the result of $E_i mod N$ with $E_i$ being the
  current entry and $N$ being the number of groups). If this group fails to
  respond to the request in time, the lead responsibility may shift to another
  group.

Relay Entry Candidate:: A random number generated by the threshold relay that
  has not yet been finalized on the blockchain; may be invalid.

Relay Entry:: A relay entry candidate that has been finalized on the blockchain;
  may be invalid.

Keep Client:: The entire application running on a user's system, which contains
  multiple subclients for the various pieces of the Keep system.

Staking Client:: The part of the Keep Client that stakes and participates in the
  threshold relay.

Verifying Client:: Verifies entries on-chain and reports invalid entries.
  Optional, does not require a stake. Reward for identifying an invalid random
  number on the chain.

Provider Client:: The Keep Provider piece of the application, which can in turn
  have workers for various Keep types.

Keep Type:: The functionality that the given Keep relies on for providing
  security. e.g. an SHM (Secure Hardware Module) Keep, SMPC (Secure Multi-Party
  Computation) Keep, Proxy Reencryption Keep, etc.

Provider Worker:: One worker that runs the code to allow a provider client to
  participate in a given Keep Type.

Keep Provider:: One economic entity in the Keep network; has a stake, must
  participate in a signing group as a single member.

Keep:: Up to 1MB of encrypted storage across one or more Keep Providers.

KEEP:: Token used to stake. Can be represented as a K with a vertical bar
  through it.

Keep Owner, Delegate, Requester are described in the whitepaper.

=== Verbs

The network *assigns* one *seat* of one *keep* to a *keep provider*.

One *keep provider* can only be assigned one *seat* for any given *keep*.

One *keep* has 1 or more *seats*, which correspond to unique *keep providers*.

One *staker* becomes a *signing member* on the threshold relay when the *signing
group* they are a member of is *complete*.

One *signing group* is *activated* once it is *complete* (meaning, it has a
number of stakers assigned to it equal to the *signing group size*),
*initialized* (meaning, the stakers have generated their key shares and the
group has a public key registered), and the *activation delay* has elapsed.

=== Relationships

A greater *stake amount* leads to a greater probability of being *assigned* a
*keep*.

A greater number of *seats* costs more *native token* over time.

The *threshold relay* generates one or more new *relay entry candidates* on
request. One block on the chain can contain one or more requests for new relay
entries.

The pending *relay entry candidates* are finalized on the chain into *relay
entries*.

=== Paying

The Threshold Relay needs to be sustainable on its own.

Hypothesis: we can adjust our incentive and threshold signing structure to make
new numbers only appear when requested. We can then charge for requesting a new
number.

Strategy: rather than signing just the previous number with the next threshold
group, sign a combination of the blockchain block hash and the previous random
number. Which block is an open question. A number is not valid if it has not
been requested, meaning the block hash that is used has to be related to the
requesting block somehow.

TBD: How do we combine the block hash with the random number in a way that
is attack-resistant and maintains the same distribution guarantee of signing
the previous random number?