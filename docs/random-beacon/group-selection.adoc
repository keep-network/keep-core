:toc: macro

= Random Beacon Group Selection

ifndef::yellowpaper[toc::[]]

The group selection protocol is intended to be
an interactive method of selecting candidate group _P_
from the set of all stakers _S_
given a pseudorandom seed value _V~i~_.

Functional interface:

inputs: _S, V~i~_

output: _P_

The protocol should:

. [[req-1]]produce a representative result, where each staker's profit is proportional
to the number of tokens they have staked
. [[req-2]]produce a group _P_ of constant size _N_
. [[req-3]]not require an excessive amount of on-chain operations to perform
. [[req-4]]not be feasible for an adversary to manipulate
. [[req-5]]be compatible with future measures to make stakers indistinguishable

.Some terms
|===
|Term |Meaning

|Trenchcoating
|Several actors pooling up their stakes under one staker identity
to take advantage of rich-get-richer effects.
Thus what seems to be a large staker is actually
"a hundred small stakers in a trenchcoat".

|Blitzpantsing
|The inverse of trenchcoating; a single token holder dividing their stake
under multiple identities to avoid rich-get-poorer effects or to increase their
representation in groups.
This can increase profits above what is designed, or make certain attacks easier
to perform by making one actor more likely to control a group.
Thus what seems to be a large number of small stakers is actually a single
whale in an "inverse trenchcoat", or "blitzpants".

|Non-interactive
|A protocol is non-interactive if it can be performed without stakers
providing additional information.
Specifically, _S~i~_ can determine whether they are in _P_
without input from other stakers in _S_.

|Interactive
|An interactive protocol requires stakers to provide additional information
over what is available on-chain,
and then performs a deterministic algorithm to select a group
based on the information provided by the stakers.
In an interactive protocol _S~i~_ cannot know for sure
whether they are in _P_ before they receive the other stakers' input.

|Actual staker
|An actor holding and staking at least _MINIMUM_STAKE_ tokens,
represented as _S~i~_.
Each actual staker corresponds to one or more virtual stakers.
An actual staker can be represented multiple times in a candidate group,
through multiple virtual stakers.
The surplus tokens above _n * MINIMUM_STAKE_ (for an integer _n_)
do not impact the actual staker's ability to create virtual stakers.

|Virtual staker
|A construct used to simplify
the mathematical requirements of the group selection protocol
and ensure blitzpantsing provides no advantage.

Each virtual staker represents exactly _MINIMUM_STAKE_ tokens
staked by some actual staker who may or may not be anonymous.
A virtual staker may only ever be included once in a candidate group,
and _N_ properly denotes the number of virtual stakers in _P_.

|Ticket
|A message containing a pseudorandomly generated value _W~k~_ which is used to 
 determine whether a given _virtual staker_ is eligible for the group _P_ (the
 lowest _N_ tickets will be chosen) and a proof of the validity of the value

|Threshold
|The value of the highest-valued ticket in _P_

|_Space~tickets~_
|Is a space consisting of all possible tickets. It is strongly related
with a pseudo random function that is used for ticket generation.
Currently the _Space~tickets~_ is equal to _2^256^- 1_, which is due
to selection of SHA3-256 as our pseudo random function.

|Natural threshold
|_Threshold~nat~ = floor(N * Space~tickets~ / (Tokens~total~ / MINIMUM_STAKE))_

In other words, the natural threshold is the value _N_ virtual stakers' tickets
would be expected to fall below if the tokens were optimally staked, and the
tickets' values were evenly distributed in the domain of the pseudorandom
function.

Usually _Threshold~P~ > Threshold~nat~_ as not all tokens will be staked and the
distribution of stakes will not be optimal.

_Tokens~total~_ is used instead of _Stake~total~_ to make it possible to later
hide the stakes of individual stakers; otherwise the staking or unstaking of
tokens would reveal the amount through the update to _Stake~total~_.
|===

== Setup

When a staker _S~j~_ is created, the following values are determined:

- _Stake~j~_: the amount of tokens staked by _S~j~_ and thus locked up until the
  staker is destroyed 
- _Weight~j~= floor(Stake~j~ / MINIMUM_STAKE)_: the staking weight of _S~j~_;
  how many virtual stakers can represent _S~j~_ 
- _Q~j~_: a staker-specific value used as an input to the pseudorandom function

The staker creation operation needs to include a proof of the correctness of the
above values.

Currently the _Stake~j~_ and _Weight~j~_ can be public and _Q~j~_ can be the 
ECDSA pubkey of _S~j~_. Future work towards indistinguishable staking would make
_Stake~j~_ and _Weight~j~_ values private and enable their verification via
zero-knowledge proofs.

== Protocol

A new output _V~i~_ is generated by the random beacon. This triggers the
selection of a new candidate group.

=== Phase 1: ticket calculation

_S~j~_ calculates _Ticket~k~ = (W~k~, proof~k~)_  containing the value
_W~k~ = prf(V~i~, Q~j~, vs)_ and proof that:

- the ticket value _W~k~_ is created correctly
- the staker-specific values _Q~j~, Weight~j~_ correspond to _S~j~_ in _S_
- the virtual staker number _vs_ is within the range _1 <= vs <= Weight~j~_

=== Phase 2: ticket submission

==== Phase 2a: initial ticket submission

Each staker whose _W~k~ < Threshold~nat~_ on one or more _Ticket~k~_ publishes
the ticket/s.

The smart contract function `cheapCheck` is used to do basic inexpensive
on-chain validation of the tickets as they are received. Invalid tickets are
rejected and their senders penalized.

Phase 2a ends when _TICKET_INITIAL_TIMEOUT_ is reached.

==== Phase 2b: reactive ticket submission

If the number of tickets received in phase 2a is less than _N_, the stakers
whose tickets did not fall below the natural threshold will publish theirs.

Tickets should ideally be published in order, to reduce the costs of ticket
submission on the stakers. For this, it is recommended that tickets where
_W~k~ = x * Threshold~nat~_ be submitted at time _x * TICKET_INITIAL_TIMEOUT_,
IFF the number of tickets below _W~k~_ is less than _N_.

When tickets are published in order, the number of unnecessary transactions can
be minimized, which benefits the stakers. Thus it would be in each staker's
interests to follow the regular order. This, however, is only a recommendation
and tickets submitted at different times should not be rejected.

Phase 2b ends when _TICKET_SUBMISSION_TIMEOUT_ is reached.

=== Phase 3: ticket verification

Each staker should verify the proofs supplied with each ticket. If a ticket
doesn't pass `costlyCheck`, the staker should raise a challenge to that ticket.

When a ticket is challenged, on-chain will perform `costlyCheck` on the
challenged ticket, performing whatever verification is necessary on the proof.
If the ticket fails `costlyCheck`, the staker who originally submitted the
ticket will be penalized. If the ticket passes `costlyCheck` the staker who
presented the invalid challenge will be penalized.

Phase 3 ends when _TICKET_CHALLENGE_TIMEOUT_ is reached. Challenges may also be
presented during phase 2. 

=== Phase 4: threshold determination

After all potentially eligible tickets have been submitted and challenges
resolved, the _N_ tickets with the lowest values for _W~k~_ will be selected
into the group _P_. The corresponding virtual stakers will be automatically
assigned to form the group and no further interaction is necessary. DKG will be
performed.

== Notes and rationale:

=== Virtual stakers

Due to the use of virtual stakers, the stakers will be expected to be
represented in _P_ with a probability proportional to their _Weight~j~_; a
staker staking at least _2 * MINIMUM_STAKE_ may also be selected multiple times
for the same group.

This makes the result representative and ensures that neither blitzpantsing nor
trenchcoating will provide the staker greater profits than they could acquire
otherwise (<<req-1,requirement 1>>), with the exception that pooling token
amounts below _MINIMUM_STAKE_ and sharing the risk and profits would enable the
utilization of smaller holders' tokens or surplus tokens from regular stakers.
This form of trenchcoating is arguably either neutral or beneficial, and in any
case it does not violate proportionality of rewards.

Additionally, using virtual stakers and tickets instead of eg. a threshold that
adjusts itself based on the staked amount lets us hide any particular staker's
identity and the size of their stake later (<<req-5,requirement 5>>).

=== Interactive protocol

There would be two simple non-interactive options but neither is able to
satisfy all of the requirements:

1. One method would be to have each _S~j~_ calculate a pseudorandom value
_Seed~j~_, and then everybody whose _Seed~j~ < Threshold~i~_ is in _P_.
_Threshold~i~_ would be calculated using public information,
eg. by _Threshold~i~ = floor(N * Space~tickets~ / |S|)_ for a 256-bit _Seed~j~_.
However, this means that due to random chance, most of the time _|P| != N_.
This violates <<req-2,requirement 2>>.
2. Alternatively each staker could present  some kind of a hashed value
_Hash~j~_ so that whether _S~j~_ is in _P_ can be determined publicly
by _f(V~i~, Hash~j~, S, N) -> Bool_.
This cannot work, because then anybody could
calculate _f(V~m~, Hash~j~, S, N)_ for a large number of different values _V~m~_
and see how often _S~j~_ ends up eligible for the candidate group.
Due to <<req-1,requirement 1>> this necessarily reveals how much _S~j~_ has staked
to an arbitrary degree of precision, violating <<req-5,requirement 5>>.

These constraints seem inherent in the problem, and thus an interactive protocol
appears necessary. The aforementioned issues can be avoided by having _S~j~_
calculate a value _W~j~_, so that _S~j~_ will be in _P_ if _Threshold~P~ > W~j~_.

[source, python]
----
all_tickets = []
for S_j in S:
    for vs in [1..Weight_j]:
        W_k = prf(V_i, Q_j, vs)
        all_tickets.append(Ticket(W_k, proof(W_k))

Threshold_P = max(all_tickets.map(fn(t): t.W_k).sort().take(N)
----

Assuming once again 256-bit values for _W~k~_ and _Threshold~P~_,
_S~j~_ can predict their expected probability of being in _P_
by calculating how likely it would be that _Threshold~P~ > W~k~_.
Then _S~j~_ can broadcast their input only if there seems to be
a realistic chance that they could be selected.
If it seems likely that _Threshold~P~ < W~k~_,
_S~j~_ can refrain from broadcasting _W~k~_ and only monitor the situation,
reacting if it seems that few stakers' ticket values are falling under
the estimated threshold.

=== Zero-knowledge proofs

The protocol has been designed to be easily compatible with zero-knowledge
proofs later (<<req-5,requirement 5>>). The weights and virtual staker indices
can use range proofs, and _Q~j~_ is required to be simply a value unique to any
given staker.

Initially _Q~j~_ can be something public and easy to verify, such as the ECDSA
pubkey of _S~j~_, but the design of the protocol should be flexible later.

Similarly, the protocol specifies a pseudorandom function `prf`; `sha3` can be used
before staker indistinguishability is required, but any function with the right
qualities can be easily substituted.

Tickets are checked on-chain in two stages: `cheapCheck` does surface-level
validation of factors that are easy to check, while `costlyCheck` performs a
full verification of the supplied proof only if the ticket is challenged. This
means that the on-chain protocol should not be too constrained by the cost of
ZKP verification later on, as verification can only be performed when necessary.
Rational adversaries will not present invalid tickets due to the penalties.

== Alternative off-chain protocol

This protocol was not chosen but is included in the yellowpaper to illustrate
reasoning and what alternatives were considered

=== Protocol

Each staker calculates their tickets

Each staker who has one or more ticket/s that may be eligible for the group
broadcasts the ticket, including proof of its validity

Other stakers check broadcasted tickets for validity; if an invalid ticket is
broadcast, the ticket is rejected

After _T~selection~_ has elapsed, stakers following the broadcast channel
select _N_ tickets with the lowest value to form the candidate group

Each member of the candidate group BLS-signs a message
containing all the tickets of the group and the threshold

This is the _Group Formation Message_, signed by _[P~1~..P~N~]_ to ensure the
integrity of the group selection process. Because all participants are required
to sign the _Group Formation Message_, the group composition cannot be
manipulated later.

The members of _P_ perform DKG; at the end of DKG the final message contains:

- DKG output, similarly BLS signed
- group formation message
- aggregate BLS signature of the above

On-chain receives DKG conclusion message, and:

- checks that all stakers in the group formation message are valid
- checks the proofs supplied in the tickets
- checks that all tickets are below the threshold
- checks that the group formation message is signed by everyone in _P_
and that the DKG output is signed by at least _H_ members of _P_

If two or more valid group formations are presented,
the one with the lowest threshold wins

Any virtual staker is only permitted to sign a group formation message for one
group (any given ticket may only be used for one group); if a ticket is used for
two or more different groups, the staker should be penalized

Submitting only a group formation message without DKG conclusion is also valid
and signifies that the group was formed, but DKG did not reach quorum (_H_
participants would not agree on any given result)

However, if a group formation message is published it may be superseded by a
valid DKG conclusion message for the same group

If a member of group _P_ with _Threshold~P~_ publishes a valid group formation
message, and a member of group _P'_ with _Threshold~P'~_ publishes a valid group
formation and DKG conclusion message:

- if _P âˆ© P' != {}_, the stakers who signed both group formation messages should
  be penalized, but the groups _P_ and _P'_ may still be valid (this is to
  prevent an attack where one member of an unfavorable group prevents the group
  creation by signing and publishing a different, unrelated group creation message)
- if _Threshold~P~ > Threshold~P'~_, group _P'_ is to be considered the correct
  group and the group selection is to be deemed a success.
- if _Threshold~P~ < Threshold~P'~_, group _P_ is to be considered the correct
  group and the group selection is to be deemed a failure.
- if _Threshold~P~ = Threshold~P'~_, group _P'_ is to be considered the correct group


=== Notes

The BLS signatures should probably be verified with the protocol in
https://crypto.stanford.edu/~dabo/pubs/papers/BLSmultisig.html and Bulletproofs
would likely be used for the ZKP element after the introduction of staker
indistinguishability

The off-chain protocol is much more complex to secure effectively, and a variety
of attacks on the group composition need to be addressed.
