:toc: macro

= Random Beacon Distributed Key Generation

:toclevels: 4

This proposal for Distributed Key Generation for the threshold relay
is based on a protocol by Gennaro, Jarecki, Krawczyk and Rabin <<GJKR>>.
GJKR is further based on Pedersen-VSS (verifiable secret sharing) <<Ped>>.
For this implementation, GJKR has been modified
to make protocol violations objectively attributable
and remove the need for one-to-one messaging channels.

The protocol uses ephemeral ECDH keys
to encrypt one-to-one communication on the broadcast channel.
This ensures that participants can neither
make baseless complaints nor
cause a minor nuisance with subtle misbehavior.

Additionally, the threshold relay public key submission protocol
is defined.

ifndef::yellowpaper[toc::[]]

include::dkg-terms.adoc[]

include::dkg-concepts.adoc[]


== Protocol

Input: _V~i~, S_

Output: one of

* Successfully generated group _P_ including
** public key _Y_ of _P_
** lists of absent and disqualified nodes _IA_ and _DQ_
* Failure to generate a valid group including
** list of disqualified nodes _DQ_

The group generation protocol selects a new candidate group _P_ from _S_
and runs a distributed key generation (DKG) protocol
to create a threshold signature public key _Y_ for the group,
to be used in the random beacon.

After a successful execution of the protocol,
_P_ will be the group of nodes
that may participate in the random beacon signing,
having been neither inactive or misbehaving during the DKG.

Inactive nodes will be removed from _P_
and not be eligible for the rewards
from participating in the random beacon
by contributing to the signature _V~j~_
should _P_ be chosen as the group to produce
the __j__th random number from the beacon.

Disqualified nodes will be removed from _P_
and their stake will be slashed in punishment
for provably and attributably acting in breach of the DKG protocol.

=== Group Selection

_TBD_

Input: _V~i~_, _N_

Output: _[Y~1~, Y~2~, ... Y~N~]_

For the purposes of the DKG algorithm,
group selection can be left undefined for now.
The protocol requires an ordered list of node identifiers,
represented here as public keys of participants _P~1~_ to _P~N~_.
This list is produced from _P_ using _V~i~_ as input.

=== Distributed Key Generation

Phases are seen from the perspective of _P~i~_

After phase _p_, the nodes that failed to broadcast a required message
will be added to _IA~p~_.
Nodes that broadcast a malformed message may be added to _IA~p~_ or _DQ~p~_.

[#phase-1,reftext="Phase 1"]
==== Phase 1. Ephemeral key generation

To ensure integrity in later parts of the DKG protocol,
we will require every _P~i~_ to generate
an ephemeral ECDH keypair _(x~ij~, y~ij~)_ for every other member _P~j~_ in _P_.
These will be broadcast in phase 1.

Registering the ephemeral keys on-chain is not required
if the broadcast channel assumption holds,
and all honest participants agree on the keys
published by each participant in phase 1.

[source, python]
----
# Receive:

[Y_1, Y_2, ... Y_N] # <1>

# Calculate:

t_init = getCurrentBlockHeight()

for P_j in P, P_j /= P_i:
  (X_ij, Y_ij) = genEcdhKeypair()

[X_i1, X_i2, ... X_iN] # <2>

[Y_i1, Y_i2, ... Y_iN] # <3>

# Broadcast:

[Y_i1, Y_i2, ... Y_iN]
----

<1> Identifiers of participants in candidate group _P_
<2> Private keys for communicating with other participants in _P_
<3> Public keys for communicating with other participants in _P_

[#phase-2,reftext="Phase 2"]
==== Phase 2. Ephemeral ECDH

Every node in _P_ has now published a valid list of ephemeral ECDH pubkeys.
_P~i~_ will perform ECDH with every _P~j~_ in _P_ to create _k~ij~_.

[source, python]
----
# Receive:

[[Y_12, Y_13, ... Y_1i, ... Y_1N],
 [Y_21, Y_23, ... Y_2i, ... Y_2N],
 ...
 [Y_N1, Y_N2, ... Y_Ni, ... Y_N(N-1)]] # <1>

# Calculate:

(G_2, IA_1, DQ_1) = checkBroadcast(1, G_1) # <2>

for P_j in G_2:
   k_ij = ecdh(X_ij, Y_ji)
----

<1> Public keys of all other participants in _P_
<2> A validation function which determines which nodes
have broadcast the correct message for phase _p_

[#phase-3,reftext="Phase 3"]
==== Phase 3. Polynomial generation

Every node in _G~3~_ has, for every other node in _G~3~_, a symmetric key that
can be used for encrypted and attributable communications over the broadcast
channel. The Pedersen-VSS phase of the GJKR DKG algorithm can commence.

Create two polynomials _f~i~(z)_ and _g~i~(z)_ of degree _T_ and calculate
other players' shares as points on these polynomials. Additionally, calculate
Pedersen commitments to the coefficients of _f~i~(z)_ using the coefficients
of _g~i~(z)_.

Shares to _P~j~_ are encrypted with the symmetric key _K~ij~ = K~ji~_
shared by _P~i~_ and _P~j~_.
Commitments and encrypted shares are broadcast to other players.


[source, python]
----
# Calculate:

G_3 = G_2

for k in [0..T]:
  a_ik = random(Z_q)
  b_ik = random(Z_q)

f_i(z) = sum(
  for k in [0..T]:
    a_ik * z^k
)

g_i(z) = sum(
  for k in [0..T]:
    b_ik * z^k
)

z_i = a_i0 = f_i(0) # <1>

commitments_i =
  for k in [0..T]:
    C_ik = g^a_ik * h^b_ik mod p # <2>

encryptedShares_i =
  for j in G_3:
    s_ij = f_i(j) mod q
    t_ij = g_i(j) mod q

    E_ij = encrypt(K_ij, (s_ij, t_ij)) # <3>

# Broadcast:

(encryptedShares_i, commitments_i)
----

<1> _P~i~_'s share of the shared secret key
<2> Pedersen commitments to coefficients
<3> Shares for _P~j~_ encrypted with the shared symkey

[#phase-4,reftext="Phase 4"]
==== Phase 4: Share verification

Receive, decrypt and validate shares from other participants. If any share
fails to pass validation, broadcast a complaint by publishing the corresponding
ephemeral private key so others can validate the result.

[source, python]
----
# Receive:

[(encryptedShares_1, commitments_1),
 ...
 (encryptedShares_N, commitments_N)]

# Calculate:

(G_4, IA_3, DQ_3) = checkBroadcast(3, G_3)

complaints_Ai = []

for j in G_4:
  E_ji = encryptedShares_j[i]

  (s_ji, t_ji) = decrypt(K_ij, E_ji)

  C_prod = product(
    for k in [0..T]:
      commitments_j[k] ^ (i^k)
  ) mod p

  if g^s_ji * h^t_ji /= C_prod:
    complaints_i += X_ij # <<1>>

# Broadcast:

complaints_Ai
----

<<1>> Publish the private key _P~i~_ created for communicating with _P~j~_,
so anyone can decrypt and verify the shares _P~i~_ received from _P~j~_.

[#phase-5,reftext="Phase 5"]
==== Phase 5: First complaint resolution

If anyone has complaints about another player,
use the published privkeys to decrypt transmitted messages and determine fault.
As every message in the broadcast channel is signed,
decrypting previous messages makes misbehavior attributable.
For every complaint, one party will be disqualified:
either the accused sent invalid shares,
or the accuser made a false complaint.

[source, python]
----
# Receive:

[complaints_A1, complaints_A2, ... ]

# Calculate:

(G_5, IA_4, DQ_4) = checkBroadcast(4, G_4)

DQ_5 = []

complaints_A = union(complaints_A1, complaints_A2, ...)

for c in complaints_A:
  P_j = c.sender
  P_m = c.accused
  X_jm = c.revealedKey

  K_jm = ecdh(X_jm, Y_mj)

  (s_mj, t_mj) = decrypt(K_jm, E_mj)

  C_prod = product(
    for k in [0..T]:
      C_mk ^ (j^k)
  ) mod p

  if g^s_mj * h^t_mj = C_prod: # <1>
    DQ_5 += P_j
  else:
    DQ_5 += P_m
----

<<1>> If the shares are inconsistent with commitments,
disqualify the accused _P~m~_; if consistent, disqualify the accuser _P~j~_.

[#phase-6,reftext="Phase 6"]
==== Phase 6: Share calculation

Each player sets their share _x~i~_ of the secret _X_ to equal the sum of all
shares _s~ji~_ as per GJKR. _X_ equals the sum of shares _s~j0~_.

[source, python]
----
# Calculate:

G_6 = G_5 - DQ_5

x_i = sum(
  for j in G_6:
    s_ji
) mod q

x'_i = sum(
  for j in G_6:
    t_ji
) mod q
----

[#phase-7,reftext="Phase 7"]
==== Phase 7: Public key share points

Each player broadcasts their _A~ik~_ values.

[source, python]
----
# Calculate:

G_7 = G_6

for k in [0..T]:
  A_ik = g^a_ik mod p

# Broadcast:

[A_i0, A_i1, ... A_iT]
----

[#phase-8,reftext="Phase 8"]
==== Phase 8: Public key share validation

Each player validates the values received in the previous step.

[source, python]
----
# Receive:

[[A_10, A_11, ... A_1T], ...]

# Calculate:

(G_8, IA_7, DQ_7) = checkBroadcast(7, G_7)

complaints_Bi = []

for j in G_8:
  A_prod = product(
    for k in [0..T]:
      A_jk ^ (i^k)
  ) mod p

  if g^s_ji /= A_prod:
    complaints_B += X_ij

# Broadcast:

complaints_Bi
----

[#phase-9,reftext="Phase 9"]
==== Phase 9: Second complaint resolution

As in <<phase-5>>, but with the validation formula from <<phase-8>>.

It should be noted that the symmetric nature of the encryption
allows the parties to also decrypt _E~jm~_ and not just _E~mj~_.
This is not very significant though,
as even the publication of only the misbehaving participants' shares
would reduce the security margin excessively
if a large fraction of _P_ were to misbehave.
By setting the threshold for group creation failure at _f~max~/2_
the impact of this is reduced to a manageable level.

[source, python]
----
# Receive:

[complaints_B1, complaints_B2, ...]

# Calculate:

(G_9, IA_8, DQ_8) = checkBroadcast(8, G_8)

DQ_9 = []

complaints_B = union(complaints_B1, complaints_B2, ...)

for c in complaints_B:
  P_j = c.sender
  P_m = c.accused
  X_jm = c.revealedKey

  K_jm = ecdh(X_jm, Y_mj)

  (s_mj, t_mj) = decrypt(K_jm, E_mj)

  A_prod = product(
    for k in [0..T]:
      A_mk ^ (j^k)
  ) mod p

  if g^s_mj = A_prod:
    DQ_9 += P_j
  else:
    DQ_9 += P_m
----

[#phase-10,reftext="Phase 10"]
==== Phase 10: Disqualified share opening

All active players in _G~10~_ broadcast the keys they share with
players in _DQ~9~_, so the reconstruction of Pedersen-VSS can be done
offline.

[source, python]
----
# Calculate:

G_10 = G_9 - DQ_9

keys_i = []

for m in DQ_9:
  keys_i += X_im

# Broadcast:

if keys_i /= []:
  keys_i
----

[#phase-11,reftext="Phase 11"]
==== Phase 11: Disqualified share reconstruction

Decrypt and reconstruct _z~m~_ for every participant _P~m~_ that presented
valid shares in <<phase-3>> but whose public key shares in <<phase-7>> were invalid.
Calculate _y~m~ = g^z~m~^ mod p_ for each reconstructed _z~m~_.

[source, python]
----
# Receive:

[keys_1, keys_2, ... , keys_N]

# Calculate:

(G_11, IA_10, DQ_10) = checkBroadcast(10, G_10)

for m in (G_6 - G_11): # <1>
  for j in G:
    X_jm = keys_j[m]

    K_jm = ecdh(X_jm, Y_mj)

    (s_mj, t_mj) = decrypt(K_jm, E_mj)

  ss_m = take(T + 1, [s_m1, ... , s_mN])

  is_m = [s.index for s in ss_m]

  z_m = sum(
    for k in is_m, s_mk in ss_m:
      a_mk = product(
        for l in is_m, l /= k:
          l / (l - k)
      )
      s_mk * a_mk
  )

  y_m = g^z_m mod p
----
<<1>> Reconstruct the shares of participants that became inactive
or were disqualified since <<phase-6>>

[#phase-12,reftext="Phase 12"]
==== Phase 12: Public key reconstruction

Let _G~12~ = G~11~_

Combine _y~j~_ for all participants in _G~6~_ to reconstruct the public key for
the group.

[source, python]
----
# Calculate:

for j in G_6:
  y_j = A_j0 = g^z_j mod p

Y = product(
  for j in G_6:
    y_j
) mod p
----

[#phase-13,reftext="Phase 13"]
==== Phase 13: Result publication

Let _IA = IA~1~ + IA~2~ + ... + IA~10~_

Let _DQ = DQ~1~ + DQ~2~ + ... + DQ~10~_

Player _P~1~_ is the participant designated to submit the result on-chain.
However, if _P~1~_ does not submit a transaction
within _T~dkg~_ blocks of starting the key generation protocol,
_P~2~_ becomes eligible to submit the public key.
After _T~dkg~ + T~step~_ blocks, _P~3~_ becomes eligible,
after _T~dkg~ + 2 * T~step~_ blocks _P~4~_, and so on.

When _P~j~_ submits the result, players _P~k~ | k < j_ will face a small
penalty for being late, while _P~j~_ will receive the submission reward.

[source, python]
----
if nPlayers(IA + DQ) > T/2:
  correctResult = Result.failure(disqualified = DQ)
else:
  correctResult = Result.success(pubkey = Y, inactive = IA, disqualified = DQ)

resultHash = hash(correctResult)

alreadySubmitted = False
resultPublished = False
finished = False

while not resultPublished:
  T_now = getCurrentBlockHeight()

  # using T_init from phase 1
  T_elapsed = T_now - T_init

  # determine highest index j eligible to submit
  if T_elapsed <= T_dkg:
    j = 1
  else:
    T_over = T_elapsed - T_dkg
    j = 1 + ceiling(T_over / T_step)

  if j >= i:
    broadcast(correctResult)
    resultPublished = True
    alreadySubmitted = True
  else:
    resultPublished = checkChainForResult()
----

[#phase-14,reftext="Phase 14"]
==== Phase 14: Result conflict resolution

Because of the honest majority assumption, we can expect
a result supported by at least _H_ participants to be correct.

If any participant disputes a result submitted on-chain, they can submit a
different one.

If any participant disputes the submitted result that currently has the greatest
number of signatures on-chain, believing a different result submitted on-chain
to be the correct one, they can publish a support message by publishing a
hash of their preferred result
(implicitly authenticated with the signature inherent in publishing on-chain).

Any participant can only vote for one submitted result, by submitting it or
publishing a support message for it.

Because of the available honest majority assumption, we can expect that any
result that is not at the lead after _T~conflict~_ time has elapsed has
acquired its maximum number of signatures it would be able to receive, and
thus the result receiving the plurality of support is the correct one.

An exception to this is if the total number of signatures supporting all other
submitted results is higher than _M~max~_, in which case the result is declared a
failure without disqualifications.

[source, python]
----
while resultPublished and not finished:
  allResults = getSubmissions()
  leadResult = allResults.mostVotes

  T_now = getCurrentBlockHeight()
  T_first = allResults.earliest.submitTime

  if T_now > T_first + T_conflict or leadResult.votes > M_max:
    finished = True

  elif correctResult = leadResult or alreadySubmitted:
    wait()

  elif correctResult in allResults:
    submit(sign(resultHash))
    alreadySubmitted = True

  else:
    submit(correctResult)
    alreadySubmitted = True
----

From the perspective of the chain:


[source, python]
----
# memberVotes :: Set PlayerID
memberVotes = Set.empty()

# receivedSubmissions :: Map (HashOf Result) Result
receivedSubmissions = Map.empty()

# submissionVotes :: Map (HashOf Result) Int
submissionVotes = Map.empty()


def eligibleSubmitter(P_i):
    T_now = getCurrentBlockHeight()
    T_elapsed = T_now - T_init

    i = P_i.index

    if i == 1:
        True
    elif T_elapsed >= T_dkg + (i-2) * T_step:
        True
    else:
        False


def addVote(player, resultHash):
    memberVotes.add(player)
    submissionVotes[resultHash] += 1


def alreadyVoted(player):
    memberVotes.contains(player)


def addSubmission(submitter, result):
    resultHash = hash(result)
    receivedSubmissions[resultHash] = result
    memberVotes.add(submitter)
    submissionVotes[resultHash] = 1


def alreadySubmitted(resultHash):
    receivedSubmissions.hasKey(resultHash)

# data Submission = Submission Result PlayerID
# data Vote = Vote (HashOf Result) PlayerID

def receiveSubmission(s):
    P_s = s.submitter
    result = s.result
    resultHash = hash(result)

    if receivedSubmissions == {}:
        if eligibleSubmitter(P_s): # <1>
            addSubmission(P_s, s)
        else:
            reject(s)
    else:
        if alreadyVoted(P_s):
            reject(s)
        elif alreadySubmitted(resultHash): # <2>
            addVote(P_s, resultHash)
        else:
            addSubmission(P_s, result)

def receiveVote(v):
    P_v = v.submitter
    resultHash = hash(v.result)

    if alreadyVoted(P_v) or not alreadySubmitted(resultHash):
        reject(v)
    else:
        addVote(P_v, resultHash)


def getFinalResult():
    (leadingResult, highestVoteN) = submissionVotes.maxByValue()
    totalVotes = sum(submissionVotes.values())

    if totalVotes - highestVoteN >= f_max: # <3>
        return Result.failure(disqualified = [])
    else:
        return leadingResult
----

<<1>> Eligibility gets tested on the first submission only;
after one valid submission it's a free for all.

<<2>> When the same result gets "initially" submitted,
such as when a different result was previously submitted and two
participants submit theirs in the same block

<<3>> If more than _f~max~_ participants vote for a non-leading result,
our honest majority assumption has failed
and we cannot determine the correct outcome.

[bibliography]
== References

- [[[GJKR]]] Gennaro R., Jarecki S., Krawczyk H., Rabin T. (1999)
Secure Distributed Key Generation for Discrete-Log Based Cryptosystems.
In: Stern J. (eds) Advances in Cryptology — EUROCRYPT ’99. EUROCRYPT 1999.
Lecture Notes in Computer Science, vol 1592. Springer, Berlin, Heidelberg

- [[[Ped]]] Pedersen T.P. (1992)
Non-Interactive and Information-Theoretic Secure Verifiable Secret Sharing.
In: Feigenbaum J. (eds) Advances in Cryptology — CRYPTO ’91. CRYPTO 1991.
Lecture Notes in Computer Science, vol 576. Springer, Berlin, Heidelberg
