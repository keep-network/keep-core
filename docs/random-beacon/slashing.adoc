:icons: font
:numbered:
toc::[]

== Misbehavior and punishments

To incentivize correct behavior in the Keep network,
misbehaving participants will be punished. In some situations,
proving misbehavior requires cooperation from another participant,
a _tattletale_. This coordination is incentivized by rewarding the _tattletale_
by granting them a fraction of the tokens taken from the misbehaving participant.

Tokens are staked by transferring them to the staking contract.
The staking contract tracks the stake allocated to each _staker_.
Stakes can be _slashed_ to punish misbehavior.
Tokens backing slashed stakes are burned;
if a tattletale proves another operator's misbehavior
they will receive 5% of the slashed tokens,
the remainder being burned.
The misbehaving operator will then be removed from its group.

==== Authorization

_Operator contracts_ are authorized to impose penalties
by stakers' _authorizers_.
All stakers using the same _authorizer_
share the set of authorized operator contracts.
Once given, this authorization cannot be revoked by the authorizer.

When a staker wishes to join a group
the contract responsible for creating the group
will be authorized by the staker's authorizer.
The operator contract will check its authorization status
when determining a staker's eligibility.

Authorization is checked when a staker submits a ticket for validation. Tickets submited to an unauthorized contract will be rejected as invalid. 

==== Penalties

When an operator misbehaves on-chain,
the operator contract calls the staking contract to punish the operator.
The staking contract checks
that the operator contract is authorized to punish the staker,
and if true, applies the penalty.

A penalty can be applied to one or more stakers simultaneously.
Each affected staker is penalized by the same amount.

===== Pure slashing

When misbehavior is detected without third-party input,
a _pure slashing_ penalty is applied.
Pure slashing means that the staking contract
subtracts the applicable penalty from the operator's stake
and burns tokens equal to the penalty amount.

===== Seizing

When a tattletale proves another operator's misbehavior,
a fraction of the penalty amount is _seized_ and transferred to the tattletale,
while the rest is burned.
The tattletale reward can be set to any value
between 0 and the maximum of 5% of the penalty.

To apply a seizing penalty,
the operator contract includes the tattletale operator's address in the call.
The staking contract subtracts the applicable penalty from the operator's stake
and transfers the reward to the tattletale's _beneficiary_ address.
The remainder is burned.

===== Penalty amounts
TODO: How are penalty amounts determined in the final implementation?

Penalties for misbehavior could be adjusted
to match the severity of the misbehavior.
However, initially a simple rule should be sufficient:
when `op_contract` imposes a punishment,
the amount slashed should equal
the minimum stake required to participate in operations on `op_contract`.
If contract _Foo_ requires 10,000 KEEP to participate with one virtual staker,
_Foo_ should slash a misbehaving virtual staker by 10,000 KEEP.

==== Interface requirements

===== Staking contract: slashing

TODO: Describe in prose?

`slash(tokens sum, address[] misbehavers)`::

Check that `msg.sender` is authorized
to slash each `misbehaver` in `misbehavers`:
`isAuthorized(msg.sender, misbehaver.authorizer) == true`.
+
Subtract `sum` tokens from the stake of each `misbehaver`
and burn `sum * length(misbehavers)` tokens.

`seize(tokens sum, float pay, address tattletale, address[] misbehavers)`::

Check that `msg.sender` is authorized
to slash each `misbehaver` in `misbehavers`:
`isAuthorized(msg.sender, misbehaver.authorizer) == true`.

Check that `0 < pay {lt}= 1`.

Subtract `sum` tokens from the stake of each `misbehaver`;
set `total = sum * length(misbehavers)` and `reward = total * 0.05 * pay`;
burn `total - reward`; transfer `reward` to beneficiary of staker `tattletale`.

===== Staking contract: authorizations
TODO: Describe in prose?

`authorize(address op_contract)`::

Authorize `op_contract`.
Operators using `msg.sender` as their authorizer
may now join operations on `op_contract`
and `op_contract` may slash their stakes.

`isAuthorized(address op_contract, address by) -> bool`::

Check if the authorizer `by` has authorized `op_contract`.

===== Token contract

`burn(amount sum)`::

Any address that holds tokens can call `burn(amount sum)`
to burn `sum` tokens, limited by tokens held by the address.

=== Misbehavior and penalties in the Random Beacon

==== DKG

===== Invalid ticket

Invalid tickets are detected automatically
without the need for a tattletale. Proof of invalid tickets is _objective_,
as all information required to verify tickets is available on-chain. Because the cost of ticket submission is paid by the submitter,
the ticket can be simply rejected and the transaction reverted.

===== Failure to produce a DKG result
TODO: What is the trigger transaction?

Failure to finish DKG is verifiable without additional proof,
but requires a trigger transaction for this verification
after the deadline for completing DKG has passed.
If no other trigger transaction is made,
the trigger transaction for another DKG shall check
if the previous attempt at DKG has failed to produce a result.

TODO: is objective a function?
Failure to finish DKG is _objective_.

Failure to produce a result will not be explicitly penalized as the participants will forfeit their ticket submission fees. 

===== Submitting an invalid DKG result

Invalid DKG results are detected automatically.

Proof of invalid DKG results is _objective_.

Submitters are not explicitly penalized for submitting an invalide ticket. They are however, not reimbursed. 

===== Inactivity in DKG

An operator might fail to send a required message during DKG. This lowers the effective safety margin of the group
against lynchpinning and inability to produce a signature.

Inactivity in DKG is determined by the list of inactive members in the DKG result submission.

TODO: are we following some specific techinical descriptions of _subjective_ and _objective_?

Unless DKG is performed on-chain, proof of inactivity in DKG is _subjective_ and subject to the honest majority assumption; a dishonest majority could always forge a false proof of inactivity. It is not possible to make off-chain DKG inactivity objectively provable.

Inactive members will be removed from the group, but not otherwise punished; the opportunity cost of not being included in the group already provides an incentive to be active.

===== Disqualification in DKG

Disqualification in DKG is determined like inactivity,
by the list of disqualified members being included in the result submission. On-chain proof of disqualification is _subjective_
and a dishonest majority could forge a false proof.

TODO: Is this true for the current implementation?
Punishing disqualified members based on subjective proof creates opportunities for dishonest majorities to attack other stakers
in a way which extends beyond the damage caused by frontrunning the beacon. Because of this, punishing disqualified members without objective proof requires further examination of the associated risks and incentives.

For the first version, disqualification shall be treated like inactivity and only punished with removal from the group.

==== Signing

===== Invalid signature share

Invalid signature shares can only be detected on-chain if a tattletale submits a proof that includes the signature share and the information required to verify it.

TODO: What has been implemented in the current version?
In the first version,
the infrastructure for verifying these proofs is not yet in place.
Invalid signature shares shall be simply rejected by the other members.

===== Failing to broadcast a signature share

Failure of an individual member to broadcast a signature share
can not be reliably detected on-chain,
even in the event the group as a whole fails to produce a signature.
Thus, individual failures to broadcast shares shall not be punished.

===== Submitting an invalid signature

An operator may submit an invalid threshold signature on-chain
when generating a beacon entry, and these are automatically detected.

Proof of an invalid threshold signature is _objective_.

TODO: Who is verifying the signature? The submitter or the group? 

As verifying a threshold signature is relatively expensive,
no separate punishment is needed beyond reverting the transaction.

===== Unauthorized use of individual private key

Unauthorized use of a member's individual private key
can be proven on-chain by the submission of a suitable proof.

TODO: Is this currently true?
The first version is not yet able to verify these proofs,
so unauthorized use of individual private keys is not separately penalized.

===== Creating an unauthorized signature

An entire signing group's private key could be abused to create an unauthorized signature.

Unauthorized threshold signing can be proven by publishing a value the group hasn't been previously requested to sign, and a valid signature for the value. Proof of unauthorized signing is _objective_.

Unauthorized signing will be punished by _seizing_ tokens from all members, based on submission of a proof from the _tattletale_.

===== Failure to produce a signature

A signing group may fail to produce a new entry within the deadline. This can be verified on-chain without a separate proof,
but requires a transaction to trigger this check.

TODO: What is the triggering transaction called?

The proof of failure is _objective_.

When a group fails to produce an entry, all of its members will be subject to _seizing_ and the group itself will be terminated. The submitter of the trigger transaction will be treated as the _tattletale_, but the tattletale reward will be limited to `min(1, 20 / group_size)` of the maximum, or effectively the minimum stake of a single member. This is to prevent actors in a lynchpin position from profitably stealing other stakers' funds.


=== Limitations

Slashing is not limited to the amount originally staked for participating in the relevant operations; a malfunctioning operator contract could cause a staker to lose all stake. Chain reorganizations may lead to honest behavior in one branch being punishable misbehavior in another. Mitigations for this have not been included in this RFC.

