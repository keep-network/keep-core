:toc: macro

= Pricing

== Background

The beacon needs to capture enough value to make it self-sufficient.
It uses a simple method for pricing beacon entries
that doesn't present easy exploitation opportunities.
The pricing method avoids
the known downfalls of previously considered, more complex, schemes,
such as price discrimination being defeated by callback pooling.

==== UML diagram
[ditaa]
+-----------------+            
|  estimate_fee   |            
+-----------------+       

==== Making requests
How are requests made?

A request begins with the query 
`entry_fee_estimate = estimate_fee(callback_gas_amount)`
, which provides the customer with an estimated gas cost to use in the request. 
The fee estimate is only valud for the transaction it is called in, so the customer must
make the request immediately after obtaining the estimate. Insufficient payment will lead to the request being rejected
and the transaction reverted.

To make a request after determining the applicable fee
the customer must call the request method on the beacon,
transferring enough currency to cover the fee:
`request_entry.value(entry_fee_estimate)()`.

If the customer wishes to receive the generated random number in a callback, they should also specify the _callback address_, _callback function_, and _callback gas amount_:
`request_entry.value(entry_fee_estimate)(callback_address, callback_function, callback_gas)`.

No new requests should be made
while the beacon is already processing another request.
Requests made while the beacon is busy will be rejected
and the transaction reverted.

==== Receiving a request
How are customer requests handled by the protocol?

A request sent to a non-busy beacon is checked for _request fee_ >= _entry fee estimate_ + _callback gas amount_ from the request. If the beacon is already serving an earlier request, it rejects any new requests and refunds the fee.

A sufficiently funded request triggers the beacon to select the new signing group.
The selected group is tasked with producing the new entry.

The request is then set as the _pending request_
with the following information:

- the _requester address_

- the _callback address_, _callback function_, and _callback gas amount_, if applicable

- the _assigned signing group_{blank}footnote:[This is needed
if changes to the active groups can be made
while waiting for an entry.
]

- the _submission delay base time_ which equals
the number of the block the request was received in,
plus 1{blank}footnote:[The way of calculating rewards
is inevitably prone to off-by-one errors _somewhere_
and doing the incrementing at request time seems the simplest.
]

- the _estimated gas price_ at the time of the request{blank}footnote:[This
means we don't need to assume the price feed remains stable
between the making of the request and the paying out of rewards.
If the gas price feed is guaranteed to not change
until a valid entry is received, this is not necessary.
]

- the _request fee_ paid

==== Serving a request

===== Receiving submissions
How does the protocol handle a submission from the relay?

A valid entry created by a signing group is submitted by a 
member of the group called the _submitter_, before the _Submission deadline_. 
Submissions that fail verification are ignored.
Repeat submissions for a request that has already been served are dropped immediately to minimize gas expenditure.

If no valid entry has been received by the _submission deadline_
a submission timeout can be called by anyone, as a result of which:

- the failing group is terminated and its members slashed

- a new signing group is assigned from the remaining active groups

- the submission delay calculation is reset by setting the _submission delay base time_ to the previous _submission deadline_.

When a valid entry submission is received on-chain:

- it is emitted in an event

- the requester's callback is called if applicable

- and fees, rewards and refunds are paid out

===== Callback processing
How are callbacks processed?

A callback is called using the callback gas amount as the maximum gas. 
If the callback gas amount is insufficient,
callback execution is skipped and the rest of the relay entry submission code
is processed as usual.

_callback expenditure_ is calculated as, gas spent on call * minimum(_estimated gas price_, _callback expenditure_). 

The minimum of the gas price is included to protect the beacon and requester against malicious miner-submitters.

Malicious miner-submitter attacks: 

- a miner-submitter can steal the surplus pool subsidy by placing an arbitrary gas price on the transaction that is higher than quoted. This will cause the  the requester refund to go negative. If the negative requester refund is added to the 1% surplus pool subsidy it can permit the miner-submitter to steal the subsidy.

- a miner-submitter can steal the requesters refund by setting the gas price to the provided maximum. The requester is billed for the entire gas budget even if they really only spent a small fraction of it. 

A callback execution that uses more gas than specified in the request, it will run out of gas. A callback execution can cost more than was quoted and paid for only when the gas cost of the transaction exceeds the 
quoted estimate (which includes the safety margin mentioned in the gas price feed
section). The submitter is intended to take the hit for submitting with a gas price that exceeds the estimate.

===== Requester refund
How is a refund to the requester processed?

Note: when is a requester refund processed? - Ask promethea

_requester refund = actual entry price - requester fee + 1% of request subsidy pool_

_actual entry price = callback expenditure +  entry base price_ 

_entry base price = estimated gas price + profit margin + DKG contribution amortized over multiple entries + entry verification fee_

_Group & Submitter reward = F (submission delay, submission delay base time)_

If the sum of rewards paid out
is < _profit margin + entry verification fee_,
the difference is added to the _request subsidy pool_.

---
This section appears to be a bunch of options?

The _DKG contribution_ is added to the _DKG fee pool_,
and the state of the pool is checked.

If the amount in the DKG fee pool equals or exceeds the _DKG cost estimate_,
group creation and a new DKG may be triggered.footnote:[Whether
DKG is actually triggered is open.

Always triggering DKG when the fee pool reaches a given level
doesn't smooth out fluctuations in demand:
a very large number of groups is created when demand is high,
but those groups will expire on schedule if a slump occurs.

A stochastic method for triggering DKG
would permit smoothing out demand fluctuations:
Take the current number of active groups,
divide by a threshold number of groups,
and e.g. square root the result to get a(n insensitivity) number;
Trigger DKG if the entry (interpreted as a number from 0 to 1)
is less than 1 divided by the above number.
If the number of active groups is below the threshold,
this attempts to create a new signing group
every time sufficient funding is present;
with higher demand the number of groups
tends to be proportional to _(number of entries in expiration period)^2/3^_.
]

---

==== Rewards

A _base reward_ for each member of a signing group that produces an entry
is specified in the system constants in the service contract.
The nominal _profit margin_ of each entry
equals the _base reward_ multiplied by the applicable _group size_.

The exact rewards paid out to operators are based on the base reward
but vary according to _submission delay_ and submitter position.

If the amount paid out to the signing group in _group rewards_
and the submitter's _extra reward_ is less than the _profit margin_,
the difference is added to the beacon's _request subsidy pool_
to incentivize customers to request entries.

===== Submitter reward
_Submitter reward = F (submission delay, submission delay base time)_

If the sum of rewards paid out
is < _profit margin + entry verification fee_,
the difference is added to the _request subsidy pool_.


===== Group reward
How are group members compensated?

The group reward is paid to every member of the signing group,
including the submitter,
upon submission of a valid entry.

The group reward equals the _base reward_
multiplied by a _delay factor_
equaling the fraction of time left by the submission deadline, squared:
_group reward = base reward * delay factor_;
_delay factor = (T~remaining~ / (T~deadline~ - T~begin~))^2^_;
_T~remaining~ = T~deadline~ - T~received~_.

The delay factor is counted
from 1 in the first block a submission could be published in,
to 0 in the deadline block which doesn't accept any more submissions.

For example, assume the maximum time to submit is 20 blocks,
the off-chain entry generation protocol takes 5 blocks
and a request is made on block 1000.

Block 1005 is the earliest block the submission could be published in:
if published in this block the delay factor is 1.
Block 1025 is the deadline block:
no submissions are accepted and the delay factor is 0.

If the entry is submitted in block 1009,
the delay factor is:
```
((1025 - 1009) / (1025 - 1005))^2 = 0.8^2 = 0.64
```
Thus the _group reward = base reward * 0.64_,
with the difference being the _delay penalty = base reward * (1 - 0.64)_.

If the submission deadline is reached and the delay factor reaches 0,
the entry submission fails and all group members are penalized.

===== Submitter reward
How are submitters compensated?

In addition to the _group reward_,
the submitter is reimbursed for gas fees
and receives an extra reward.

The _submitter reward_ consists of
the _callback expenditure_ to cover the exact cost of the callback;
the _entry verification fee_ to cover the cost of verifying the submission;
and 5% of the _delay penalties_ of the entire group.

Unlike the _callback allowance_,
the entire _entry verification fee_ is paid to the submitter
regardless of their gas expenditure.
The submitter is free to spend less or more,
keeping the surplus or paying the difference.
This is to incentivize optimizing gas fees.

To incentivize a race for the submitter position,
the submitter receives _delay penalty * group size * 0.05_ as an extra reward.
With realistic group sizes this is significant,
but not high enough to render certain attacks profitable.
If the group size is 100 and the delay factor is 0.64,
the submitter receives an extra reward of
_base reward * 0.36 * 100 * 0.05 = base reward * 1.8_.
In this scenario the full submitter reward would be
_base reward * (1.8 + 0.64) + callback expenditure + entry verification fee_.

==== DKG submitter reimbursement
How is the DKG submitter compensated?

Getting to participate in a formed group is already valuable so there is no
additional reward for a DKG result submitter. The only thing necessary is a gas
cost reimbursement for the submitter.

After DKG result is submitted, the amount of gas spent on the call is 
multiplied with the lower of the estimated gas price at the time of submitting
the result, or the actual gas price of the transaction to get the _DKG result
submission expenditure_.

The entire DKG result submission expenditure is returned to the submitter
from the _DKG fee pool_ of the operator contract.

Any surplus between the _DKG fee pool_ of the operator contract and 
the actual cost of DKG result submission is returned back to the service 
contract. In the case when the entire DKG fails, the unspent fee will be 
transferred back to the service contract upon the next DKG triggered by the 
service contract.

The minimum of the gas price protects the beacon against malicious 
miner-submitters. If the submitter is also a miner, they can place any 
arbitrary gas price on the transaction. Without taking the minimum, 
miner-submitter would be able to steal from _DKG fee pool_ of the operator 
contract.

The on-chain DKG result submission code needs to have all deterministic 
and time-bounded run paths that are independent of miner-controlled inputs. 
If the miner-submitter pays the gas price estimated by the price feed, but 
tricks the contract into consuming twice the gas as normal, they will be able 
to get twice the reimbursement as well. 

==== Cost estimates
How do we estimate the various costs?

===== Gas price feed
Where does the gas price come from?

A short-term gas price feed is required
to estimate the gas cost components.

The critical feature of the gas price feed is
that the feed price multiplied by a safety margin for fluctuations (e.g. 1.5)
should be sufficient for getting beacon entries processed
within the deadline under all circumstances.
The gas price estimate for an entry is set when the request is processed,
but the entry submission transaction will be sent later.

If actual gas prices rise to a level
where the feed price and margin are insufficient
for getting a transaction to be mined,
and stays there for the duration of the entry submission window,
the basic profit margin for the operators cannot be guaranteed.

However, this does not imply that high gas prices
would render the beacon inoperable.
The submitter's extra reward incentivizes submitting
even when the entry verification fee cannot cover the gas costs.
In the extreme,
avoiding the severe penalty for failure to produce an entry
should incentivize group members to pay the gas prices
up to the (theoretical) limit
where gas for the entry submission transaction
costs as much as the KEEP tokens at stake.

The exact implementation of this gas price feed
is out for scope for this RFC.footnote:[A rather obvious candidate
is to use the gas price paid by the requester.
This doesn't work if the requester is a miner
as they can provide an arbitrarily low price.
]

===== DKG cost estimate
How do we calculate the cost of running the DKG?

The gas required for DKG should be calculated.
DKG gas cost should include only DKG result submission. Ticket submission
costs are covered by the expected return from getting into a signing group.
Multiply DKG gas by gas estimate to get DKG cost estimate.
Use a DKG frequency divider _d_ to set the group creation rate;
once every _d_ entries on average.
Divide DKG cost estimate by _d_ to get DKG contribution for each entry.

The maximum DKG gas cost should be hardcoded in the operator contract.
The service contract takes the highest applicable gas cost from all operator
contracts being used and multiplies it by the fluctuation margin times gas price 
feed's estimate.

Because DKG is performed when sufficient gas money has accumulated,
fluctuations in gas prices don't need special consideration.
When gas costs are rising,
DKG gets performed less frequently
until prices (and thus gas cost contributions) stabilize.
As long as the fluctuation safety factor is sufficient
to cover the immediate rise in gas fees during DKG execution
the beacon is capable of generating new groups.
Similarly, when gas costs fall DKG gets triggered faster.

===== Entry verification fee
How do we calculate the gas required for entry verification?

Calculate gas required for verifying entry and associated support operations.
The maximum entry verification gas cost should be hardcoded in the operator
contract. The service contract takes the highest applicable gas cost from all 
operator contracts being used and  multiplies it by the fluctuation margin 
(e.g. 1.5) times gas price feed's estimate to get entry verification fee.

==== Cleanup gas efficiency
How do we calculate the cost of cleanup or post processing?

As the gas cost of storing data in a previously zero field
and later zeroing it again (20,000 + 5,000 - 15,000 = 10,000)
exceeds the cost of modifying a nonzero field (5,000),
cleaning unnecessary fields would appear to increase operating costs
with little upside.

However, gas costs in the entry submission transaction
contribute 1.5 times as much to the effective price of beacon entries.
Thus the 10,000 gas net refund per field
is effectively worth 15,000 gas,
making both options equal to the requester.
The difference of 5,000 actual gas is effectively paid by the submitter
in the form of a lower _entry verification fee_.

Packing request data more densely,
where applicable,
could further reduce operating costs.

===== Zeroing everything


Resetting all request fields to zero after serving a request
increases the immediate gas cost of making a request,
but reduces the entry verification fee by a roughly equal amount.

This results in a slightly lower total revenue for operators,
but reduces the possible space of programming errors marginally;
false positives for pending requests are eliminated
even if the wrong field is queried.
In practice this benefit is negligible.

===== Wiping the minimum necessary

Wiping only the necessary fields results in higher operator revenue
for the same net price paid by requesters.
Additionally, if a field remains nonzero but unchanged between requests
even greater gas savings can be obtained.

The field used to determine the presence of a pending request must be wiped.

The requester address,
assigned signing group,
submission delay base time,
gas price estimate
and request fee
are always written when a request is received.
These are not necessary to wipe,
but one of them must be chosen to signify the presence of a pending request
with a nonzero value.

Requester address, signing group, gas price and fee
can theoretically stay unchanged between requests.
If a single heavy user makes a number of consecutive requests
with the same callback (gas amount) and gas prices are stable,
this would provide a minor reduction in beacon operating costs.

The submission delay base time
is guaranteed to change when a new request is made,
and thus is the most efficient indicator of a pending request.
Using the maximum value instead of zero for "no request"
is slightly more efficient.

The presence of a callback can be determined by either 
the callback address or callback gas.

The callback address is likely to remain the same
only if the requester is the same.

Because excess callback gas is refunded
the only cost of setting a higher callback gas is the tied-up liquidity,
with the exception of callbacks
where excessive gas consumption indicates an error state
where reverting is preferable to continuing.
With well-programmed callback contracts,
the callback gas amount is only necessary to modify
if it needs to be increased,
or if the requester cannot afford the higher gas allowance.

This suggests that using callback address to denote the presence of a callback
allows minor efficiency gains.
Modifying the callback address when a request is processed,
including setting it to zero in a no-callback request,
further improves gas efficiency.

=== Limitations

Entry pricing is mostly static;
entry quality has a slight effect on price
(faster entries -> lower surplus -> lower request subsidies)
but other factors apart from gas fees do not impact the price.

Processing entries one-by-one doesn't scale.

== Future Work

Instead of rejecting new requests when one has already been made,
the beacon could accept a single queued request,
to be served after the active one.
Other requesters could outbid the current queued request
by paying enough to process the request and refund the previous one,
and provide some specified (e.g. 1.2) increase in the profit margin.
When the current active request is served,
the queued request automatically becomes the next active request.

This method would act as both a price floor and a supply cap,
while capturing the effective price increase when demand exceeds supply,
instead of letting it go to miners
as customers try to get their requests processed first.

== Open Questions

The implementation of the gas price feed is out of scope.
The method of estimating gas fees,
the timespan over which the estimate should be calculated,
and the fluctuation safety margin are not yet defined.

////
[bibliography]
== Related Links

- Flowdock Links
////
