:toc: macro

= Pricing

== Background

The beacon needs to capture enough value to make it self-sufficient.
It uses a simple method for pricing beacon entries
that doesn't present easy exploitation opportunities.
The pricing method avoids
the known downfalls of previously considered, more complex, schemes,
such as price discrimination being defeated by callback pooling.

==== UML diagram
[ditaa]
+-----------------+            
|  estimate_fee   |            
+-----------------+       

==== Making requests
How are requests made?

A request begins with the query 
`entry_fee_estimate = estimate_fee(callback_gas_amount)`
, which provides the customer with an estimated gas cost to use in the request. 
The fee estimate is only valud for the transaction it is called in, so the customer must
make the request immediately after obtaining the estimate. Insufficient payment will lead to the request being rejected
and the transaction reverted.

To make a request after determining the applicable fee
the customer must call the request method on the beacon,
transferring enough currency to cover the fee:
`request_entry.value(entry_fee_estimate)()`.

If the customer wishes to receive the generated random number in a callback, they should also specify the _callback address_, _callback function_, and _callback gas amount_:
`request_entry.value(entry_fee_estimate)(callback_address, callback_function, callback_gas)`.

No new requests should be made
while the beacon is already processing another request.
Requests made while the beacon is busy will be rejected
and the transaction reverted.

==== Receiving a request
How are customer requests handled by the protocol?

A request sent to a non-busy beacon is checked for _request fee_ >= _entry fee estimate_ + _callback gas amount_ from the request. If the beacon is already serving an earlier request, it rejects any new requests and refunds the fee.

A sufficiently funded request triggers the beacon to select the new signing group.
The selected group is tasked with producing the new entry.

The request is then set as the _pending request_
with the following information:

- the _requester address_

- the _callback address_, _callback function_, and _callback gas amount_, if applicable

- the _assigned signing group_{blank}footnote:[This is needed
if changes to the active groups can be made
while waiting for an entry.
]

- the _submission delay base time_ which equals
the number of the block the request was received in,
plus 1{blank}footnote:[The way of calculating rewards
is inevitably prone to off-by-one errors _somewhere_
and doing the incrementing at request time seems the simplest.
]

- the _estimated gas price_ at the time of the request{blank}footnote:[This
means we don't need to assume the price feed remains stable
between the making of the request and the paying out of rewards.
If the gas price feed is guaranteed to not change
until a valid entry is received, this is not necessary.
]

- the _request fee_ paid

==== Serving a request

===== Receiving submissions
How does the protocol handle a submission from the relay?

A valid entry created by a signing group is submitted by a 
member of the group called the _submitter_, before the _Submission deadline_. 
Submissions that fail verification are ignored.
Repeat submissions for a request that has already been served are dropped immediately to minimize gas expenditure.

If no valid entry has been received by the _submission deadline_
a submission timeout can be called by anyone, as a result of which:

- the failing group is terminated and its members slashed

- a new signing group is assigned from the remaining active groups

- the submission delay calculation is reset by setting the _submission delay base time_ to the previous _submission deadline_.

When a valid entry submission is received on-chain:

- it is emitted in an event

- the requester's callback is called if applicable

- and fees, rewards and refunds are paid out

===== Callback processing
How are callbacks processed?

A callback is called using the callback gas amount as the maximum gas. 
If the callback gas amount is insufficient,
callback execution is skipped and the rest of the relay entry submission code
is processed as usual.

_callback expenditure_ is calculated as, gas spent on call * minimum(_estimated gas price_, _callback expenditure_). 

The minimum of the gas price is included to protect the beacon and requester against malicious miner-submitters.

Malicious miner-submitter attacks: 

- a miner-submitter can steal the surplus pool subsidy by placing an arbitrary gas price on the transaction that is higher than quoted. This will cause the  the requester refund to go negative. If the negative requester refund is added to the 1% surplus pool subsidy it can permit the miner-submitter to steal the subsidy.

- a miner-submitter can steal the requesters refund by setting the gas price to the provided maximum. The requester is billed for the entire gas budget even if they really only spent a small fraction of it. 

A callback execution that uses more gas than specified in the request, it will run out of gas. A callback execution can cost more than was quoted and paid for only when the gas cost of the transaction exceeds the 
quoted estimate (which includes the safety margin mentioned in the gas price feed
section). The submitter is intended to take the hit for submitting with a gas price that exceeds the estimate.

===== Requester refund
How is a refund to the requester processed?

Note: when is a requester refund processed? - Ask promethea

_requester refund = actual entry price - requester fee + 1% of request subsidy pool_

_actual entry price = callback expenditure +  entry base price_ 

_entry base price = estimated gas price + profit margin + DKG contribution amortized over multiple entries + entry verification fee_

_Group & Submitter reward = F (submission delay, submission delay base time)_

If the sum of rewards paid out
is < _profit margin + entry verification fee_,
the difference is added to the _request subsidy pool_.

The _DKG contribution_ is added to the _DKG fee pool_,
and the state of the pool is checked.

If the amount in the DKG fee pool equals or exceeds the _DKG cost estimate_,
group creation and a new DKG may be triggered.


==== Rewards

A _base reward_ for each member of a signing group that produces an entry
is specified in the system constants in the service contract and:

_profit margin = base reward * group size_

The exact rewards paid out to operators are based on the base reward
but vary according to _submission delay_ and submitter position.

To incentivize customers to request entries, any amount in excess of the _profit margin_ is added to the beacons _request subsidy pool_

===== Submitter reward
_Submitter reward = F (submission delay, submission delay base time)_

If the sum of rewards paid out
is < _profit margin + entry verification fee_,
the difference is added to the _request subsidy pool_.

===== Group reward
How are group members compensated?

The group reward is paid to every member of the signing group,
including the submitter, upon submission of a valid entry.

The group reward equals the _base reward_
multiplied by a _delay factor_
equaling the fraction of time left by the submission deadline, squared:
_group reward = base reward * delay factor_;
_delay factor = (T~remaining~ / (T~deadline~ - T~begin~))^2^_;
_T~remaining~ = T~deadline~ - T~received~_.

The delay factor is counted
from 1 in the first block a submission could be published in,
to 0 in the deadline block which doesn't accept any more submissions.

For example, assume the maximum time to submit is 20 blocks,
the off-chain entry generation protocol takes 5 blocks
and a request is made on block 1000.

Block 1005 is the earliest block the submission could be published in:
if published in this block the delay factor is 1.
Block 1025 is the deadline block:
no submissions are accepted and the delay factor is 0.

If the entry is submitted in block 1009,
the delay factor is:
```
((1025 - 1009) / (1025 - 1005))^2 = 0.8^2 = 0.64
```
Thus the _group reward = base reward * 0.64_,
with the difference being the _delay penalty = base reward * (1 - 0.64)_.

If the submission deadline is reached and the delay factor reaches 0,
the entry submission fails and all group members are penalized.

===== Submitter reward
How are submitters compensated?

In addition to the _group reward_,
the submitter is reimbursed for gas fees
and receives an extra reward.

The _submitter reward_ consists of:
- _callback expenditure_ to cover the exact cost of the callback

- the _entry verification fee_ to cover the cost of verifying the submission

- 5% of the _delay penalties_ of the entire group

Unlike the _callback allowance_,
the entire _entry verification fee_ is paid to the submitter
regardless of their gas expenditure.
The submitter is free to spend less or more,
keeping the surplus or paying the difference.
This is to incentivize optimizing gas fees.

To incentivize a race for the submitter position,
the submitter receives:

 _delay penalty * group size * 0.05_ as an extra reward

With realistic group sizes this is significant,
but not high enough to render certain attacks profitable.
If the group size is 100 and the delay factor is 0.64,
the submitter receives an extra reward of:

_base reward * 0.36 * 100 * 0.05 = base reward * 1.8_

In this scenario the full submitter reward would be:

_base reward * (1.8 + 0.64) + callback expenditure + entry verification fee_

==== DKG submitter reimbursement
How is the DKG submitter compensated?

Getting to participate in a formed group is already valuable so there is no
additional reward for a DKG result submitter. The only thing necessary is a gas
cost reimbursement for the submitter.

After the DKG result is submitted:

_DKG result submission expenditure = minimum(estimated gas price at submission, actual gas price during transaction) * gas spent on call_

The entire DKG result submission expenditure is returned to the submitter
from the _DKG fee pool_ of the operator contract.

The minimum of the gas price protects the beacon against malicious 
miner-submitters. If the submitter is also a miner, they can place any 
arbitrary gas price on the transaction. Without taking the minimum, 
miner-submitter would be able to steal from _DKG fee pool_ of the operator 
contract.

Any surplus between the _DKG fee pool_ of the operator contract and 
the actual cost of DKG result submission is returned back to the service 
contract. In the case when the entire DKG fails, the unspent fee will be 
transferred back to the service contract upon the next DKG triggered by the 
service contract.

The on-chain DKG result submission code needs to have all deterministic 
and time-bounded run paths that are independent of miner-controlled inputs. 
If the miner-submitter pays the gas price estimated by the price feed, but 
tricks the contract into consuming twice the gas as normal, they will be able 
to get twice the reimbursement as well. 

==== Cost estimates
todo: How do we estimate the various costs?

===== Gas price feed

A short-term gas price feed is required
to estimate the gas cost components.

The critical feature of the gas price feed is
that the feed price multiplied by a safety margin for fluctuations (e.g. 1.5)
should be sufficient for getting beacon entries processed
within the deadline under all circumstances.
The gas price estimate for an entry is set when the request is processed,
but the entry submission transaction will be sent later.

If actual gas prices rise to a level
where the feed price and margin are insufficient
for getting a transaction to be mined,
and stays there for the duration of the entry submission window,
the basic profit margin for the operators cannot be guaranteed.

However, this does not imply that high gas prices
would render the beacon inoperable.
The submitter's extra reward incentivizes submitting
even when the entry verification fee cannot cover the gas costs.
In the extreme,
avoiding the severe penalty for failure to produce an entry
will incentivize group members to pay the gas prices
up to the (theoretical) limit
where gas for the entry submission transaction
costs as much as the KEEP tokens at stake.

The exact implementation of this gas price feed
is out for scope for this RFC.

===== DKG cost estimate
How do we calculate the cost of running the DKG?

The gas required for DKG should be calculated.
DKG gas cost should include only DKG result submission. Ticket submission
costs are covered by the expected return from getting into a signing group.
Multiply DKG gas by gas estimate to get DKG cost estimate.
Use a DKG frequency divider _d_ to set the group creation rate;
once every _d_ entries on average.
Divide DKG cost estimate by _d_ to get DKG contribution for each entry.

The maximum DKG gas cost should be hardcoded in the operator contract.
The service contract takes the highest applicable gas cost from all operator
contracts being used and multiplies it by the fluctuation margin times gas price feed's estimate.

Because DKG is performed when sufficient gas money has accumulated,
fluctuations in gas prices don't need special consideration.
When gas costs are rising,
DKG gets performed less frequently
until prices (and thus gas cost contributions) stabilize.
As long as the fluctuation safety factor is sufficient
to cover the immediate rise in gas fees during DKG execution
the beacon is capable of generating new groups.
Similarly, when gas costs fall DKG gets triggered faster.

===== Entry verification fee
How do we calculate the gas required for entry verification?

Calculate gas required for verifying entry and associated support operations.
The maximum entry verification gas cost are hardcoded in the operator
contract. The service contract takes the highest applicable gas cost from all 
operator contracts being used and  multiplies it by the fluctuation margin 
(e.g. 1.5) times gas price feed's estimate to get entry verification fee.

==== Cleanup gas efficiency
How do we calculate the cost of cleanup or post processing?

As the gas cost of storing data in a previously zero field
and later zeroing it again (20,000 + 5,000 - 15,000 = 10,000)
exceeds the cost of modifying a nonzero field (5,000),
cleaning unnecessary fields would appear to increase operating costs
with little upside.

However, gas costs in the entry submission transaction
contribute 1.5 times as much to the effective price of beacon entries.
Thus the 10,000 gas net refund per field
is effectively worth 15,000 gas,
making both options equal to the requester.
The difference of 5,000 actual gas is effectively paid by the submitter
in the form of a lower _entry verification fee_.

TODO: Do we need the following?
Packing request data more densely,
where applicable,
could further reduce operating costs.

////
[bibliography]
== Related Links
////
