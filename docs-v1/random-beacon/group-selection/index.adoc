:toc: macro

= Random Beacon Group Selection

ifndef::yellowpaper[toc::[]]

The group selection protocol is intended to be
an interactive method of selecting candidate group _P_
from the set of all stakers _S_
given a pseudorandom seed value _V~i~_.

Functional interface:

inputs: _S, V~i~_

output: _P_

The protocol should:

. [[req-1]]produce a representative result,
where each staker's profit is proportional
to the number of tokens they have staked
. [[req-2]]produce a group _P_ of constant size _N_
. [[req-3]]not require an excessive amount of on-chain operations to perform
. [[req-4]]not be feasible for an adversary to manipulate

.Some terms
|===
|Term |Meaning

|Trenchcoating
|Several actors pooling up their stakes under one staker identity
to take advantage of rich-get-richer effects.
Thus what seems to be a large staker is actually
"a hundred small stakers in a trenchcoat".

|Blitzpantsing
|The inverse of trenchcoating; a single token holder dividing their stake
under multiple identities to avoid rich-get-poorer effects or to increase their
representation in groups.
This can increase profits above what is designed, or make certain attacks easier
to perform by making one actor more likely to control a group.
Thus what seems to be a large number of small stakers is actually a single
whale in an "inverse trenchcoat", or "blitzpants".

|Non-interactive
|A protocol is non-interactive if it can be performed without stakers
providing additional information.
Specifically, _S~i~_ can determine whether they are in _P_
without input from other stakers in _S_.

|Interactive
|An interactive protocol requires stakers to provide additional information
over what is available on-chain,
and then performs a deterministic algorithm to select a group
based on the information provided by the stakers.
In an interactive protocol _S~i~_ cannot know for sure
whether they are in _P_ before they receive the other stakers' input.

|Actual staker
|An actor holding and staking at least _MINIMUM_STAKE_ tokens,
represented as _S~i~_.
Each actual staker corresponds to one or more virtual stakers.
An actual staker can be represented multiple times in a candidate group,
through multiple virtual stakers.
The surplus tokens above _n * MINIMUM_STAKE_ (for an integer _n_)
do not impact the actual staker's ability to create virtual stakers.

|Virtual staker
|A construct used to simplify
the mathematical requirements of the group selection protocol
and ensure blitzpantsing provides no advantage.

Each virtual staker represents exactly _MINIMUM_STAKE_ tokens
staked by some actual staker who may or may not be anonymous.
A virtual staker may only ever be included once in a candidate group,
and _N_ properly denotes the number of virtual stakers in _P_.

|Ticket
|A message containing a pseudorandomly generated value _W~k~_ which is used to 
 determine whether a given _virtual staker_ is eligible for the group _P_ (the
 lowest _N_ tickets will be chosen) and a proof of the validity of the value

|Threshold
|The value of the highest-valued ticket in _P_

|_Space~tickets~_
|Is a space consisting of all possible tickets. It is strongly related
with a pseudorandom function that is used for ticket generation.
Currently the _Space~tickets~_ is equal to _2^64^- 1_, which is due
to selection of the first 8 bytes of keccak256
as our pseudorandom function.

|_Supply~tokens~_
|Is the total number of tokens which are going to be supplied during the project
lifetime and is set to 10^9.

|Natural threshold
|_Threshold~nat~ = floor(N * Space~tickets~ / (Supply~tokens~ / MINIMUM_STAKE))_

In other words, the natural threshold is the value _N_ virtual stakers' tickets
would be expected to fall below if the tokens were optimally staked, and the
tickets' values were evenly distributed in the domain of the pseudorandom
function.

Usually _Threshold~P~ > Threshold~nat~_ as not all tokens will be staked and the
distribution of stakes will not be optimal.
|===

== Setup

When a staker _S~j~_ is created, the following values are determined:

- _Stake~j~_: the amount of tokens staked by _S~j~_ and thus locked up until the
  staker is destroyed 
- _Weight~j~= floor(Stake~j~ / MINIMUM_STAKE)_: the staking weight of _S~j~_;
  how many virtual stakers can represent _S~j~_ 
- _Address~j~_: the operator address of _S~j~_

== Protocol

A new output _V~i~_ is generated by the random beacon. This triggers the
selection of a new candidate group.

=== Phase 1: ticket calculation

_S~j~_ calculates _Ticket~k~ = (value~k~, vs, Address~j~)_ where:

- the ticket value is calculated as _value~k~ = prf(V~i~, Address~j~, vs)_
- the virtual staker number _vs_ is within the range _1 <= vs <= Weight~j~_
- the staker weight _Weight~j~_ is correct for the operator address _Address~j~_

=== Phase 2: ticket submission

==== Phase 2a: initial ticket submission

Each staker whose _value~k~ < Threshold~nat~_ on one or more _Ticket~k~_ publishes
the ticket/s.

The operator contract checks the validity of each submitted ticket
by querying the staking contract
for the stake available to the operator in the ticket,
calculating the corresponding staker weight,
checking that the virtual staker index _vs_ is within the allowed bounds,
and verifying that _value~k~_ is correct.
Invalid tickets are rejected.

Phase 2a ends when _TICKET_INITIAL_TIMEOUT_ is reached.

==== Phase 2b: reactive ticket submission

If the number of tickets received in phase 2a is less than _N_, the stakers
whose tickets did not fall below the natural threshold will publish theirs.

Tickets should ideally be published in order, to reduce the costs of ticket
submission on the stakers. For this, it is recommended that tickets where
_W~k~ = x * Threshold~nat~_ be submitted at time _x * TICKET_INITIAL_TIMEOUT_,
IFF the number of tickets below _W~k~_ is less than _N_.

When tickets are published in order, the number of unnecessary transactions can
be minimized, which benefits the stakers. Thus it would be in each staker's
interests to follow the regular order. This, however, is only a recommendation
and tickets submitted at different times should not be rejected.

Phase 2b ends when _TICKET_SUBMISSION_TIMEOUT_ is reached.

=== Phase 3: threshold determination

After all potentially eligible tickets have been submitted,
the _N_ tickets with the lowest values for _value~k~_
will be selected into the group _P_.
The corresponding virtual stakers
will be automatically assigned to form the group
and no further interaction is necessary.
DKG will be performed.

== Notes and rationale:

=== Virtual stakers

Due to the use of virtual stakers, the stakers will be expected to be
represented in _P_ with a probability proportional to their _Weight~j~_; a
staker staking at least _2 * MINIMUM_STAKE_ may also be selected multiple times
for the same group.

This makes the result representative and ensures that neither blitzpantsing nor
trenchcoating will provide the staker greater profits than they could acquire
otherwise (<<req-1,requirement 1>>), with the exception that pooling token
amounts below _MINIMUM_STAKE_ and sharing the risk and profits would enable the
utilization of smaller holders' tokens or surplus tokens from regular stakers.
This form of trenchcoating is arguably either neutral or beneficial, and in any
case it does not violate proportionality of rewards.

=== Interactive protocol

There would be two simple non-interactive options but neither is able to
satisfy all of the requirements:

1. One method would be to have each _S~j~_ calculate a pseudorandom value
_Seed~j~_, and then everybody whose _Seed~j~ < Threshold~i~_ is in _P_.
_Threshold~i~_ would be calculated using public information,
eg. by _Threshold~i~ = floor(N * Space~tickets~ / |S|)_ for a 256-bit _Seed~j~_.
However, this means that due to random chance, most of the time _|P| != N_.
This violates <<req-2,requirement 2>>.
2. Alternatively each staker could present  some kind of a hashed value
_Hash~j~_ so that whether _S~j~_ is in _P_ can be determined publicly
by _f(V~i~, Hash~j~, S, N) -> Bool_.
This cannot work, because then anybody could
calculate _f(V~m~, Hash~j~, S, N)_ for a large number of different values _V~m~_
and see how often _S~j~_ ends up eligible for the candidate group.
Due to <<req-1,requirement 1>> this necessarily reveals how much _S~j~_ has staked
to an arbitrary degree of precision, violating <<req-5,requirement 5>>.

These constraints seem inherent in the problem, and thus an interactive protocol
appears necessary. The aforementioned issues can be avoided by having _S~j~_
calculate a value _W~j~_, so that _S~j~_ will be in _P_ if _Threshold~P~ > W~j~_.

[source, python]
----
all_tickets = []
for S_j in S:
    for vs in [1..Weight_j]:
        W_k = prf(V_i, Q_j, vs)
        all_tickets.append(Ticket(W_k, proof(W_k))

Threshold_P = max(all_tickets.map(fn(t): t.W_k).sort().take(N)
----

Assuming once again 256-bit values for _W~k~_ and _Threshold~P~_,
_S~j~_ can predict their expected probability of being in _P_
by calculating how likely it would be that _Threshold~P~ > W~k~_.
Then _S~j~_ can broadcast their input only if there seems to be
a realistic chance that they could be selected.
If it seems likely that _Threshold~P~ < W~k~_,
_S~j~_ can refrain from broadcasting _W~k~_ and only monitor the situation,
reacting if it seems that few stakers' ticket values are falling under
the estimated threshold.

== Alternative off-chain protocol

This protocol was not chosen but is included in the yellowpaper to illustrate
reasoning and what alternatives were considered

=== Protocol

Each staker calculates their tickets

Each staker who has one or more ticket/s that may be eligible for the group
broadcasts the ticket, including proof of its validity

Other stakers check broadcasted tickets for validity; if an invalid ticket is
broadcast, the ticket is rejected

After _T~selection~_ has elapsed, stakers following the broadcast channel
select _N_ tickets with the lowest value to form the candidate group

Each member of the candidate group BLS-signs a message
containing all the tickets of the group and the threshold

This is the _Group Formation Message_, signed by _[P~1~..P~N~]_ to ensure the
integrity of the group selection process. Because all participants are required
to sign the _Group Formation Message_, the group composition cannot be
manipulated later.

The members of _P_ perform DKG; at the end of DKG the final message contains:

- DKG output, similarly BLS signed
- group formation message
- aggregate BLS signature of the above

On-chain receives DKG conclusion message, and:

- checks that all stakers in the group formation message are valid
- checks the proofs supplied in the tickets
- checks that all tickets are below the threshold
- checks that the group formation message is signed by everyone in _P_
and that the DKG output is signed by at least _H_ members of _P_

If two or more valid group formations are presented,
the one with the lowest threshold wins

Any virtual staker is only permitted to sign a group formation message for one
group (any given ticket may only be used for one group); if a ticket is used for
two or more different groups, the staker should be penalized

Submitting only a group formation message without DKG conclusion is also valid
and signifies that the group was formed, but DKG did not reach quorum (_H_
participants would not agree on any given result)

However, if a group formation message is published it may be superseded by a
valid DKG conclusion message for the same group

If a member of group _P_ with _Threshold~P~_ publishes a valid group formation
message, and a member of group _P'_ with _Threshold~P'~_ publishes a valid group
formation and DKG conclusion message:

- if _P âˆ© P' != {}_, the stakers who signed both group formation messages should
  be penalized, but the groups _P_ and _P'_ may still be valid (this is to
  prevent an attack where one member of an unfavorable group prevents the group
  creation by signing and publishing a different, unrelated group creation message)
- if _Threshold~P~ > Threshold~P'~_, group _P'_ is to be considered the correct
  group and the group selection is to be deemed a success.
- if _Threshold~P~ < Threshold~P'~_, group _P_ is to be considered the correct
  group and the group selection is to be deemed a failure.
- if _Threshold~P~ = Threshold~P'~_, group _P'_ is to be considered the correct group


=== Notes

The off-chain protocol is much more complex to secure effectively, and a variety
of attacks on the group composition need to be addressed.
