{
  "language": "Solidity",
  "sources": {
    "contracts/api/IWalletOwner.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n//\n// ▓▓▌ ▓▓ ▐▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▄\n// ▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n//   ▓▓▓▓▓▓    ▓▓▓▓▓▓▓▀    ▐▓▓▓▓▓▓    ▐▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n//   ▓▓▓▓▓▓▄▄▓▓▓▓▓▓▓▀      ▐▓▓▓▓▓▓▄▄▄▄         ▓▓▓▓▓▓▄▄▄▄         ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n//   ▓▓▓▓▓▓▓▓▓▓▓▓▓▀        ▐▓▓▓▓▓▓▓▓▓▓         ▓▓▓▓▓▓▓▓▓▓         ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n//   ▓▓▓▓▓▓▀▀▓▓▓▓▓▓▄       ▐▓▓▓▓▓▓▀▀▀▀         ▓▓▓▓▓▓▀▀▀▀         ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▀\n//   ▓▓▓▓▓▓   ▀▓▓▓▓▓▓▄     ▐▓▓▓▓▓▓     ▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌\n// ▓▓▓▓▓▓▓▓▓▓ █▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▓▓\n// ▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▓▓\n//\n//                           Trust math, not hardware.\n\npragma solidity 0.8.17;\n\ninterface IWalletOwner {\n    /// @notice Callback function executed once a new wallet is created.\n    /// @dev Should be callable only by the Wallet Registry.\n    /// @param walletID Wallet's unique identifier.\n    /// @param publicKeyY Wallet's public key's X coordinate.\n    /// @param publicKeyY Wallet's public key's Y coordinate.\n    function __ecdsaWalletCreatedCallback(\n        bytes32 walletID,\n        bytes32 publicKeyX,\n        bytes32 publicKeyY\n    ) external;\n\n    /// @notice Callback function executed once a wallet heartbeat failure\n    ///         is detected.\n    /// @dev Should be callable only by the Wallet Registry.\n    /// @param walletID Wallet's unique identifier.\n    /// @param publicKeyY Wallet's public key's X coordinate.\n    /// @param publicKeyY Wallet's public key's Y coordinate.\n    function __ecdsaWalletHeartbeatFailedCallback(\n        bytes32 walletID,\n        bytes32 publicKeyX,\n        bytes32 publicKeyY\n    ) external;\n}\n"
    },
    "contracts/WalletRegistryGovernance.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n//\n// ▓▓▌ ▓▓ ▐▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▄\n// ▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n//   ▓▓▓▓▓▓    ▓▓▓▓▓▓▓▀    ▐▓▓▓▓▓▓    ▐▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n//   ▓▓▓▓▓▓▄▄▓▓▓▓▓▓▓▀      ▐▓▓▓▓▓▓▄▄▄▄         ▓▓▓▓▓▓▄▄▄▄         ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n//   ▓▓▓▓▓▓▓▓▓▓▓▓▓▀        ▐▓▓▓▓▓▓▓▓▓▓         ▓▓▓▓▓▓▓▓▓▓         ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n//   ▓▓▓▓▓▓▀▀▓▓▓▓▓▓▄       ▐▓▓▓▓▓▓▀▀▀▀         ▓▓▓▓▓▓▀▀▀▀         ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▀\n//   ▓▓▓▓▓▓   ▀▓▓▓▓▓▓▄     ▐▓▓▓▓▓▓     ▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌\n// ▓▓▓▓▓▓▓▓▓▓ █▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▓▓\n// ▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▓▓\n//\n//\n\npragma solidity 0.8.17;\n\nimport \"./WalletRegistry.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@keep-network/random-beacon/contracts/ReimbursementPool.sol\";\n\nimport {IWalletOwner} from \"./api/IWalletOwner.sol\";\nimport {IRandomBeacon} from \"@keep-network/random-beacon/contracts/api/IRandomBeacon.sol\";\n\n/// @title Wallet Registry Governance\n/// @notice Owns the `WalletRegistry` contract and is responsible for updating\n///         its governable parameters in respect to the governance delay.\ncontract WalletRegistryGovernance is Ownable {\n    uint256 public newGovernanceDelay;\n    uint256 public governanceDelayChangeInitiated;\n\n    address public newWalletRegistryGovernance;\n    uint256 public walletRegistryGovernanceTransferInitiated;\n\n    address public newWalletOwner;\n    uint256 public walletOwnerChangeInitiated;\n\n    uint96 public newMinimumAuthorization;\n    uint256 public minimumAuthorizationChangeInitiated;\n\n    uint64 public newAuthorizationDecreaseDelay;\n    uint256 public authorizationDecreaseDelayChangeInitiated;\n\n    uint64 public newAuthorizationDecreaseChangePeriod;\n    uint256 public authorizationDecreaseChangePeriodChangeInitiated;\n\n    uint96 public newMaliciousDkgResultSlashingAmount;\n    uint256 public maliciousDkgResultSlashingAmountChangeInitiated;\n\n    uint256 public newMaliciousDkgResultNotificationRewardMultiplier;\n    uint256\n        public maliciousDkgResultNotificationRewardMultiplierChangeInitiated;\n\n    uint256 public newSortitionPoolRewardsBanDuration;\n    uint256 public sortitionPoolRewardsBanDurationChangeInitiated;\n\n    uint256 public newDkgSeedTimeout;\n    uint256 public dkgSeedTimeoutChangeInitiated;\n\n    uint256 public newDkgResultChallengePeriodLength;\n    uint256 public dkgResultChallengePeriodLengthChangeInitiated;\n\n    uint256 public newDkgResultChallengeExtraGas;\n    uint256 public dkgResultChallengeExtraGasChangeInitiated;\n\n    uint256 public newDkgResultSubmissionTimeout;\n    uint256 public dkgResultSubmissionTimeoutChangeInitiated;\n\n    uint256 public newSubmitterPrecedencePeriodLength;\n    uint256 public dkgSubmitterPrecedencePeriodLengthChangeInitiated;\n\n    uint256 public newDkgResultSubmissionGas;\n    uint256 public dkgResultSubmissionGasChangeInitiated;\n\n    uint256 public newDkgResultApprovalGasOffset;\n    uint256 public dkgResultApprovalGasOffsetChangeInitiated;\n\n    uint256 public newNotifyOperatorInactivityGasOffset;\n    uint256 public notifyOperatorInactivityGasOffsetChangeInitiated;\n\n    uint256 public newNotifySeedTimeoutGasOffset;\n    uint256 public notifySeedTimeoutGasOffsetChangeInitiated;\n\n    uint256 public newNotifyDkgTimeoutNegativeGasOffset;\n    uint256 public notifyDkgTimeoutNegativeGasOffsetChangeInitiated;\n\n    address payable public newReimbursementPool;\n    uint256 public reimbursementPoolChangeInitiated;\n\n    WalletRegistry public immutable walletRegistry;\n\n    uint256 public governanceDelay;\n\n    event GovernanceDelayUpdateStarted(\n        uint256 governanceDelay,\n        uint256 timestamp\n    );\n    event GovernanceDelayUpdated(uint256 governanceDelay);\n\n    event WalletRegistryGovernanceTransferStarted(\n        address newWalletRegistryGovernance,\n        uint256 timestamp\n    );\n    event WalletRegistryGovernanceTransferred(\n        address newWalletRegistryGovernance\n    );\n\n    event WalletOwnerUpdateStarted(address walletOwner, uint256 timestamp);\n    event WalletOwnerUpdated(address walletOwner);\n\n    event MinimumAuthorizationUpdateStarted(\n        uint96 minimumAuthorization,\n        uint256 timestamp\n    );\n    event MinimumAuthorizationUpdated(uint96 minimumAuthorization);\n\n    event AuthorizationDecreaseDelayUpdateStarted(\n        uint64 authorizationDecreaseDelay,\n        uint256 timestamp\n    );\n    event AuthorizationDecreaseDelayUpdated(uint64 authorizationDecreaseDelay);\n\n    event AuthorizationDecreaseChangePeriodUpdateStarted(\n        uint64 authorizationDecreaseChangePeriod,\n        uint256 timestamp\n    );\n\n    event AuthorizationDecreaseChangePeriodUpdated(\n        uint64 authorizationDecreaseChangePeriod\n    );\n\n    event MaliciousDkgResultSlashingAmountUpdateStarted(\n        uint256 maliciousDkgResultSlashingAmount,\n        uint256 timestamp\n    );\n    event MaliciousDkgResultSlashingAmountUpdated(\n        uint256 maliciousDkgResultSlashingAmount\n    );\n\n    event MaliciousDkgResultNotificationRewardMultiplierUpdateStarted(\n        uint256 maliciousDkgResultNotificationRewardMultiplier,\n        uint256 timestamp\n    );\n    event MaliciousDkgResultNotificationRewardMultiplierUpdated(\n        uint256 maliciousDkgResultNotificationRewardMultiplier\n    );\n\n    event SortitionPoolRewardsBanDurationUpdateStarted(\n        uint256 sortitionPoolRewardsBanDuration,\n        uint256 timestamp\n    );\n    event SortitionPoolRewardsBanDurationUpdated(\n        uint256 sortitionPoolRewardsBanDuration\n    );\n\n    event DkgSeedTimeoutUpdateStarted(\n        uint256 dkgSeedTimeout,\n        uint256 timestamp\n    );\n    event DkgSeedTimeoutUpdated(uint256 dkgSeedTimeout);\n\n    event DkgResultChallengePeriodLengthUpdateStarted(\n        uint256 dkgResultChallengePeriodLength,\n        uint256 timestamp\n    );\n    event DkgResultChallengePeriodLengthUpdated(\n        uint256 dkgResultChallengePeriodLength\n    );\n\n    event DkgResultChallengeExtraGasUpdateStarted(\n        uint256 dkgResultChallengeExtraGas,\n        uint256 timestamp\n    );\n    event DkgResultChallengeExtraGasUpdated(uint256 dkgResultChallengeExtraGas);\n\n    event DkgResultSubmissionTimeoutUpdateStarted(\n        uint256 dkgResultSubmissionTimeout,\n        uint256 timestamp\n    );\n    event DkgResultSubmissionTimeoutUpdated(uint256 dkgResultSubmissionTimeout);\n\n    event DkgSubmitterPrecedencePeriodLengthUpdateStarted(\n        uint256 submitterPrecedencePeriodLength,\n        uint256 timestamp\n    );\n    event DkgSubmitterPrecedencePeriodLengthUpdated(\n        uint256 submitterPrecedencePeriodLength\n    );\n\n    event DkgResultSubmissionGasUpdateStarted(\n        uint256 dkgResultSubmissionGas,\n        uint256 timestamp\n    );\n    event DkgResultSubmissionGasUpdated(uint256 dkgResultSubmissionGas);\n\n    event DkgResultApprovalGasOffsetUpdateStarted(\n        uint256 dkgResultApprovalGasOffset,\n        uint256 timestamp\n    );\n    event DkgResultApprovalGasOffsetUpdated(uint256 dkgResultApprovalGasOffset);\n\n    event NotifyOperatorInactivityGasOffsetUpdateStarted(\n        uint256 notifyOperatorInactivityGasOffset,\n        uint256 timestamp\n    );\n    event NotifyOperatorInactivityGasOffsetUpdated(\n        uint256 notifyOperatorInactivityGasOffset\n    );\n\n    event NotifySeedTimeoutGasOffsetUpdateStarted(\n        uint256 notifySeedTimeoutGasOffset,\n        uint256 timestamp\n    );\n    event NotifySeedTimeoutGasOffsetUpdated(uint256 notifySeedTimeoutGasOffset);\n\n    event NotifyDkgTimeoutNegativeGasOffsetUpdateStarted(\n        uint256 notifyDkgTimeoutNegativeGasOffset,\n        uint256 timestamp\n    );\n    event NotifyDkgTimeoutNegativeGasOffsetUpdated(\n        uint256 notifyDkgTimeoutNegativeGasOffset\n    );\n\n    event ReimbursementPoolUpdateStarted(\n        address reimbursementPool,\n        uint256 timestamp\n    );\n    event ReimbursementPoolUpdated(address reimbursementPool);\n\n    /// @notice Reverts if called before the governance delay elapses.\n    /// @param changeInitiatedTimestamp Timestamp indicating the beginning\n    ///        of the change.\n    modifier onlyAfterGovernanceDelay(uint256 changeInitiatedTimestamp) {\n        /* solhint-disable not-rely-on-time */\n        require(changeInitiatedTimestamp > 0, \"Change not initiated\");\n        require(\n            block.timestamp - changeInitiatedTimestamp >= governanceDelay,\n            \"Governance delay has not elapsed\"\n        );\n        _;\n        /* solhint-enable not-rely-on-time */\n    }\n\n    constructor(WalletRegistry _walletRegistry, uint256 _governanceDelay) {\n        walletRegistry = _walletRegistry;\n        governanceDelay = _governanceDelay;\n    }\n\n    /// @notice Upgrades the random beacon.\n    /// @dev Can be called only by the contract owner.\n    /// @param _newRandomBeacon New random beacon address\n    function upgradeRandomBeacon(address _newRandomBeacon) external onlyOwner {\n        require(\n            _newRandomBeacon != address(0),\n            \"New random beacon address cannot be zero\"\n        );\n\n        walletRegistry.upgradeRandomBeacon(IRandomBeacon(_newRandomBeacon));\n    }\n\n    /// @notice Initializes the Wallet Owner's address.\n    /// @dev Can be called only by the contract owner. It can be called only if\n    ///      walletOwner has not been set before. It doesn't enforce a governance\n    ///      delay for the initial update. Any subsequent updates should be performed\n    ///      with beginWalletOwnerUpdate/finalizeWalletOwnerUpdate with respect\n    ///      of a governance delay.\n    /// @param _walletOwner The Wallet Owner's address\n    function initializeWalletOwner(address _walletOwner) external onlyOwner {\n        require(\n            address(walletRegistry.walletOwner()) == address(0),\n            \"Wallet Owner already initialized\"\n        );\n        require(\n            _walletOwner != address(0),\n            \"Wallet Owner address cannot be zero\"\n        );\n\n        walletRegistry.updateWalletOwner(IWalletOwner(_walletOwner));\n    }\n\n    /// @notice Begins the governance delay update process.\n    /// @dev Can be called only by the contract owner.\n    /// @param _newGovernanceDelay New governance delay\n    function beginGovernanceDelayUpdate(uint256 _newGovernanceDelay)\n        external\n        onlyOwner\n    {\n        newGovernanceDelay = _newGovernanceDelay;\n        /* solhint-disable not-rely-on-time */\n        governanceDelayChangeInitiated = block.timestamp;\n        emit GovernanceDelayUpdateStarted(_newGovernanceDelay, block.timestamp);\n        /* solhint-enable not-rely-on-time */\n    }\n\n    /// @notice Finalizes the governance delay update process.\n    /// @dev Can be called only by the contract owner, after the governance\n    ///      delay elapses.\n    function finalizeGovernanceDelayUpdate()\n        external\n        onlyOwner\n        onlyAfterGovernanceDelay(governanceDelayChangeInitiated)\n    {\n        emit GovernanceDelayUpdated(newGovernanceDelay);\n        governanceDelay = newGovernanceDelay;\n        governanceDelayChangeInitiated = 0;\n        newGovernanceDelay = 0;\n    }\n\n    /// @notice Begins the wallet registry governance transfer process.\n    /// @dev Can be called only by the contract owner.\n    function beginWalletRegistryGovernanceTransfer(\n        address _newWalletRegistryGovernance\n    ) external onlyOwner {\n        require(\n            address(_newWalletRegistryGovernance) != address(0),\n            \"New wallet registry governance address cannot be zero\"\n        );\n        newWalletRegistryGovernance = _newWalletRegistryGovernance;\n        /* solhint-disable not-rely-on-time */\n        walletRegistryGovernanceTransferInitiated = block.timestamp;\n        emit WalletRegistryGovernanceTransferStarted(\n            _newWalletRegistryGovernance,\n            block.timestamp\n        );\n        /* solhint-enable not-rely-on-time */\n    }\n\n    /// @notice Finalizes the wallet registry governance transfer process.\n    /// @dev Can be called only by the contract owner, after the governance\n    ///      delay elapses.\n    function finalizeWalletRegistryGovernanceTransfer()\n        external\n        onlyOwner\n        onlyAfterGovernanceDelay(walletRegistryGovernanceTransferInitiated)\n    {\n        emit WalletRegistryGovernanceTransferred(newWalletRegistryGovernance);\n        // slither-disable-next-line reentrancy-no-eth\n        walletRegistry.transferGovernance(newWalletRegistryGovernance);\n        walletRegistryGovernanceTransferInitiated = 0;\n        newWalletRegistryGovernance = address(0);\n    }\n\n    /// @notice Begins the wallet owner update process.\n    /// @dev Can be called only by the contract owner.\n    /// @param _newWalletOwner New wallet owner address\n    function beginWalletOwnerUpdate(address _newWalletOwner)\n        external\n        onlyOwner\n    {\n        require(\n            address(_newWalletOwner) != address(0),\n            \"New wallet owner address cannot be zero\"\n        );\n        /* solhint-disable not-rely-on-time */\n        newWalletOwner = _newWalletOwner;\n        walletOwnerChangeInitiated = block.timestamp;\n        emit WalletOwnerUpdateStarted(_newWalletOwner, block.timestamp);\n        /* solhint-enable not-rely-on-time */\n    }\n\n    /// @notice Finalizes the wallet owner update process.\n    /// @dev Can be called only by the contract owner, after the governance\n    ///      delay elapses.\n    function finalizeWalletOwnerUpdate()\n        external\n        onlyOwner\n        onlyAfterGovernanceDelay(walletOwnerChangeInitiated)\n    {\n        emit WalletOwnerUpdated(newWalletOwner);\n        // slither-disable-next-line reentrancy-no-eth\n        walletRegistry.updateWalletOwner(IWalletOwner(newWalletOwner));\n        walletOwnerChangeInitiated = 0;\n        newWalletOwner = address(0);\n    }\n\n    /// @notice Begins the minimum authorization amount update process.\n    /// @dev Can be called only by the contract owner.\n    /// @param _newMinimumAuthorization New minimum authorization amount.\n    function beginMinimumAuthorizationUpdate(uint96 _newMinimumAuthorization)\n        external\n        onlyOwner\n    {\n        /* solhint-disable not-rely-on-time */\n        newMinimumAuthorization = _newMinimumAuthorization;\n        minimumAuthorizationChangeInitiated = block.timestamp;\n        emit MinimumAuthorizationUpdateStarted(\n            _newMinimumAuthorization,\n            block.timestamp\n        );\n        /* solhint-enable not-rely-on-time */\n    }\n\n    /// @notice Finalizes the minimum authorization amount update process.\n    /// @dev Can be called only by the contract owner, after the governance\n    ///      delay elapses.\n    function finalizeMinimumAuthorizationUpdate()\n        external\n        onlyOwner\n        onlyAfterGovernanceDelay(minimumAuthorizationChangeInitiated)\n    {\n        emit MinimumAuthorizationUpdated(newMinimumAuthorization);\n        (\n            ,\n            uint64 authorizationDecreaseDelay,\n            uint64 authorizationDecreaseChangePeriod\n        ) = walletRegistry.authorizationParameters();\n        // slither-disable-next-line reentrancy-no-eth\n        walletRegistry.updateAuthorizationParameters(\n            newMinimumAuthorization,\n            authorizationDecreaseDelay,\n            authorizationDecreaseChangePeriod\n        );\n        minimumAuthorizationChangeInitiated = 0;\n        newMinimumAuthorization = 0;\n    }\n\n    /// @notice Begins the authorization decrease delay update process.\n    /// @dev Can be called only by the contract owner.\n    /// @param _newAuthorizationDecreaseDelay New authorization decrease delay\n    function beginAuthorizationDecreaseDelayUpdate(\n        uint64 _newAuthorizationDecreaseDelay\n    ) external onlyOwner {\n        /* solhint-disable not-rely-on-time */\n        newAuthorizationDecreaseDelay = _newAuthorizationDecreaseDelay;\n        authorizationDecreaseDelayChangeInitiated = block.timestamp;\n        emit AuthorizationDecreaseDelayUpdateStarted(\n            _newAuthorizationDecreaseDelay,\n            block.timestamp\n        );\n        /* solhint-enable not-rely-on-time */\n    }\n\n    /// @notice Finalizes the authorization decrease delay update process.\n    /// @dev Can be called only by the contract owner, after the governance\n    ///      delay elapses.\n    function finalizeAuthorizationDecreaseDelayUpdate()\n        external\n        onlyOwner\n        onlyAfterGovernanceDelay(authorizationDecreaseDelayChangeInitiated)\n    {\n        emit AuthorizationDecreaseDelayUpdated(newAuthorizationDecreaseDelay);\n        (\n            uint96 minimumAuthorization,\n            uint64 authorizationDecreaseChangePeriod,\n\n        ) = walletRegistry.authorizationParameters();\n        // slither-disable-next-line reentrancy-no-eth\n        walletRegistry.updateAuthorizationParameters(\n            minimumAuthorization,\n            newAuthorizationDecreaseDelay,\n            authorizationDecreaseChangePeriod\n        );\n        authorizationDecreaseDelayChangeInitiated = 0;\n        newAuthorizationDecreaseDelay = 0;\n    }\n\n    /// @notice Begins the authorization decrease change period update process.\n    /// @dev Can be called only by the contract owner.\n    /// @param _newAuthorizationDecreaseChangePeriod New authorization decrease change period\n    function beginAuthorizationDecreaseChangePeriodUpdate(\n        uint64 _newAuthorizationDecreaseChangePeriod\n    ) external onlyOwner {\n        /* solhint-disable not-rely-on-time */\n        newAuthorizationDecreaseChangePeriod = _newAuthorizationDecreaseChangePeriod;\n        authorizationDecreaseChangePeriodChangeInitiated = block.timestamp;\n        emit AuthorizationDecreaseChangePeriodUpdateStarted(\n            _newAuthorizationDecreaseChangePeriod,\n            block.timestamp\n        );\n        /* solhint-enable not-rely-on-time */\n    }\n\n    /// @notice Finalizes the authorization decrease change period update process.\n    /// @dev Can be called only by the contract owner, after the governance\n    ///      delay elapses.\n    function finalizeAuthorizationDecreaseChangePeriodUpdate()\n        external\n        onlyOwner\n        onlyAfterGovernanceDelay(\n            authorizationDecreaseChangePeriodChangeInitiated\n        )\n    {\n        emit AuthorizationDecreaseChangePeriodUpdated(\n            newAuthorizationDecreaseChangePeriod\n        );\n        (\n            uint96 minimumAuthorization,\n            uint64 authorizationDecreaseDelay,\n\n        ) = walletRegistry.authorizationParameters();\n        // slither-disable-next-line reentrancy-no-eth\n        walletRegistry.updateAuthorizationParameters(\n            minimumAuthorization,\n            authorizationDecreaseDelay,\n            newAuthorizationDecreaseChangePeriod\n        );\n        authorizationDecreaseChangePeriodChangeInitiated = 0;\n        newAuthorizationDecreaseChangePeriod = 0;\n    }\n\n    /// @notice Begins the malicious DKG result slashing amount update process.\n    /// @dev Can be called only by the contract owner.\n    /// @param _newMaliciousDkgResultSlashingAmount New malicious DKG result\n    ///        slashing amount\n    function beginMaliciousDkgResultSlashingAmountUpdate(\n        uint96 _newMaliciousDkgResultSlashingAmount\n    ) external onlyOwner {\n        /* solhint-disable not-rely-on-time */\n        newMaliciousDkgResultSlashingAmount = _newMaliciousDkgResultSlashingAmount;\n        maliciousDkgResultSlashingAmountChangeInitiated = block.timestamp;\n        emit MaliciousDkgResultSlashingAmountUpdateStarted(\n            _newMaliciousDkgResultSlashingAmount,\n            block.timestamp\n        );\n        /* solhint-enable not-rely-on-time */\n    }\n\n    /// @notice Finalizes the malicious DKG result slashing amount update\n    ///         process.\n    /// @dev Can be called only by the contract owner, after the governance\n    ///      delay elapses.\n    function finalizeMaliciousDkgResultSlashingAmountUpdate()\n        external\n        onlyOwner\n        onlyAfterGovernanceDelay(\n            maliciousDkgResultSlashingAmountChangeInitiated\n        )\n    {\n        emit MaliciousDkgResultSlashingAmountUpdated(\n            newMaliciousDkgResultSlashingAmount\n        );\n        // slither-disable-next-line reentrancy-no-eth\n        walletRegistry.updateSlashingParameters(\n            newMaliciousDkgResultSlashingAmount\n        );\n        maliciousDkgResultSlashingAmountChangeInitiated = 0;\n        newMaliciousDkgResultSlashingAmount = 0;\n    }\n\n    /// @notice Begins the DKG malicious result notification reward multiplier\n    ///         update process.\n    /// @dev Can be called only by the contract owner.\n    /// @param _newMaliciousDkgResultNotificationRewardMultiplier New DKG\n    ///        malicious result notification reward multiplier.\n    function beginMaliciousDkgResultNotificationRewardMultiplierUpdate(\n        uint256 _newMaliciousDkgResultNotificationRewardMultiplier\n    ) external onlyOwner {\n        /* solhint-disable not-rely-on-time */\n        require(\n            _newMaliciousDkgResultNotificationRewardMultiplier <= 100,\n            \"Maximum value is 100\"\n        );\n\n        newMaliciousDkgResultNotificationRewardMultiplier = _newMaliciousDkgResultNotificationRewardMultiplier;\n        maliciousDkgResultNotificationRewardMultiplierChangeInitiated = block\n            .timestamp;\n        emit MaliciousDkgResultNotificationRewardMultiplierUpdateStarted(\n            _newMaliciousDkgResultNotificationRewardMultiplier,\n            block.timestamp\n        );\n        /* solhint-enable not-rely-on-time */\n    }\n\n    /// @notice Finalizes the DKG malicious result notification reward\n    ///         multiplier update process.\n    /// @dev Can be called only by the contract owner, after the governance\n    ///      delay elapses.\n    function finalizeMaliciousDkgResultNotificationRewardMultiplierUpdate()\n        external\n        onlyOwner\n        onlyAfterGovernanceDelay(\n            maliciousDkgResultNotificationRewardMultiplierChangeInitiated\n        )\n    {\n        emit MaliciousDkgResultNotificationRewardMultiplierUpdated(\n            newMaliciousDkgResultNotificationRewardMultiplier\n        );\n        (, uint256 sortitionPoolRewardsBanDuration) = walletRegistry\n            .rewardParameters();\n        // slither-disable-next-line reentrancy-no-eth\n        walletRegistry.updateRewardParameters(\n            newMaliciousDkgResultNotificationRewardMultiplier,\n            sortitionPoolRewardsBanDuration\n        );\n        maliciousDkgResultNotificationRewardMultiplierChangeInitiated = 0;\n        newMaliciousDkgResultNotificationRewardMultiplier = 0;\n    }\n\n    /// @notice Begins the dkg result submission gas update process.\n    /// @dev Can be called only by the contract owner.\n    /// @param _newDkgResultSubmissionGas New DKG result submission gas.\n    function beginDkgResultSubmissionGasUpdate(\n        uint256 _newDkgResultSubmissionGas\n    ) external onlyOwner {\n        /* solhint-disable not-rely-on-time */\n        newDkgResultSubmissionGas = _newDkgResultSubmissionGas;\n        dkgResultSubmissionGasChangeInitiated = block.timestamp;\n        emit DkgResultSubmissionGasUpdateStarted(\n            _newDkgResultSubmissionGas,\n            block.timestamp\n        );\n        /* solhint-enable not-rely-on-time */\n    }\n\n    /// @notice Finalizes the dkg result submission gas update process.\n    /// @dev Can be called only by the contract owner, after the governance\n    ///      delay elapses.\n    function finalizeDkgResultSubmissionGasUpdate()\n        external\n        onlyOwner\n        onlyAfterGovernanceDelay(dkgResultSubmissionGasChangeInitiated)\n    {\n        emit DkgResultSubmissionGasUpdated(newDkgResultSubmissionGas);\n        (\n            ,\n            uint256 dkgResultApprovalGasOffset,\n            uint256 notifyOperatorInactivityGasOffset,\n            uint256 notifySeedTimeoutGasOffset,\n            uint256 notifyDkgTimeoutNegativeGasOffset\n        ) = walletRegistry.gasParameters();\n        // slither-disable-next-line reentrancy-no-eth\n        walletRegistry.updateGasParameters(\n            newDkgResultSubmissionGas,\n            dkgResultApprovalGasOffset,\n            notifyOperatorInactivityGasOffset,\n            notifySeedTimeoutGasOffset,\n            notifyDkgTimeoutNegativeGasOffset\n        );\n        dkgResultSubmissionGasChangeInitiated = 0;\n        newDkgResultSubmissionGas = 0;\n    }\n\n    /// @notice Begins the dkg approval gas offset update process.\n    /// @dev Can be called only by the contract owner.\n    /// @param _newDkgResultApprovalGasOffset New DKG result approval gas.\n    function beginDkgResultApprovalGasOffsetUpdate(\n        uint256 _newDkgResultApprovalGasOffset\n    ) external onlyOwner {\n        /* solhint-disable not-rely-on-time */\n        newDkgResultApprovalGasOffset = _newDkgResultApprovalGasOffset;\n        dkgResultApprovalGasOffsetChangeInitiated = block.timestamp;\n        emit DkgResultApprovalGasOffsetUpdateStarted(\n            _newDkgResultApprovalGasOffset,\n            block.timestamp\n        );\n        /* solhint-enable not-rely-on-time */\n    }\n\n    /// @notice Finalizes the dkg result approval gas offset update process.\n    /// @dev Can be called only by the contract owner, after the governance\n    ///      delay elapses.\n    function finalizeDkgResultApprovalGasOffsetUpdate()\n        external\n        onlyOwner\n        onlyAfterGovernanceDelay(dkgResultApprovalGasOffsetChangeInitiated)\n    {\n        emit DkgResultApprovalGasOffsetUpdated(newDkgResultApprovalGasOffset);\n        (\n            uint256 dkgResultSubmissionGas,\n            ,\n            uint256 notifyOperatorInactivityGasOffset,\n            uint256 notifySeedTimeoutGasOffset,\n            uint256 notifyDkgTimeoutNegativeGasOffset\n        ) = walletRegistry.gasParameters();\n        // slither-disable-next-line reentrancy-no-eth\n        walletRegistry.updateGasParameters(\n            dkgResultSubmissionGas,\n            newDkgResultApprovalGasOffset,\n            notifyOperatorInactivityGasOffset,\n            notifySeedTimeoutGasOffset,\n            notifyDkgTimeoutNegativeGasOffset\n        );\n        dkgResultApprovalGasOffsetChangeInitiated = 0;\n        newDkgResultApprovalGasOffset = 0;\n    }\n\n    /// @notice Begins the notify operator inactivity gas offset update process.\n    /// @dev Can be called only by the contract owner.\n    /// @param _newNotifyOperatorInactivityGasOffset New operator inactivity\n    ///        notification gas offset\n    function beginNotifyOperatorInactivityGasOffsetUpdate(\n        uint256 _newNotifyOperatorInactivityGasOffset\n    ) external onlyOwner {\n        /* solhint-disable not-rely-on-time */\n        newNotifyOperatorInactivityGasOffset = _newNotifyOperatorInactivityGasOffset;\n        notifyOperatorInactivityGasOffsetChangeInitiated = block.timestamp;\n        emit NotifyOperatorInactivityGasOffsetUpdateStarted(\n            _newNotifyOperatorInactivityGasOffset,\n            block.timestamp\n        );\n        /* solhint-enable not-rely-on-time */\n    }\n\n    /// @notice Finalizes the notify operator inactivity gas offset update process.\n    /// @dev Can be called only by the contract owner, after the governance\n    ///      delay elapses.\n    function finalizeNotifyOperatorInactivityGasOffsetUpdate()\n        external\n        onlyOwner\n        onlyAfterGovernanceDelay(\n            notifyOperatorInactivityGasOffsetChangeInitiated\n        )\n    {\n        emit NotifyOperatorInactivityGasOffsetUpdated(\n            newNotifyOperatorInactivityGasOffset\n        );\n        (\n            uint256 dkgResultSubmissionGas,\n            uint256 dkgResultApprovalGasOffset,\n            ,\n            uint256 notifySeedTimeoutGasOffset,\n            uint256 notifyDkgTimeoutNegativeGasOffset\n        ) = walletRegistry.gasParameters();\n        // slither-disable-next-line reentrancy-no-eth\n        walletRegistry.updateGasParameters(\n            dkgResultSubmissionGas,\n            dkgResultApprovalGasOffset,\n            newNotifyOperatorInactivityGasOffset,\n            notifySeedTimeoutGasOffset,\n            notifyDkgTimeoutNegativeGasOffset\n        );\n        notifyOperatorInactivityGasOffsetChangeInitiated = 0;\n        newNotifyOperatorInactivityGasOffset = 0;\n    }\n\n    /// @notice Begins the notify seed for DKG delivery timeout gas offset update\n    ///         process.\n    /// @dev Can be called only by the contract owner.\n    /// @param _newNotifySeedTimeoutGasOffset New seed for DKG delivery timeout\n    ///        notification gas offset\n    function beginNotifySeedTimeoutGasOffsetUpdate(\n        uint256 _newNotifySeedTimeoutGasOffset\n    ) external onlyOwner {\n        /* solhint-disable not-rely-on-time */\n        newNotifySeedTimeoutGasOffset = _newNotifySeedTimeoutGasOffset;\n        notifySeedTimeoutGasOffsetChangeInitiated = block.timestamp;\n        emit NotifySeedTimeoutGasOffsetUpdateStarted(\n            _newNotifySeedTimeoutGasOffset,\n            block.timestamp\n        );\n        /* solhint-enable not-rely-on-time */\n    }\n\n    /// @notice Finalizes the notify seed for DKG delivery timeout gas offset\n    ///         update process.\n    /// @dev Can be called only by the contract owner, after the governance\n    ///      delay elapses.\n    function finalizeNotifySeedTimeoutGasOffsetUpdate()\n        external\n        onlyOwner\n        onlyAfterGovernanceDelay(notifySeedTimeoutGasOffsetChangeInitiated)\n    {\n        emit NotifySeedTimeoutGasOffsetUpdated(newNotifySeedTimeoutGasOffset);\n        (\n            uint256 dkgResultSubmissionGas,\n            uint256 dkgResultApprovalGasOffset,\n            uint256 notifyOperatorInactivityGasOffset,\n            ,\n            uint256 notifyDkgTimeoutNegativeGasOffset\n        ) = walletRegistry.gasParameters();\n        // slither-disable-next-line reentrancy-no-eth\n        walletRegistry.updateGasParameters(\n            dkgResultSubmissionGas,\n            dkgResultApprovalGasOffset,\n            notifyOperatorInactivityGasOffset,\n            newNotifySeedTimeoutGasOffset,\n            notifyDkgTimeoutNegativeGasOffset\n        );\n        notifySeedTimeoutGasOffsetChangeInitiated = 0;\n        newNotifySeedTimeoutGasOffset = 0;\n    }\n\n    /// @notice Begins the notify DKG timeout negative gas offset update process.\n    /// @dev Can be called only by the contract owner.\n    /// @param _newNotifyDkgTimeoutNegativeGasOffset New DKG timeout negative gas\n    ///        notification gas offset\n    function beginNotifyDkgTimeoutNegativeGasOffsetUpdate(\n        uint256 _newNotifyDkgTimeoutNegativeGasOffset\n    ) external onlyOwner {\n        /* solhint-disable not-rely-on-time */\n        newNotifyDkgTimeoutNegativeGasOffset = _newNotifyDkgTimeoutNegativeGasOffset;\n        notifyDkgTimeoutNegativeGasOffsetChangeInitiated = block.timestamp;\n        emit NotifyDkgTimeoutNegativeGasOffsetUpdateStarted(\n            _newNotifyDkgTimeoutNegativeGasOffset,\n            block.timestamp\n        );\n        /* solhint-enable not-rely-on-time */\n    }\n\n    /// @notice Finalizes the notify DKG timeout negative gas offset update process.\n    /// @dev Can be called only by the contract owner, after the governance\n    ///      delay elapses.\n    function finalizeNotifyDkgTimeoutNegativeGasOffsetUpdate()\n        external\n        onlyOwner\n        onlyAfterGovernanceDelay(\n            notifyDkgTimeoutNegativeGasOffsetChangeInitiated\n        )\n    {\n        emit NotifyDkgTimeoutNegativeGasOffsetUpdated(\n            newNotifyDkgTimeoutNegativeGasOffset\n        );\n        (\n            uint256 dkgResultSubmissionGas,\n            uint256 dkgResultApprovalGasOffset,\n            uint256 notifyOperatorInactivityGasOffset,\n            uint256 notifySeedTimeoutGasOffset,\n\n        ) = walletRegistry.gasParameters();\n        // slither-disable-next-line reentrancy-no-eth\n        walletRegistry.updateGasParameters(\n            dkgResultSubmissionGas,\n            dkgResultApprovalGasOffset,\n            notifyOperatorInactivityGasOffset,\n            notifySeedTimeoutGasOffset,\n            newNotifyDkgTimeoutNegativeGasOffset\n        );\n        notifyDkgTimeoutNegativeGasOffsetChangeInitiated = 0;\n        newNotifyDkgTimeoutNegativeGasOffset = 0;\n    }\n\n    /// @notice Begins the reimbursement pool update process.\n    /// @dev Can be called only by the contract owner.\n    /// @param _newReimbursementPool New reimbursement pool.\n    function beginReimbursementPoolUpdate(address payable _newReimbursementPool)\n        external\n        onlyOwner\n    {\n        require(\n            address(_newReimbursementPool) != address(0),\n            \"New reimbursement pool address cannot be zero\"\n        );\n        /* solhint-disable not-rely-on-time */\n        newReimbursementPool = _newReimbursementPool;\n        reimbursementPoolChangeInitiated = block.timestamp;\n        emit ReimbursementPoolUpdateStarted(\n            _newReimbursementPool,\n            block.timestamp\n        );\n        /* solhint-enable not-rely-on-time */\n    }\n\n    /// @notice Finalizes the reimbursement pool update process.\n    /// @dev Can be called only by the contract owner, after the governance\n    ///      delay elapses.\n    function finalizeReimbursementPoolUpdate()\n        external\n        onlyOwner\n        onlyAfterGovernanceDelay(reimbursementPoolChangeInitiated)\n    {\n        emit ReimbursementPoolUpdated(newReimbursementPool);\n        // slither-disable-next-line reentrancy-no-eth\n        walletRegistry.updateReimbursementPool(\n            ReimbursementPool(newReimbursementPool)\n        );\n        reimbursementPoolChangeInitiated = 0;\n        newReimbursementPool = payable(address(0));\n    }\n\n    /// @notice Begins the sortition pool rewards ban duration update process.\n    /// @dev Can be called only by the contract owner.\n    /// @param _newSortitionPoolRewardsBanDuration New sortition pool rewards\n    ///        ban duration.\n    function beginSortitionPoolRewardsBanDurationUpdate(\n        uint256 _newSortitionPoolRewardsBanDuration\n    ) external onlyOwner {\n        /* solhint-disable not-rely-on-time */\n        newSortitionPoolRewardsBanDuration = _newSortitionPoolRewardsBanDuration;\n        sortitionPoolRewardsBanDurationChangeInitiated = block.timestamp;\n        emit SortitionPoolRewardsBanDurationUpdateStarted(\n            _newSortitionPoolRewardsBanDuration,\n            block.timestamp\n        );\n        /* solhint-enable not-rely-on-time */\n    }\n\n    /// @notice Finalizes the sortition pool rewards ban duration update process.\n    /// @dev Can be called only by the contract owner, after the governance\n    ///      delay elapses.\n    function finalizeSortitionPoolRewardsBanDurationUpdate()\n        external\n        onlyOwner\n        onlyAfterGovernanceDelay(sortitionPoolRewardsBanDurationChangeInitiated)\n    {\n        emit SortitionPoolRewardsBanDurationUpdated(\n            newSortitionPoolRewardsBanDuration\n        );\n        (\n            uint256 maliciousDkgResultNotificationRewardMultiplier,\n\n        ) = walletRegistry.rewardParameters();\n        // slither-disable-next-line reentrancy-no-eth\n        walletRegistry.updateRewardParameters(\n            maliciousDkgResultNotificationRewardMultiplier,\n            newSortitionPoolRewardsBanDuration\n        );\n        sortitionPoolRewardsBanDurationChangeInitiated = 0;\n        newSortitionPoolRewardsBanDuration = 0;\n    }\n\n    /// @notice Begins the DKG seed timeout update process.\n    /// @dev Can be called only by the contract owner.\n    /// @param _newDkgSeedTimeout New DKG seed timeout in blocks\n    function beginDkgSeedTimeoutUpdate(uint256 _newDkgSeedTimeout)\n        external\n        onlyOwner\n    {\n        /* solhint-disable not-rely-on-time */\n        require(_newDkgSeedTimeout > 0, \"DKG seed timeout must be > 0\");\n        newDkgSeedTimeout = _newDkgSeedTimeout;\n        dkgSeedTimeoutChangeInitiated = block.timestamp;\n        emit DkgSeedTimeoutUpdateStarted(_newDkgSeedTimeout, block.timestamp);\n        /* solhint-enable not-rely-on-time */\n    }\n\n    /// @notice Finalizes the DKG seed timeout update process.\n    /// @dev Can be called only by the contract owner, after the governance\n    ///      delay elapses.\n    function finalizeDkgSeedTimeoutUpdate()\n        external\n        onlyOwner\n        onlyAfterGovernanceDelay(dkgSeedTimeoutChangeInitiated)\n    {\n        emit DkgSeedTimeoutUpdated(newDkgSeedTimeout);\n        // slither-disable-next-line reentrancy-no-eth\n        walletRegistry.updateDkgParameters(\n            newDkgSeedTimeout,\n            walletRegistry.dkgParameters().resultChallengePeriodLength,\n            walletRegistry.dkgParameters().resultChallengeExtraGas,\n            walletRegistry.dkgParameters().resultSubmissionTimeout,\n            walletRegistry.dkgParameters().submitterPrecedencePeriodLength\n        );\n        dkgSeedTimeoutChangeInitiated = 0;\n        newDkgSeedTimeout = 0;\n    }\n\n    /// @notice Begins the DKG result challenge period length update process.\n    /// @dev Can be called only by the contract owner.\n    /// @param _newDkgResultChallengePeriodLength New DKG result challenge\n    ///        period length in blocks\n    function beginDkgResultChallengePeriodLengthUpdate(\n        uint256 _newDkgResultChallengePeriodLength\n    ) external onlyOwner {\n        /* solhint-disable not-rely-on-time */\n        require(\n            _newDkgResultChallengePeriodLength >= 10,\n            \"DKG result challenge period length must be >= 10\"\n        );\n        newDkgResultChallengePeriodLength = _newDkgResultChallengePeriodLength;\n        dkgResultChallengePeriodLengthChangeInitiated = block.timestamp;\n        emit DkgResultChallengePeriodLengthUpdateStarted(\n            _newDkgResultChallengePeriodLength,\n            block.timestamp\n        );\n        /* solhint-enable not-rely-on-time */\n    }\n\n    /// @notice Finalizes the DKG result challenge period length update process.\n    /// @dev Can be called only by the contract owner, after the governance\n    ///      delay elapses.\n    function finalizeDkgResultChallengePeriodLengthUpdate()\n        external\n        onlyOwner\n        onlyAfterGovernanceDelay(dkgResultChallengePeriodLengthChangeInitiated)\n    {\n        emit DkgResultChallengePeriodLengthUpdated(\n            newDkgResultChallengePeriodLength\n        );\n        // slither-disable-next-line reentrancy-no-eth\n        walletRegistry.updateDkgParameters(\n            walletRegistry.dkgParameters().seedTimeout,\n            newDkgResultChallengePeriodLength,\n            walletRegistry.dkgParameters().resultChallengeExtraGas,\n            walletRegistry.dkgParameters().resultSubmissionTimeout,\n            walletRegistry.dkgParameters().submitterPrecedencePeriodLength\n        );\n        dkgResultChallengePeriodLengthChangeInitiated = 0;\n        newDkgResultChallengePeriodLength = 0;\n    }\n\n    /// @notice Begins the DKG result challenge extra gas update process.\n    /// @dev Can be called only by the contract owner.\n    /// @param _newDkgResultChallengeExtraGas New DKG result challenge extra gas\n    function beginDkgResultChallengeExtraGasUpdate(\n        uint256 _newDkgResultChallengeExtraGas\n    ) external onlyOwner {\n        /* solhint-disable not-rely-on-time */\n        newDkgResultChallengeExtraGas = _newDkgResultChallengeExtraGas;\n        dkgResultChallengeExtraGasChangeInitiated = block.timestamp;\n        emit DkgResultChallengeExtraGasUpdateStarted(\n            _newDkgResultChallengeExtraGas,\n            block.timestamp\n        );\n        /* solhint-enable not-rely-on-time */\n    }\n\n    /// @notice Finalizes the DKG result challenge extra gas update process.\n    /// @dev Can be called only by the contract owner, after the governance\n    ///      delay elapses.\n    function finalizeDkgResultChallengeExtraGasUpdate()\n        external\n        onlyOwner\n        onlyAfterGovernanceDelay(dkgResultChallengeExtraGasChangeInitiated)\n    {\n        emit DkgResultChallengeExtraGasUpdated(newDkgResultChallengeExtraGas);\n        // slither-disable-next-line reentrancy-no-eth\n        walletRegistry.updateDkgParameters(\n            walletRegistry.dkgParameters().seedTimeout,\n            walletRegistry.dkgParameters().resultChallengePeriodLength,\n            newDkgResultChallengeExtraGas,\n            walletRegistry.dkgParameters().resultSubmissionTimeout,\n            walletRegistry.dkgParameters().submitterPrecedencePeriodLength\n        );\n        dkgResultChallengeExtraGasChangeInitiated = 0;\n        newDkgResultChallengeExtraGas = 0;\n    }\n\n    /// @notice Begins the DKG result submission timeout update\n    ///         process.\n    /// @dev Can be called only by the contract owner.\n    /// @param _newDkgResultSubmissionTimeout New DKG result submission timeout\n    ///        in blocks\n    function beginDkgResultSubmissionTimeoutUpdate(\n        uint256 _newDkgResultSubmissionTimeout\n    ) external onlyOwner {\n        /* solhint-disable not-rely-on-time */\n        require(\n            _newDkgResultSubmissionTimeout > 0,\n            \"DKG result submission timeout must be > 0\"\n        );\n        newDkgResultSubmissionTimeout = _newDkgResultSubmissionTimeout;\n        dkgResultSubmissionTimeoutChangeInitiated = block.timestamp;\n        emit DkgResultSubmissionTimeoutUpdateStarted(\n            _newDkgResultSubmissionTimeout,\n            block.timestamp\n        );\n        /* solhint-enable not-rely-on-time */\n    }\n\n    /// @notice Finalizes the DKG result submission timeout update\n    ///         process.\n    /// @dev Can be called only by the contract owner, after the governance\n    ///      delay elapses.\n    function finalizeDkgResultSubmissionTimeoutUpdate()\n        external\n        onlyOwner\n        onlyAfterGovernanceDelay(dkgResultSubmissionTimeoutChangeInitiated)\n    {\n        emit DkgResultSubmissionTimeoutUpdated(newDkgResultSubmissionTimeout);\n        // slither-disable-next-line reentrancy-no-eth\n        walletRegistry.updateDkgParameters(\n            walletRegistry.dkgParameters().seedTimeout,\n            walletRegistry.dkgParameters().resultChallengePeriodLength,\n            walletRegistry.dkgParameters().resultChallengeExtraGas,\n            newDkgResultSubmissionTimeout,\n            walletRegistry.dkgParameters().submitterPrecedencePeriodLength\n        );\n        dkgResultSubmissionTimeoutChangeInitiated = 0;\n        newDkgResultSubmissionTimeout = 0;\n    }\n\n    /// @notice Begins the DKG submitter precedence period length update\n    ///         process.\n    /// @dev Can be called only by the contract owner.\n    /// @param _newSubmitterPrecedencePeriodLength New DKG submitter precedence\n    ///        period length in blocks\n    function beginDkgSubmitterPrecedencePeriodLengthUpdate(\n        uint256 _newSubmitterPrecedencePeriodLength\n    ) external onlyOwner {\n        /* solhint-disable not-rely-on-time */\n        require(\n            _newSubmitterPrecedencePeriodLength > 0,\n            \"DKG submitter precedence period length must be > 0\"\n        );\n        newSubmitterPrecedencePeriodLength = _newSubmitterPrecedencePeriodLength;\n        dkgSubmitterPrecedencePeriodLengthChangeInitiated = block.timestamp;\n        emit DkgSubmitterPrecedencePeriodLengthUpdateStarted(\n            _newSubmitterPrecedencePeriodLength,\n            block.timestamp\n        );\n        /* solhint-enable not-rely-on-time */\n    }\n\n    /// @notice Finalizes the DKG submitter precedence period length update\n    ///         process.\n    /// @dev Can be called only by the contract owner, after the governance\n    ///      delay elapses.\n    function finalizeDkgSubmitterPrecedencePeriodLengthUpdate()\n        external\n        onlyOwner\n        onlyAfterGovernanceDelay(\n            dkgSubmitterPrecedencePeriodLengthChangeInitiated\n        )\n    {\n        emit DkgSubmitterPrecedencePeriodLengthUpdated(\n            newSubmitterPrecedencePeriodLength\n        );\n        // slither-disable-next-line reentrancy-no-eth\n        walletRegistry.updateDkgParameters(\n            walletRegistry.dkgParameters().seedTimeout,\n            walletRegistry.dkgParameters().resultChallengePeriodLength,\n            walletRegistry.dkgParameters().resultChallengeExtraGas,\n            walletRegistry.dkgParameters().resultSubmissionTimeout,\n            newSubmitterPrecedencePeriodLength\n        );\n        dkgSubmitterPrecedencePeriodLengthChangeInitiated = 0;\n        newSubmitterPrecedencePeriodLength = 0;\n    }\n\n    /// @notice Withdraws rewards belonging to operators marked as ineligible\n    ///         for sortition pool rewards.\n    /// @dev Can be called only by the contract owner.\n    /// @param recipient Recipient of withdrawn rewards.\n    function withdrawIneligibleRewards(address recipient) external onlyOwner {\n        walletRegistry.withdrawIneligibleRewards(recipient);\n    }\n\n    /// @notice Get the time remaining until the governance delay can be updated.\n    /// @return Remaining time in seconds.\n    function getRemainingGovernanceDelayUpdateTime()\n        external\n        view\n        returns (uint256)\n    {\n        return getRemainingChangeTime(governanceDelayChangeInitiated);\n    }\n\n    /// @notice Get the time remaining until the wallet registry governance can\n    ///         be transferred.\n    /// @return Remaining time in seconds.\n    function getRemainingWalletRegistryGovernanceTransferDelayTime()\n        external\n        view\n        returns (uint256)\n    {\n        return\n            getRemainingChangeTime(walletRegistryGovernanceTransferInitiated);\n    }\n\n    /// @notice Get the time remaining until the minimum authorization amount\n    ///         can be updated.\n    /// @return Remaining time in seconds.\n    function getRemainingMimimumAuthorizationUpdateTime()\n        external\n        view\n        returns (uint256)\n    {\n        return getRemainingChangeTime(minimumAuthorizationChangeInitiated);\n    }\n\n    /// @notice Get the time remaining until the authorization decrease delay\n    ///         can be updated.\n    /// @return Remaining time in seconds.\n    function getRemainingAuthorizationDecreaseDelayUpdateTime()\n        external\n        view\n        returns (uint256)\n    {\n        return\n            getRemainingChangeTime(authorizationDecreaseDelayChangeInitiated);\n    }\n\n    /// @notice Get the time remaining until the authorization decrease change\n    ///         period can be updated.\n    /// @return Remaining time in seconds.\n    function getRemainingAuthorizationDecreaseChangePeriodUpdateTime()\n        external\n        view\n        returns (uint256)\n    {\n        return\n            getRemainingChangeTime(\n                authorizationDecreaseChangePeriodChangeInitiated\n            );\n    }\n\n    /// @notice Get the time remaining until the malicious DKG result\n    ///         slashing amount can be updated.\n    /// @return Remaining time in seconds.\n    function getRemainingMaliciousDkgResultSlashingAmountUpdateTime()\n        external\n        view\n        returns (uint256)\n    {\n        return\n            getRemainingChangeTime(\n                maliciousDkgResultSlashingAmountChangeInitiated\n            );\n    }\n\n    /// @notice Get the time remaining until the DKG malicious result\n    ///         notification reward multiplier duration can be updated.\n    /// @return Remaining time in seconds.\n    function getRemainingMaliciousDkgResultNotificationRewardMultiplierUpdateTime()\n        external\n        view\n        returns (uint256)\n    {\n        return\n            getRemainingChangeTime(\n                maliciousDkgResultNotificationRewardMultiplierChangeInitiated\n            );\n    }\n\n    /// @notice Get the time remaining until the sortition pool rewards ban\n    ///         duration can be updated.\n    /// @return Remaining time in seconds.\n    function getRemainingSortitionPoolRewardsBanDurationUpdateTime()\n        external\n        view\n        returns (uint256)\n    {\n        return\n            getRemainingChangeTime(\n                sortitionPoolRewardsBanDurationChangeInitiated\n            );\n    }\n\n    /// @notice Get the time remaining until the DKG seed timeout can be updated.\n    /// @return Remaining time in seconds.\n    function getRemainingDkgSeedTimeoutUpdateTime()\n        external\n        view\n        returns (uint256)\n    {\n        return getRemainingChangeTime(dkgSeedTimeoutChangeInitiated);\n    }\n\n    /// @notice Get the time remaining until the DKG result challenge period\n    ///         length can be updated.\n    /// @return Remaining time in seconds.\n    function getRemainingDkgResultChallengePeriodLengthUpdateTime()\n        external\n        view\n        returns (uint256)\n    {\n        return\n            getRemainingChangeTime(\n                dkgResultChallengePeriodLengthChangeInitiated\n            );\n    }\n\n    function getRemainingDkgResultChallengeExtraGasUpdateTime()\n        external\n        view\n        returns (uint256)\n    {\n        return\n            getRemainingChangeTime(dkgResultChallengeExtraGasChangeInitiated);\n    }\n\n    /// @notice Get the time remaining until the DKG result submission timeout\n    ///         can be updated.\n    /// @return Remaining time in seconds.\n    function getRemainingDkgResultSubmissionTimeoutUpdateTime()\n        external\n        view\n        returns (uint256)\n    {\n        return\n            getRemainingChangeTime(dkgResultSubmissionTimeoutChangeInitiated);\n    }\n\n    /// @notice Get the time remaining until the wallet owner can be updated.\n    /// @return Remaining time in seconds.\n    function getRemainingWalletOwnerUpdateTime()\n        external\n        view\n        returns (uint256)\n    {\n        return getRemainingChangeTime(walletOwnerChangeInitiated);\n    }\n\n    /// @notice Get the time remaining until the wallet owner can be updated.\n    /// @return Remaining time in seconds.\n    function getRemainingDkgSubmitterPrecedencePeriodLengthUpdateTime()\n        external\n        view\n        returns (uint256)\n    {\n        return\n            getRemainingChangeTime(\n                dkgSubmitterPrecedencePeriodLengthChangeInitiated\n            );\n    }\n\n    /// @notice Get the time remaining until the dkg result submission gas can\n    ///         be updated.\n    /// @return Remaining time in seconds.\n    function getRemainingDkgResultSubmissionGasUpdateTime()\n        external\n        view\n        returns (uint256)\n    {\n        return getRemainingChangeTime(dkgResultSubmissionGasChangeInitiated);\n    }\n\n    /// @notice Get the time remaining until the dkg result approval gas offset\n    ///         can be updated.\n    /// @return Remaining time in seconds.\n    function getRemainingDkgResultApprovalGasOffsetUpdateTime()\n        external\n        view\n        returns (uint256)\n    {\n        return\n            getRemainingChangeTime(dkgResultApprovalGasOffsetChangeInitiated);\n    }\n\n    /// @notice Get the time remaining until the operator inactivity gas offset\n    ///         can be updated.\n    /// @return Remaining time in seconds.\n    function getRemainingNotifyOperatorInactivityGasOffsetUpdateTime()\n        external\n        view\n        returns (uint256)\n    {\n        return\n            getRemainingChangeTime(\n                notifyOperatorInactivityGasOffsetChangeInitiated\n            );\n    }\n\n    /// @notice Get the time remaining until the seed for DKG delivery timeout\n    /// gas offset can be updated.\n    /// @return Remaining time in seconds.\n    function getRemainingNotifySeedTimeoutGasOffsetUpdateTime()\n        external\n        view\n        returns (uint256)\n    {\n        return\n            getRemainingChangeTime(notifySeedTimeoutGasOffsetChangeInitiated);\n    }\n\n    /// @notice Get the time remaining until the DKG timeout negative gas offset\n    ///         can be updated.\n    /// @return Remaining time in seconds.\n    function getRemainingNotifyDkgTimeoutNegativeGasOffsetUpdateTime()\n        external\n        view\n        returns (uint256)\n    {\n        return\n            getRemainingChangeTime(\n                notifyDkgTimeoutNegativeGasOffsetChangeInitiated\n            );\n    }\n\n    /// @notice Get the time remaining until reimbursement pool can be updated.\n    /// @return Remaining time in seconds.\n    function getRemainingReimbursementPoolUpdateTime()\n        external\n        view\n        returns (uint256)\n    {\n        return getRemainingChangeTime(reimbursementPoolChangeInitiated);\n    }\n\n    /// @notice Gets the time remaining until the governable parameter update\n    ///         can be committed.\n    /// @param changeTimestamp Timestamp indicating the beginning of the change.\n    /// @return Remaining time in seconds.\n    function getRemainingChangeTime(uint256 changeTimestamp)\n        internal\n        view\n        returns (uint256)\n    {\n        require(changeTimestamp > 0, \"Change not initiated\");\n        /* solhint-disable-next-line not-rely-on-time */\n        uint256 elapsed = block.timestamp - changeTimestamp;\n        if (elapsed >= governanceDelay) {\n            return 0;\n        }\n\n        return governanceDelay - elapsed;\n    }\n}\n"
    },
    "contracts/WalletRegistry.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n//\n// ▓▓▌ ▓▓ ▐▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▄\n// ▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n//   ▓▓▓▓▓▓    ▓▓▓▓▓▓▓▀    ▐▓▓▓▓▓▓    ▐▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n//   ▓▓▓▓▓▓▄▄▓▓▓▓▓▓▓▀      ▐▓▓▓▓▓▓▄▄▄▄         ▓▓▓▓▓▓▄▄▄▄         ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n//   ▓▓▓▓▓▓▓▓▓▓▓▓▓▀        ▐▓▓▓▓▓▓▓▓▓▓         ▓▓▓▓▓▓▓▓▓▓         ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n//   ▓▓▓▓▓▓▀▀▓▓▓▓▓▓▄       ▐▓▓▓▓▓▓▀▀▀▀         ▓▓▓▓▓▓▀▀▀▀         ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▀\n//   ▓▓▓▓▓▓   ▀▓▓▓▓▓▓▄     ▐▓▓▓▓▓▓     ▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌\n// ▓▓▓▓▓▓▓▓▓▓ █▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▓▓\n// ▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▓▓\n//\n//                           Trust math, not hardware.\n\npragma solidity 0.8.17;\n\nimport \"./api/IWalletRegistry.sol\";\nimport \"./api/IWalletOwner.sol\";\nimport \"./libraries/Wallets.sol\";\nimport {EcdsaAuthorization as Authorization} from \"./libraries/EcdsaAuthorization.sol\";\nimport {EcdsaDkg as DKG} from \"./libraries/EcdsaDkg.sol\";\nimport {EcdsaInactivity as Inactivity} from \"./libraries/EcdsaInactivity.sol\";\nimport {EcdsaDkgValidator as DKGValidator} from \"./EcdsaDkgValidator.sol\";\n\nimport \"@keep-network/sortition-pools/contracts/SortitionPool.sol\";\nimport \"@keep-network/random-beacon/contracts/api/IRandomBeacon.sol\";\nimport \"@keep-network/random-beacon/contracts/api/IRandomBeaconConsumer.sol\";\nimport \"@keep-network/random-beacon/contracts/Reimbursable.sol\";\nimport \"@keep-network/random-beacon/contracts/ReimbursementPool.sol\";\nimport \"@keep-network/random-beacon/contracts/Governable.sol\";\n\nimport \"@threshold-network/solidity-contracts/contracts/staking/IApplication.sol\";\nimport \"@threshold-network/solidity-contracts/contracts/staking/IStaking.sol\";\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\ncontract WalletRegistry is\n    IWalletRegistry,\n    IRandomBeaconConsumer,\n    IApplication,\n    Governable,\n    Reimbursable,\n    Initializable\n{\n    using Authorization for Authorization.Data;\n    using DKG for DKG.Data;\n    using Wallets for Wallets.Data;\n\n    // Libraries data storages\n    Authorization.Data internal authorization;\n    DKG.Data internal dkg;\n    Wallets.Data internal wallets;\n\n    /// @notice Slashing amount for submitting a malicious DKG result. Every\n    ///         DKG result submitted can be challenged for the time of\n    ///         `dkg.resultChallengePeriodLength`. If the DKG result submitted\n    ///         is challenged and proven to be malicious, the operator who\n    ///         submitted the malicious result is slashed for\n    ///         `_maliciousDkgResultSlashingAmount`.\n    uint96 internal _maliciousDkgResultSlashingAmount;\n\n    /// @notice Percentage of the staking contract malicious behavior\n    ///         notification reward which will be transferred to the notifier\n    ///         reporting about a malicious DKG result. Notifiers are rewarded\n    ///         from a notifiers treasury pool. For example, if\n    ///         notification reward is 1000 and the value of the multiplier is\n    ///         5, the notifier will receive: 5% of 1000 = 50 per each\n    ///         operator affected.\n    uint256 internal _maliciousDkgResultNotificationRewardMultiplier;\n\n    /// @notice Duration of the sortition pool rewards ban imposed on operators\n    ///         who missed their turn for DKG result submission or who failed\n    ///         a heartbeat.\n    uint256 internal _sortitionPoolRewardsBanDuration;\n\n    /// @notice Calculated max gas cost for submitting a DKG result. This will\n    ///         be refunded as part of the DKG approval process. It is in the\n    ///         submitter's interest to not skip his priority turn on the approval,\n    ///         otherwise the refund of the DKG submission will be refunded to\n    ///         another group member that will call the DKG approve function.\n    uint256 internal _dkgResultSubmissionGas;\n\n    /// @notice Gas that is meant to balance the DKG result approval's overall\n    ///         cost. It can be updated by the governance based on the current\n    ///         market conditions.\n    uint256 internal _dkgResultApprovalGasOffset;\n\n    /// @notice Gas that is meant to balance the notification of an operator\n    ///         inactivity. It can be updated by the governance based on the\n    ///         current market conditions.\n    uint256 internal _notifyOperatorInactivityGasOffset;\n\n    /// @notice Gas that is meant to balance the notification of a seed for DKG\n    ///         delivery timeout. It can be updated by the governance based on the\n    ///         current market conditions.\n    uint256 internal _notifySeedTimeoutGasOffset;\n\n    /// @notice Gas that is meant to balance the notification of a DKG protocol\n    ///         execution timeout. It can be updated by the governance based on the\n    ///         current market conditions.\n    /// @dev The value is subtracted for the refundable gas calculation, as the\n    ///      DKG timeout notification transaction recovers some gas when cleaning\n    ///      up the storage.\n    uint256 internal _notifyDkgTimeoutNegativeGasOffset;\n\n    /// @notice Stores current operator inactivity claim nonce for the given\n    ///         wallet signing group. Each claim is made with a unique nonce\n    ///         which protects against claim replay.\n    mapping(bytes32 => uint256) public inactivityClaimNonce; // walletID -> nonce\n\n    // Address that is set as owner of all wallets. Only this address can request\n    // new wallets creation and manage their state.\n    IWalletOwner public walletOwner;\n\n    // External dependencies\n\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    SortitionPool public immutable sortitionPool;\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    IStaking public immutable staking;\n    IRandomBeacon public randomBeacon;\n\n    // Events\n    event DkgStarted(uint256 indexed seed);\n\n    event DkgResultSubmitted(\n        bytes32 indexed resultHash,\n        uint256 indexed seed,\n        DKG.Result result\n    );\n\n    event DkgTimedOut();\n\n    event DkgResultApproved(\n        bytes32 indexed resultHash,\n        address indexed approver\n    );\n\n    event DkgResultChallenged(\n        bytes32 indexed resultHash,\n        address indexed challenger,\n        string reason\n    );\n\n    event DkgStateLocked();\n\n    event DkgSeedTimedOut();\n\n    event WalletCreated(\n        bytes32 indexed walletID,\n        bytes32 indexed dkgResultHash\n    );\n\n    event WalletClosed(bytes32 indexed walletID);\n\n    event DkgMaliciousResultSlashed(\n        bytes32 indexed resultHash,\n        uint256 slashingAmount,\n        address maliciousSubmitter\n    );\n\n    event DkgMaliciousResultSlashingFailed(\n        bytes32 indexed resultHash,\n        uint256 slashingAmount,\n        address maliciousSubmitter\n    );\n\n    event AuthorizationParametersUpdated(\n        uint96 minimumAuthorization,\n        uint64 authorizationDecreaseDelay,\n        uint64 authorizationDecreaseChangePeriod\n    );\n\n    event RewardParametersUpdated(\n        uint256 maliciousDkgResultNotificationRewardMultiplier,\n        uint256 sortitionPoolRewardsBanDuration\n    );\n\n    event SlashingParametersUpdated(uint256 maliciousDkgResultSlashingAmount);\n\n    event DkgParametersUpdated(\n        uint256 seedTimeout,\n        uint256 resultChallengePeriodLength,\n        uint256 resultChallengeExtraGas,\n        uint256 resultSubmissionTimeout,\n        uint256 resultSubmitterPrecedencePeriodLength\n    );\n\n    event GasParametersUpdated(\n        uint256 dkgResultSubmissionGas,\n        uint256 dkgResultApprovalGasOffset,\n        uint256 notifyOperatorInactivityGasOffset,\n        uint256 notifySeedTimeoutGasOffset,\n        uint256 notifyDkgTimeoutNegativeGasOffset\n    );\n\n    event RandomBeaconUpgraded(address randomBeacon);\n\n    event WalletOwnerUpdated(address walletOwner);\n\n    event OperatorRegistered(\n        address indexed stakingProvider,\n        address indexed operator\n    );\n\n    event AuthorizationIncreased(\n        address indexed stakingProvider,\n        address indexed operator,\n        uint96 fromAmount,\n        uint96 toAmount\n    );\n\n    event AuthorizationDecreaseRequested(\n        address indexed stakingProvider,\n        address indexed operator,\n        uint96 fromAmount,\n        uint96 toAmount,\n        uint64 decreasingAt\n    );\n\n    event AuthorizationDecreaseApproved(address indexed stakingProvider);\n\n    event InvoluntaryAuthorizationDecreaseFailed(\n        address indexed stakingProvider,\n        address indexed operator,\n        uint96 fromAmount,\n        uint96 toAmount\n    );\n\n    event OperatorJoinedSortitionPool(\n        address indexed stakingProvider,\n        address indexed operator\n    );\n\n    event OperatorStatusUpdated(\n        address indexed stakingProvider,\n        address indexed operator\n    );\n\n    event InactivityClaimed(\n        bytes32 indexed walletID,\n        uint256 nonce,\n        address notifier\n    );\n\n    modifier onlyStakingContract() {\n        require(\n            msg.sender == address(staking),\n            \"Caller is not the staking contract\"\n        );\n        _;\n    }\n\n    /// @notice Reverts if called not by the Wallet Owner.\n    modifier onlyWalletOwner() {\n        require(\n            msg.sender == address(walletOwner),\n            \"Caller is not the Wallet Owner\"\n        );\n        _;\n    }\n\n    modifier onlyReimbursableAdmin() override {\n        require(governance == msg.sender, \"Caller is not the governance\");\n        _;\n    }\n\n    /// @dev Used to initialize immutable variables only, use `initialize` function\n    ///      for upgradable contract initialization on deployment.\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(SortitionPool _sortitionPool, IStaking _staking) {\n        sortitionPool = _sortitionPool;\n        staking = _staking;\n\n        _disableInitializers();\n    }\n\n    /// @dev Initializes upgradable contract on deployment.\n    function initialize(\n        DKGValidator _ecdsaDkgValidator,\n        IRandomBeacon _randomBeacon,\n        ReimbursementPool _reimbursementPool\n    ) external initializer {\n        randomBeacon = _randomBeacon;\n        reimbursementPool = _reimbursementPool;\n\n        _transferGovernance(msg.sender);\n\n        //\n        // All parameters set in the constructor are initial ones, used at the\n        // moment contracts were deployed for the first time. Parameters are\n        // governable and values assigned in the constructor do not need to\n        // reflect the current ones.\n        //\n\n        // Minimum authorization is 40k T.\n        //\n        // Authorization decrease delay is 45 days.\n        //\n        // Authorization decrease change period is 45 days. It means pending\n        // authorization decrease can be overwritten all the time.\n        authorization.setMinimumAuthorization(40_000e18);\n        authorization.setAuthorizationDecreaseDelay(3_888_000);\n        authorization.setAuthorizationDecreaseChangePeriod(3_888_000);\n\n        // Malicious DKG result slashing amount is set initially to 1% of the\n        // minimum authorization (400 T). This values needs to be increased\n        // significantly once the system is fully launched.\n        //\n        // Notifier of a malicious DKG result receives 100% of the notifier\n        // reward from the staking contract.\n        //\n        // Inactive operators are set as ineligible for rewards for 2 weeks.\n        _maliciousDkgResultSlashingAmount = 400e18;\n        _maliciousDkgResultNotificationRewardMultiplier = 100;\n        _sortitionPoolRewardsBanDuration = 2 weeks;\n\n        // DKG seed timeout is set to 48h assuming 15s block time. The same\n        // value is used by the Random Beacon as a relay entry hard timeout.\n        //\n        // DKG result challenge period length is set to 48h as well, assuming\n        // 15s block time.\n        //\n        // DKG result submission timeout, gives each member 20 blocks to submit\n        // the result. Assuming 15s block time, it is ~8h to submit the result\n        // in the pessimistic case.\n        //\n        // The original DKG result submitter has 20 blocks to approve it before\n        // anyone else can do that.\n        //\n        // With these parameters, the happy path takes no more than 104 hours.\n        // In practice, it should take about 48 hours (just the challenge time).\n        dkg.init(sortitionPool, _ecdsaDkgValidator);\n        dkg.setSeedTimeout(11_520);\n        dkg.setResultChallengePeriodLength(11_520);\n        dkg.setResultChallengeExtraGas(50_000);\n        dkg.setResultSubmissionTimeout(100 * 20);\n        dkg.setSubmitterPrecedencePeriodLength(20);\n\n        // Gas parameters were adjusted based on Ethereum state in April 2022.\n        // If the cost of EVM opcodes change over time, these parameters will\n        // have to be updated.\n        _dkgResultSubmissionGas = 290_000;\n        _dkgResultApprovalGasOffset = 72_000;\n        _notifyOperatorInactivityGasOffset = 93_000;\n        _notifySeedTimeoutGasOffset = 7_250;\n        _notifyDkgTimeoutNegativeGasOffset = 2_300;\n    }\n\n    /// @notice Withdraws application rewards for the given staking provider.\n    ///         Rewards are withdrawn to the staking provider's beneficiary\n    ///         address set in the staking contract. Reverts if staking provider\n    ///         has not registered the operator address.\n    /// @dev Emits `RewardsWithdrawn` event.\n    function withdrawRewards(address stakingProvider) external {\n        address operator = stakingProviderToOperator(stakingProvider);\n        require(operator != address(0), \"Unknown operator\");\n        (, address beneficiary, ) = staking.rolesOf(stakingProvider);\n        uint96 amount = sortitionPool.withdrawRewards(operator, beneficiary);\n        // slither-disable-next-line reentrancy-events\n        emit RewardsWithdrawn(stakingProvider, amount);\n    }\n\n    /// @notice Withdraws rewards belonging to operators marked as ineligible\n    ///         for sortition pool rewards.\n    /// @dev Can be called only by the contract guvnor, which should be the\n    ///      wallet registry governance contract.\n    /// @param recipient Recipient of withdrawn rewards.\n    function withdrawIneligibleRewards(address recipient)\n        external\n        onlyGovernance\n    {\n        sortitionPool.withdrawIneligible(recipient);\n    }\n\n    /// @notice Used by staking provider to set operator address that will\n    ///         operate ECDSA node. The given staking provider can set operator\n    ///         address only one time. The operator address can not be changed\n    ///         and must be unique. Reverts if the operator is already set for\n    ///         the staking provider or if the operator address is already in\n    ///         use. Reverts if there is a pending authorization decrease for\n    ///         the staking provider.\n    function registerOperator(address operator) external {\n        authorization.registerOperator(operator);\n    }\n\n    /// @notice Lets the operator join the sortition pool. The operator address\n    ///         must be known - before calling this function, it has to be\n    ///         appointed by the staking provider by calling `registerOperator`.\n    ///         Also, the operator must have the minimum authorization required\n    ///         by ECDSA. Function reverts if there is no minimum stake\n    ///         authorized or if the operator is not known. If there was an\n    ///         authorization decrease requested, it is activated by starting\n    ///         the authorization decrease delay.\n    function joinSortitionPool() external {\n        authorization.joinSortitionPool(staking, sortitionPool);\n    }\n\n    /// @notice Updates status of the operator in the sortition pool. If there\n    ///         was an authorization decrease requested, it is activated by\n    ///         starting the authorization decrease delay.\n    ///         Function reverts if the operator is not known.\n    function updateOperatorStatus(address operator) external {\n        authorization.updateOperatorStatus(staking, sortitionPool, operator);\n    }\n\n    /// @notice Used by T staking contract to inform the application that the\n    ///         authorized stake amount for the given staking provider increased.\n    ///\n    ///         Reverts if the authorization amount is below the minimum.\n    ///\n    ///         The function is not updating the sortition pool. Sortition pool\n    ///         state needs to be updated by the operator with a call to\n    ///         `joinSortitionPool` or `updateOperatorStatus`.\n    ///\n    /// @dev Can only be called by T staking contract.\n    function authorizationIncreased(\n        address stakingProvider,\n        uint96 fromAmount,\n        uint96 toAmount\n    ) external onlyStakingContract {\n        authorization.authorizationIncreased(\n            stakingProvider,\n            fromAmount,\n            toAmount\n        );\n    }\n\n    /// @notice Used by T staking contract to inform the application that the\n    ///         authorization decrease for the given staking provider has been\n    ///         requested.\n    ///\n    ///         Reverts if the amount after deauthorization would be non-zero\n    ///         and lower than the minimum authorization.\n    ///\n    ///         If the operator is not known (`registerOperator` was not called)\n    ///         it lets to `approveAuthorizationDecrease` immediatelly. If the\n    ///         operator is known (`registerOperator` was called), the operator\n    ///         needs to update state of the sortition pool with a call to\n    ///         `joinSortitionPool` or `updateOperatorStatus`. After the\n    ///         sortition pool state is in sync, authorization decrease delay\n    ///         starts.\n    ///\n    ///         After authorization decrease delay passes, authorization\n    ///         decrease request needs to be approved with a call to\n    ///         `approveAuthorizationDecrease` function.\n    ///\n    ///         If there is a pending authorization decrease request, it is\n    ///         overwritten.\n    ///\n    /// @dev Can only be called by T staking contract.\n    function authorizationDecreaseRequested(\n        address stakingProvider,\n        uint96 fromAmount,\n        uint96 toAmount\n    ) external onlyStakingContract {\n        authorization.authorizationDecreaseRequested(\n            stakingProvider,\n            fromAmount,\n            toAmount\n        );\n    }\n\n    /// @notice Approves the previously registered authorization decrease\n    ///         request. Reverts if authorization decrease delay has not passed\n    ///         yet or if the authorization decrease was not requested for the\n    ///         given staking provider.\n    function approveAuthorizationDecrease(address stakingProvider) external {\n        authorization.approveAuthorizationDecrease(staking, stakingProvider);\n    }\n\n    /// @notice Used by T staking contract to inform the application the\n    ///         authorization has been decreased for the given staking provider\n    ///         involuntarily, as a result of slashing.\n    ///\n    ///         If the operator is not known (`registerOperator` was not called)\n    ///         the function does nothing. The operator was never in a sortition\n    ///         pool so there is nothing to update.\n    ///\n    ///         If the operator is known, sortition pool is unlocked, and the\n    ///         operator is in the sortition pool, the sortition pool state is\n    ///         updated. If the sortition pool is locked, update needs to be\n    ///         postponed. Every other staker is incentivized to call\n    ///         `updateOperatorStatus` for the problematic operator to increase\n    ///         their own rewards in the pool.\n    function involuntaryAuthorizationDecrease(\n        address stakingProvider,\n        uint96 fromAmount,\n        uint96 toAmount\n    ) external onlyStakingContract {\n        authorization.involuntaryAuthorizationDecrease(\n            staking,\n            sortitionPool,\n            stakingProvider,\n            fromAmount,\n            toAmount\n        );\n    }\n\n    /// @notice Updates address of the Random Beacon.\n    /// @dev Can be called only by the contract guvnor, which should be the\n    ///      wallet registry governance contract. The caller is responsible for\n    ///      validating parameters.\n    /// @param _randomBeacon Random Beacon address.\n    function upgradeRandomBeacon(IRandomBeacon _randomBeacon)\n        external\n        onlyGovernance\n    {\n        randomBeacon = _randomBeacon;\n        emit RandomBeaconUpgraded(address(_randomBeacon));\n    }\n\n    /// @notice Updates the wallet owner.\n    /// @dev Can be called only by the contract guvnor, which should be the\n    ///      wallet registry governance contract. The caller is responsible for\n    ///      validating parameters. The wallet owner has to implement `IWalletOwner`\n    ///      interface.\n    /// @param _walletOwner New wallet owner address.\n    function updateWalletOwner(IWalletOwner _walletOwner)\n        external\n        onlyGovernance\n    {\n        walletOwner = _walletOwner;\n        emit WalletOwnerUpdated(address(_walletOwner));\n    }\n\n    /// @notice Updates the values of authorization parameters.\n    /// @dev Can be called only by the contract guvnor, which should be the\n    ///      wallet registry governance contract. The caller is responsible for\n    ///      validating parameters.\n    /// @param _minimumAuthorization New minimum authorization amount.\n    /// @param _authorizationDecreaseDelay New authorization decrease delay in\n    ///        seconds.\n    /// @param _authorizationDecreaseChangePeriod New authorization decrease\n    ///        change period in seconds.\n    function updateAuthorizationParameters(\n        uint96 _minimumAuthorization,\n        uint64 _authorizationDecreaseDelay,\n        uint64 _authorizationDecreaseChangePeriod\n    ) external onlyGovernance {\n        authorization.setMinimumAuthorization(_minimumAuthorization);\n        authorization.setAuthorizationDecreaseDelay(\n            _authorizationDecreaseDelay\n        );\n        authorization.setAuthorizationDecreaseChangePeriod(\n            _authorizationDecreaseChangePeriod\n        );\n\n        emit AuthorizationParametersUpdated(\n            _minimumAuthorization,\n            _authorizationDecreaseDelay,\n            _authorizationDecreaseChangePeriod\n        );\n    }\n\n    /// @notice Updates the values of DKG parameters.\n    /// @dev Can be called only by the contract guvnor, which should be the\n    ///      wallet registry governance contract. The caller is responsible for\n    ///      validating parameters.\n    /// @param _seedTimeout New seed timeout.\n    /// @param _resultChallengePeriodLength New DKG result challenge period\n    ///        length.\n    /// @param _resultChallengeExtraGas New extra gas value required to be left\n    ///        at the end of the DKG result challenge transaction.\n    /// @param _resultSubmissionTimeout New DKG result submission timeout.\n    /// @param _submitterPrecedencePeriodLength New submitter precedence period\n    ///        length.\n    function updateDkgParameters(\n        uint256 _seedTimeout,\n        uint256 _resultChallengePeriodLength,\n        uint256 _resultChallengeExtraGas,\n        uint256 _resultSubmissionTimeout,\n        uint256 _submitterPrecedencePeriodLength\n    ) external onlyGovernance {\n        dkg.setSeedTimeout(_seedTimeout);\n        dkg.setResultChallengePeriodLength(_resultChallengePeriodLength);\n        dkg.setResultChallengeExtraGas(_resultChallengeExtraGas);\n        dkg.setResultSubmissionTimeout(_resultSubmissionTimeout);\n        dkg.setSubmitterPrecedencePeriodLength(\n            _submitterPrecedencePeriodLength\n        );\n\n        // slither-disable-next-line reentrancy-events\n        emit DkgParametersUpdated(\n            _seedTimeout,\n            _resultChallengePeriodLength,\n            _resultChallengeExtraGas,\n            _resultSubmissionTimeout,\n            _submitterPrecedencePeriodLength\n        );\n    }\n\n    /// @notice Updates the values of reward parameters.\n    /// @dev Can be called only by the contract guvnor, which should be the\n    ///      wallet registry governance contract. The caller is responsible for\n    ///      validating parameters.\n    /// @param maliciousDkgResultNotificationRewardMultiplier New value of the\n    ///        DKG malicious result notification reward multiplier.\n    /// @param sortitionPoolRewardsBanDuration New sortition pool rewards\n    ///        ban duration in seconds.\n    function updateRewardParameters(\n        uint256 maliciousDkgResultNotificationRewardMultiplier,\n        uint256 sortitionPoolRewardsBanDuration\n    ) external onlyGovernance {\n        _maliciousDkgResultNotificationRewardMultiplier = maliciousDkgResultNotificationRewardMultiplier;\n        _sortitionPoolRewardsBanDuration = sortitionPoolRewardsBanDuration;\n        emit RewardParametersUpdated(\n            maliciousDkgResultNotificationRewardMultiplier,\n            sortitionPoolRewardsBanDuration\n        );\n    }\n\n    /// @notice Updates the values of slashing parameters.\n    /// @dev Can be called only by the contract guvnor, which should be the\n    ///      wallet registry governance contract. The caller is responsible for\n    ///      validating parameters.\n    /// @param maliciousDkgResultSlashingAmount New malicious DKG result\n    ///        slashing amount.\n    function updateSlashingParameters(uint96 maliciousDkgResultSlashingAmount)\n        external\n        onlyGovernance\n    {\n        _maliciousDkgResultSlashingAmount = maliciousDkgResultSlashingAmount;\n        emit SlashingParametersUpdated(maliciousDkgResultSlashingAmount);\n    }\n\n    /// @notice Updates the values of gas-related parameters.\n    /// @dev Can be called only by the contract guvnor, which should be the\n    ///      wallet registry governance contract. The caller is responsible for\n    ///      validating parameters.\n    /// @param dkgResultSubmissionGas New DKG result submission gas.\n    /// @param dkgResultApprovalGasOffset New DKG result approval gas offset.\n    /// @param notifyOperatorInactivityGasOffset New operator inactivity\n    ///        notification gas offset.\n    /// @param notifySeedTimeoutGasOffset New seed for DKG delivery timeout\n    ///        notification gas offset.\n    /// @param notifyDkgTimeoutNegativeGasOffset New DKG timeout notification gas\n    ///        offset.\n    function updateGasParameters(\n        uint256 dkgResultSubmissionGas,\n        uint256 dkgResultApprovalGasOffset,\n        uint256 notifyOperatorInactivityGasOffset,\n        uint256 notifySeedTimeoutGasOffset,\n        uint256 notifyDkgTimeoutNegativeGasOffset\n    ) external onlyGovernance {\n        _dkgResultSubmissionGas = dkgResultSubmissionGas;\n        _dkgResultApprovalGasOffset = dkgResultApprovalGasOffset;\n        _notifyOperatorInactivityGasOffset = notifyOperatorInactivityGasOffset;\n        _notifySeedTimeoutGasOffset = notifySeedTimeoutGasOffset;\n        _notifyDkgTimeoutNegativeGasOffset = notifyDkgTimeoutNegativeGasOffset;\n\n        emit GasParametersUpdated(\n            dkgResultSubmissionGas,\n            dkgResultApprovalGasOffset,\n            notifyOperatorInactivityGasOffset,\n            _notifySeedTimeoutGasOffset,\n            _notifyDkgTimeoutNegativeGasOffset\n        );\n    }\n\n    /// @notice Requests a new wallet creation.\n    /// @dev Can be called only by the owner of wallets.\n    ///      It locks the DKG and request a new relay entry. It expects\n    ///      that the DKG process will be started once a new relay entry\n    ///      gets generated.\n    function requestNewWallet() external onlyWalletOwner {\n        dkg.lockState();\n\n        randomBeacon.requestRelayEntry(this);\n    }\n\n    /// @notice Closes an existing wallet. Reverts if wallet with the given ID\n    ///         does not exist or if it has already been closed.\n    /// @param walletID ID of the wallet.\n    /// @dev Only a Wallet Owner can call this function.\n    function closeWallet(bytes32 walletID) external onlyWalletOwner {\n        wallets.deleteWallet(walletID);\n        emit WalletClosed(walletID);\n    }\n\n    /// @notice A callback that is executed once a new relay entry gets\n    ///         generated. It starts the DKG process.\n    /// @dev Can be called only by the random beacon contract.\n    /// @param relayEntry Relay entry.\n    function __beaconCallback(uint256 relayEntry, uint256) external {\n        require(\n            msg.sender == address(randomBeacon),\n            \"Caller is not the Random Beacon\"\n        );\n\n        dkg.start(relayEntry);\n    }\n\n    /// @notice Submits result of DKG protocol.\n    ///         The DKG result consists of result submitting member index,\n    ///         calculated group public key, bytes array of misbehaved members,\n    ///         concatenation of signatures from group members, indices of members\n    ///         corresponding to each signature and the list of group members.\n    ///         The result is registered optimistically and waits for an approval.\n    ///         The result can be challenged when it is believed to be incorrect.\n    ///         The challenge verifies the registered result i.a. it checks if members\n    ///         list corresponds to the expected set of members determined\n    ///         by the sortition pool.\n    /// @dev The message to be signed by each member is keccak256 hash of the\n    ///      chain ID, calculated group public key, misbehaved members indices\n    ///      and DKG start block. The calculated hash should be prefixed with\n    ///      `\\x19Ethereum signed message:\\n` before signing, so the message to\n    ///      sign is:\n    ///      `\\x19Ethereum signed message:\\n${keccak256(chainID,groupPubKey,misbehavedIndices,startBlock)}`\n    /// @param dkgResult DKG result.\n    function submitDkgResult(DKG.Result calldata dkgResult) external {\n        wallets.validatePublicKey(dkgResult.groupPubKey);\n        dkg.submitResult(dkgResult);\n    }\n\n    /// @notice Approves DKG result. Can be called when the challenge period for\n    ///         the submitted result is finished. Considers the submitted result\n    ///         as valid, bans misbehaved group members from the sortition pool\n    ///         rewards, and completes the group creation by activating the\n    ///         candidate group. For the first `resultSubmissionTimeout` blocks\n    ///         after the end of the challenge period can be called only by the\n    ///         DKG result submitter. After that time, can be called by anyone.\n    ///         A new wallet based on the DKG result details.\n    /// @param dkgResult Result to approve. Must match the submitted result\n    ///        stored during `submitDkgResult`.\n    function approveDkgResult(DKG.Result calldata dkgResult) external {\n        uint256 gasStart = gasleft();\n        uint32[] memory misbehavedMembers = dkg.approveResult(dkgResult);\n\n        (bytes32 walletID, bytes32 publicKeyX, bytes32 publicKeyY) = wallets\n            .addWallet(dkgResult.membersHash, dkgResult.groupPubKey);\n\n        emit WalletCreated(walletID, keccak256(abi.encode(dkgResult)));\n\n        if (misbehavedMembers.length > 0) {\n            sortitionPool.setRewardIneligibility(\n                misbehavedMembers,\n                // solhint-disable-next-line not-rely-on-time\n                block.timestamp + _sortitionPoolRewardsBanDuration\n            );\n        }\n\n        walletOwner.__ecdsaWalletCreatedCallback(\n            walletID,\n            publicKeyX,\n            publicKeyY\n        );\n\n        dkg.complete();\n\n        // Refund msg.sender's ETH for DKG result submission and result approval\n        reimbursementPool.refund(\n            _dkgResultSubmissionGas +\n                (gasStart - gasleft()) +\n                _dkgResultApprovalGasOffset,\n            msg.sender\n        );\n    }\n\n    /// @notice Notifies about seed for DKG delivery timeout. It is expected\n    ///         that a seed is delivered by the Random Beacon as a relay entry in a\n    ///         callback function.\n    function notifySeedTimeout() external {\n        uint256 gasStart = gasleft();\n\n        dkg.notifySeedTimeout();\n\n        reimbursementPool.refund(\n            (gasStart - gasleft()) + _notifySeedTimeoutGasOffset,\n            msg.sender\n        );\n    }\n\n    /// @notice Notifies about DKG timeout.\n    function notifyDkgTimeout() external {\n        uint256 gasStart = gasleft();\n\n        dkg.notifyDkgTimeout();\n\n        // Note that the offset is subtracted as it is expected that the cleanup\n        // performed on DKG timeout notification removes data from the storage\n        // which is recovering gas for the transaction.\n        reimbursementPool.refund(\n            (gasStart - gasleft()) - _notifyDkgTimeoutNegativeGasOffset,\n            msg.sender\n        );\n    }\n\n    /// @notice Challenges DKG result. If the submitted result is proved to be\n    ///         invalid it reverts the DKG back to the result submission phase.\n    /// @param dkgResult Result to challenge. Must match the submitted result\n    ///        stored during `submitDkgResult`.\n    /// @dev Due to EIP-150 1/64 of the gas is not forwarded to the call, and\n    ///      will be kept to execute the remaining operations in the function\n    ///      after the call inside the try-catch. To eliminate a class of\n    ///      attacks related to the gas limit manipulation, this function\n    ///      requires an extra amount of gas to be left at the end of the\n    ///      execution.\n    function challengeDkgResult(DKG.Result calldata dkgResult) external {\n        (\n            bytes32 maliciousDkgResultHash,\n            uint32 maliciousDkgResultSubmitterId\n        ) = dkg.challengeResult(dkgResult);\n\n        address maliciousDkgResultSubmitterAddress = sortitionPool\n            .getIDOperator(maliciousDkgResultSubmitterId);\n\n        address[] memory operatorWrapper = new address[](1);\n        operatorWrapper[0] = operatorToStakingProvider(\n            maliciousDkgResultSubmitterAddress\n        );\n\n        try\n            staking.seize(\n                _maliciousDkgResultSlashingAmount,\n                _maliciousDkgResultNotificationRewardMultiplier,\n                msg.sender,\n                operatorWrapper\n            )\n        {\n            // slither-disable-next-line reentrancy-events\n            emit DkgMaliciousResultSlashed(\n                maliciousDkgResultHash,\n                _maliciousDkgResultSlashingAmount,\n                maliciousDkgResultSubmitterAddress\n            );\n        } catch {\n            // Should never happen but we want to ensure a non-critical path\n            // failure from an external contract does not stop the challenge\n            // to complete.\n            emit DkgMaliciousResultSlashingFailed(\n                maliciousDkgResultHash,\n                _maliciousDkgResultSlashingAmount,\n                maliciousDkgResultSubmitterAddress\n            );\n        }\n\n        // Due to EIP-150, 1/64 of the gas is not forwarded to the call, and\n        // will be kept to execute the remaining operations in the function\n        // after the call inside the try-catch.\n        //\n        // To ensure there is no way for the caller to manipulate gas limit in\n        // such a way that the call inside try-catch fails with out-of-gas and\n        // the rest of the function is executed with the remaining 1/64 of gas,\n        // we require an extra gas amount to be left at the end of the call to\n        // `challengeDkgResult`.\n        dkg.requireChallengeExtraGas();\n    }\n\n    /// @notice Notifies about operators who are inactive. Using this function,\n    ///         a majority of the wallet signing group can decide about\n    ///         punishing specific group members who constantly fail doing their\n    ///         job. If the provided claim is proved to be valid and signed by\n    ///         sufficient number of group members, operators of members deemed\n    ///         as inactive are banned from sortition pool rewards for the\n    ///         duration specified by `sortitionPoolRewardsBanDuration` parameter.\n    ///         The function allows to signal about single operators being\n    ///         inactive as well as to signal wallet-wide heartbeat failures\n    ///         that are propagated to the wallet owner who should begin the\n    ///         procedure of moving responsibilities to another wallet given\n    ///         that the wallet who failed the heartbeat may soon be not able to\n    ///         function and provide new signatures.\n    ///         The sender of the claim must be one of the claim signers. This\n    ///         function can be called only for registered wallets\n    /// @param claim Operator inactivity claim.\n    /// @param nonce Current inactivity claim nonce for the given wallet signing\n    ///              group. Must be the same as the stored one.\n    /// @param groupMembers Identifiers of the wallet signing group members.\n    function notifyOperatorInactivity(\n        Inactivity.Claim calldata claim,\n        uint256 nonce,\n        uint32[] calldata groupMembers\n    ) external {\n        uint256 gasStart = gasleft();\n\n        bytes32 walletID = claim.walletID;\n\n        require(nonce == inactivityClaimNonce[walletID], \"Invalid nonce\");\n\n        (bytes32 pubKeyX, bytes32 pubKeyY) = wallets\n            .getWalletPublicKeyCoordinates(walletID);\n        bytes32 memberIdsHash = wallets.getWalletMembersIdsHash(walletID);\n\n        require(\n            memberIdsHash == keccak256(abi.encode(groupMembers)),\n            \"Invalid group members\"\n        );\n\n        uint32[] memory ineligibleOperators = Inactivity.verifyClaim(\n            sortitionPool,\n            claim,\n            bytes.concat(pubKeyX, pubKeyY),\n            nonce,\n            groupMembers\n        );\n\n        inactivityClaimNonce[walletID]++;\n\n        emit InactivityClaimed(walletID, nonce, msg.sender);\n\n        sortitionPool.setRewardIneligibility(\n            ineligibleOperators,\n            // solhint-disable-next-line not-rely-on-time\n            block.timestamp + _sortitionPoolRewardsBanDuration\n        );\n\n        if (claim.heartbeatFailed) {\n            walletOwner.__ecdsaWalletHeartbeatFailedCallback(\n                walletID,\n                pubKeyX,\n                pubKeyY\n            );\n        }\n\n        reimbursementPool.refund(\n            (gasStart - gasleft()) + _notifyOperatorInactivityGasOffset,\n            msg.sender\n        );\n    }\n\n    /// @notice Allows the wallet owner to add all signing group members of the\n    ///         wallet with the given ID to the slashing queue of the staking .\n    ///         contract. The notifier will receive reward per each group member\n    ///         from the staking contract notifiers treasury. The reward is\n    ///         scaled by the `rewardMultiplier` provided as a parameter.\n    /// @param amount Amount of tokens to seize from each signing group member.\n    /// @param rewardMultiplier Fraction of the staking contract notifiers\n    ///        reward the notifier should receive; should be between [0, 100].\n    /// @param notifier Address of the misbehavior notifier.\n    /// @param walletID ID of the wallet.\n    /// @param walletMembersIDs Identifiers of the wallet signing group members.\n    /// @dev Requirements:\n    ///      - The expression `keccak256(abi.encode(walletMembersIDs))` must\n    ///        be exactly the same as the hash stored under `membersIdsHash`\n    ///        for the given `walletID`. Those IDs are not directly stored\n    ///        in the contract for gas efficiency purposes but they can be\n    ///        read from appropriate `DkgResultSubmitted` and `DkgResultApproved`\n    ///        events.\n    ///      - `rewardMultiplier` must be between [0, 100].\n    ///      - This function does revert if staking contract call reverts.\n    ///        The calling code needs to handle the potential revert.\n    function seize(\n        uint96 amount,\n        uint256 rewardMultiplier,\n        address notifier,\n        bytes32 walletID,\n        uint32[] calldata walletMembersIDs\n    ) external onlyWalletOwner {\n        bytes32 memberIdsHash = wallets.getWalletMembersIdsHash(walletID);\n        require(\n            memberIdsHash == keccak256(abi.encode(walletMembersIDs)),\n            \"Invalid wallet members identifiers\"\n        );\n\n        address[] memory groupMembersAddresses = sortitionPool.getIDOperators(\n            walletMembersIDs\n        );\n        address[] memory stakingProvidersAddresses = new address[](\n            walletMembersIDs.length\n        );\n        for (uint256 i = 0; i < groupMembersAddresses.length; i++) {\n            stakingProvidersAddresses[i] = operatorToStakingProvider(\n                groupMembersAddresses[i]\n            );\n        }\n\n        staking.seize(\n            amount,\n            rewardMultiplier,\n            notifier,\n            stakingProvidersAddresses\n        );\n    }\n\n    /// @notice Checks if DKG result is valid for the current DKG.\n    /// @param result DKG result.\n    /// @return True if the result is valid. If the result is invalid it returns\n    ///         false and an error message.\n    function isDkgResultValid(DKG.Result calldata result)\n        external\n        view\n        returns (bool, string memory)\n    {\n        return dkg.isResultValid(result);\n    }\n\n    /// @notice Check current wallet creation state.\n    function getWalletCreationState() external view returns (DKG.State) {\n        return dkg.currentState();\n    }\n\n    /// @notice Checks whether the given operator is a member of the given\n    ///         wallet signing group.\n    /// @param walletID ID of the wallet.\n    /// @param walletMembersIDs Identifiers of the wallet signing group members.\n    /// @param operator Address of the checked operator.\n    /// @param walletMemberIndex Position of the operator in the wallet signing\n    ///        group members list.\n    /// @return True - if the operator is a member of the given wallet signing\n    ///         group. False - otherwise.\n    /// @dev Requirements:\n    ///      - The `operator` parameter must be an actual sortition pool operator.\n    ///      - The expression `keccak256(abi.encode(walletMembersIDs))` must\n    ///        be exactly the same as the hash stored under `membersIdsHash`\n    ///        for the given `walletID`. Those IDs are not directly stored\n    ///        in the contract for gas efficiency purposes but they can be\n    ///        read from appropriate `DkgResultSubmitted` and `DkgResultApproved`\n    ///        events.\n    ///      - The `walletMemberIndex` must be in range [1, walletMembersIDs.length]\n    function isWalletMember(\n        bytes32 walletID,\n        uint32[] calldata walletMembersIDs,\n        address operator,\n        uint256 walletMemberIndex\n    ) external view returns (bool) {\n        uint32 operatorID = sortitionPool.getOperatorID(operator);\n\n        require(operatorID != 0, \"Not a sortition pool operator\");\n\n        bytes32 memberIdsHash = wallets.getWalletMembersIdsHash(walletID);\n\n        require(\n            memberIdsHash == keccak256(abi.encode(walletMembersIDs)),\n            \"Invalid wallet members identifiers\"\n        );\n\n        require(\n            1 <= walletMemberIndex &&\n                walletMemberIndex <= walletMembersIDs.length,\n            \"Wallet member index is out of range\"\n        );\n\n        return walletMembersIDs[walletMemberIndex - 1] == operatorID;\n    }\n\n    /// @notice Checks if awaiting seed timed out.\n    /// @return True if awaiting seed timed out, false otherwise.\n    function hasSeedTimedOut() external view returns (bool) {\n        return dkg.hasSeedTimedOut();\n    }\n\n    /// @notice Checks if DKG timed out. The DKG timeout period includes time required\n    ///         for off-chain protocol execution and time for the result publication\n    ///         for all group members. After this time result cannot be submitted\n    ///         and DKG can be notified about the timeout.\n    /// @return True if DKG timed out, false otherwise.\n    function hasDkgTimedOut() external view returns (bool) {\n        return dkg.hasDkgTimedOut();\n    }\n\n    function getWallet(bytes32 walletID)\n        external\n        view\n        returns (Wallets.Wallet memory)\n    {\n        return wallets.registry[walletID];\n    }\n\n    /// @notice Gets public key of a wallet with a given wallet ID.\n    ///         The public key is returned in an uncompressed format as a 64-byte\n    ///         concatenation of X and Y coordinates.\n    /// @param walletID ID of the wallet.\n    /// @return Uncompressed public key of the wallet.\n    function getWalletPublicKey(bytes32 walletID)\n        external\n        view\n        returns (bytes memory)\n    {\n        return wallets.getWalletPublicKey(walletID);\n    }\n\n    /// @notice Checks if a wallet with the given ID is registered.\n    /// @param walletID Wallet's ID.\n    /// @return True if wallet is registered, false otherwise.\n    function isWalletRegistered(bytes32 walletID) external view returns (bool) {\n        return wallets.isWalletRegistered(walletID);\n    }\n\n    /// @notice The minimum authorization amount required so that operator can\n    ///         participate in ECDSA Wallet operations.\n    function minimumAuthorization() external view returns (uint96) {\n        return authorization.parameters.minimumAuthorization;\n    }\n\n    /// @notice Returns the current value of the staking provider's eligible\n    ///         stake. Eligible stake is defined as the currently authorized\n    ///         stake minus the pending authorization decrease. Eligible stake\n    ///         is what is used for operator's weight in the sortition pool.\n    ///         If the authorized stake minus the pending authorization decrease\n    ///         is below the minimum authorization, eligible stake is 0.\n    function eligibleStake(address stakingProvider)\n        external\n        view\n        returns (uint96)\n    {\n        return authorization.eligibleStake(staking, stakingProvider);\n    }\n\n    /// @notice Returns the amount of rewards available for withdrawal for the\n    ///         given staking provider. Reverts if staking provider has not\n    ///         registered the operator address.\n    function availableRewards(address stakingProvider)\n        external\n        view\n        returns (uint96)\n    {\n        address operator = stakingProviderToOperator(stakingProvider);\n        require(operator != address(0), \"Unknown operator\");\n        return sortitionPool.getAvailableRewards(operator);\n    }\n\n    /// @notice Returns the amount of stake that is pending authorization\n    ///         decrease for the given staking provider. If no authorization\n    ///         decrease has been requested, returns zero.\n    function pendingAuthorizationDecrease(address stakingProvider)\n        external\n        view\n        returns (uint96)\n    {\n        return authorization.pendingAuthorizationDecrease(stakingProvider);\n    }\n\n    /// @notice Returns the remaining time in seconds that needs to pass before\n    ///         the requested authorization decrease can be approved.\n    ///         If the sortition pool state was not updated yet by the operator\n    ///         after requesting the authorization decrease, returns\n    ///         `type(uint64).max`.\n    function remainingAuthorizationDecreaseDelay(address stakingProvider)\n        external\n        view\n        returns (uint64)\n    {\n        return\n            authorization.remainingAuthorizationDecreaseDelay(stakingProvider);\n    }\n\n    /// @notice Returns operator registered for the given staking provider.\n    function stakingProviderToOperator(address stakingProvider)\n        public\n        view\n        returns (address)\n    {\n        return authorization.stakingProviderToOperator[stakingProvider];\n    }\n\n    /// @notice Returns staking provider of the given operator.\n    function operatorToStakingProvider(address operator)\n        public\n        view\n        returns (address)\n    {\n        return authorization.operatorToStakingProvider[operator];\n    }\n\n    /// @notice Checks if the operator's authorized stake is in sync with\n    ///         operator's weight in the sortition pool.\n    ///         If the operator is not in the sortition pool and their\n    ///         authorized stake is non-zero, function returns false.\n    function isOperatorUpToDate(address operator) external view returns (bool) {\n        return\n            authorization.isOperatorUpToDate(staking, sortitionPool, operator);\n    }\n\n    /// @notice Returns true if the given operator is in the sortition pool.\n    ///         Otherwise, returns false.\n    function isOperatorInPool(address operator) external view returns (bool) {\n        return sortitionPool.isOperatorInPool(operator);\n    }\n\n    /// @notice Selects a new group of operators. Can only be called when DKG\n    ///         is in progress and the pool is locked.\n    ///         At least one operator has to be registered in the pool,\n    ///         otherwise the function fails reverting the transaction.\n    /// @return IDs of selected group members.\n    function selectGroup() external view returns (uint32[] memory) {\n        return sortitionPool.selectGroup(DKG.groupSize, bytes32(dkg.seed));\n    }\n\n    /// @notice Retrieves dkg parameters that were set in DKG library.\n    function dkgParameters() external view returns (DKG.Parameters memory) {\n        return dkg.parameters;\n    }\n\n    /// @notice Returns authorization-related parameters.\n    /// @dev The minimum authorization is also returned by `minimumAuthorization()`\n    ///      function, as a requirement of `IApplication` interface.\n    /// @return minimumAuthorization The minimum authorization amount required\n    ///         so that operator can participate in the random beacon. This\n    ///         amount is required to execute slashing for providing a malicious\n    ///         DKG result or when a relay entry times out.\n    /// @return authorizationDecreaseDelay Delay in seconds that needs to pass\n    ///         between the time authorization decrease is requested and the\n    ///         time that request gets approved. Protects against free-riders\n    ///         earning rewards and not being active in the network.\n    /// @return authorizationDecreaseChangePeriod Authorization decrease change\n    ///         period in seconds. It is the time, before authorization decrease\n    ///         delay end, during which the pending authorization decrease\n    ///         request can be overwritten.\n    ///         If set to 0, pending authorization decrease request can not be\n    ///         overwritten until the entire `authorizationDecreaseDelay` ends.\n    ///         If set to value equal `authorizationDecreaseDelay`, request can\n    ///         always be overwritten.\n    function authorizationParameters()\n        external\n        view\n        returns (\n            uint96 minimumAuthorization,\n            uint64 authorizationDecreaseDelay,\n            uint64 authorizationDecreaseChangePeriod\n        )\n    {\n        return (\n            authorization.parameters.minimumAuthorization,\n            authorization.parameters.authorizationDecreaseDelay,\n            authorization.parameters.authorizationDecreaseChangePeriod\n        );\n    }\n\n    /// @notice Retrieves reward-related parameters.\n    /// @return maliciousDkgResultNotificationRewardMultiplier Percentage of the\n    ///         staking contract malicious behavior notification reward which\n    ///         will be transferred to the notifier reporting about a malicious\n    ///         DKG result. Notifiers are rewarded from a notifiers treasury\n    ///         pool. For example, if notification reward is 1000 and the value\n    ///         of the multiplier is 5, the notifier will receive:\n    ///         5% of 1000 = 50 per each operator affected.\n    /// @return sortitionPoolRewardsBanDuration Duration of the sortition pool\n    ///         rewards ban imposed on operators who missed their turn for DKG\n    ///         result submission or who failed a heartbeat.\n    function rewardParameters()\n        external\n        view\n        returns (\n            uint256 maliciousDkgResultNotificationRewardMultiplier,\n            uint256 sortitionPoolRewardsBanDuration\n        )\n    {\n        return (\n            _maliciousDkgResultNotificationRewardMultiplier,\n            _sortitionPoolRewardsBanDuration\n        );\n    }\n\n    /// @notice Retrieves slashing-related parameters.\n    /// @return maliciousDkgResultSlashingAmount Slashing amount for submitting\n    ///         a malicious DKG result. Every DKG result submitted can be\n    ///         challenged for the time of `dkg.resultChallengePeriodLength`.\n    ///         If the DKG result submitted is challenged and proven to be\n    ///         malicious, the operator who submitted the malicious result is\n    ///         slashed for `_maliciousDkgResultSlashingAmount`.\n    function slashingParameters()\n        external\n        view\n        returns (uint96 maliciousDkgResultSlashingAmount)\n    {\n        return _maliciousDkgResultSlashingAmount;\n    }\n\n    /// @notice Retrieves gas-related parameters.\n    /// @return dkgResultSubmissionGas Calculated max gas cost for submitting\n    ///         a DKG result. This will be refunded as part of the DKG approval\n    ///         process. It is in the submitter's interest to not skip his\n    ///         priority turn on the approval, otherwise the refund of the DKG\n    ///         submission will be refunded to another group member that will\n    ///         call the DKG approve function.\n    /// @return dkgResultApprovalGasOffset Gas that is meant to balance the DKG\n    ///         result approval's overall cost. It can be updated by the\n    ///         governance based on the current market conditions.\n    /// @return notifyOperatorInactivityGasOffset Gas that is meant to balance\n    ///         the notification of an operator inactivity. It can be updated by\n    ///         the governance based on the current market conditions.\n    /// @return notifySeedTimeoutGasOffset Gas that is meant to balance the\n    ///         notification of a seed for DKG delivery timeout. It can be updated\n    ///         by the governance based on the current market conditions.\n    /// @return notifyDkgTimeoutNegativeGasOffset Gas that is meant to balance\n    ///         the notification of a DKG protocol execution timeout. It can be\n    ///         updated by the governance based on the current market conditions.\n    function gasParameters()\n        external\n        view\n        returns (\n            uint256 dkgResultSubmissionGas,\n            uint256 dkgResultApprovalGasOffset,\n            uint256 notifyOperatorInactivityGasOffset,\n            uint256 notifySeedTimeoutGasOffset,\n            uint256 notifyDkgTimeoutNegativeGasOffset\n        )\n    {\n        return (\n            _dkgResultSubmissionGas,\n            _dkgResultApprovalGasOffset,\n            _notifyOperatorInactivityGasOffset,\n            _notifySeedTimeoutGasOffset,\n            _notifyDkgTimeoutNegativeGasOffset\n        );\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@keep-network/random-beacon/contracts/ReimbursementPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n//\n// ▓▓▌ ▓▓ ▐▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▄\n// ▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n//   ▓▓▓▓▓▓    ▓▓▓▓▓▓▓▀    ▐▓▓▓▓▓▓    ▐▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n//   ▓▓▓▓▓▓▄▄▓▓▓▓▓▓▓▀      ▐▓▓▓▓▓▓▄▄▄▄         ▓▓▓▓▓▓▄▄▄▄         ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n//   ▓▓▓▓▓▓▓▓▓▓▓▓▓▀        ▐▓▓▓▓▓▓▓▓▓▓         ▓▓▓▓▓▓▓▓▓▓         ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n//   ▓▓▓▓▓▓▀▀▓▓▓▓▓▓▄       ▐▓▓▓▓▓▓▀▀▀▀         ▓▓▓▓▓▓▀▀▀▀         ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▀\n//   ▓▓▓▓▓▓   ▀▓▓▓▓▓▓▄     ▐▓▓▓▓▓▓     ▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌\n// ▓▓▓▓▓▓▓▓▓▓ █▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▓▓\n// ▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▓▓\n//\n//                           Trust math, not hardware.\n\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\ncontract ReimbursementPool is Ownable, ReentrancyGuard {\n    /// @notice Authorized contracts that can interact with the reimbursment pool.\n    ///         Authorization can be granted and removed by the owner.\n    mapping(address => bool) public isAuthorized;\n\n    /// @notice Static gas includes:\n    ///         - cost of the refund function\n    ///         - base transaction cost\n    uint256 public staticGas;\n\n    /// @notice Max gas price used to reimburse a transaction submitter. Protects\n    ///         against malicious operator-miners.\n    uint256 public maxGasPrice;\n\n    event StaticGasUpdated(uint256 newStaticGas);\n\n    event MaxGasPriceUpdated(uint256 newMaxGasPrice);\n\n    event SendingEtherFailed(uint256 refundAmount, address receiver);\n\n    event AuthorizedContract(address thirdPartyContract);\n\n    event UnauthorizedContract(address thirdPartyContract);\n\n    event FundsWithdrawn(uint256 withdrawnAmount, address receiver);\n\n    constructor(uint256 _staticGas, uint256 _maxGasPrice) {\n        staticGas = _staticGas;\n        maxGasPrice = _maxGasPrice;\n    }\n\n    /// @notice Receive ETH\n    receive() external payable {}\n\n    /// @notice Refunds ETH to a spender for executing specific transactions.\n    /// @dev Ignoring the result of sending ETH to a receiver is made on purpose.\n    ///      For EOA receiving ETH should always work. If a receiver is a smart\n    ///      contract, then we do not want to fail a transaction, because in some\n    ///      cases the refund is done at the very end of multiple calls where all\n    ///      the previous calls were already paid off. It is a receiver's smart\n    ///      contract resposibility to make sure it can receive ETH.\n    /// @dev Only authorized contracts are allowed calling this function.\n    /// @param gasSpent Gas spent on a transaction that needs to be reimbursed.\n    /// @param receiver Address where the reimbursment is sent.\n    function refund(uint256 gasSpent, address receiver) external nonReentrant {\n        require(\n            isAuthorized[msg.sender],\n            \"Contract is not authorized for a refund\"\n        );\n        require(receiver != address(0), \"Receiver's address cannot be zero\");\n\n        uint256 gasPrice = tx.gasprice < maxGasPrice\n            ? tx.gasprice\n            : maxGasPrice;\n\n        uint256 refundAmount = (gasSpent + staticGas) * gasPrice;\n\n        /* solhint-disable avoid-low-level-calls */\n        // slither-disable-next-line low-level-calls,unchecked-lowlevel\n        (bool sent, ) = receiver.call{value: refundAmount}(\"\");\n        /* solhint-enable avoid-low-level-calls */\n        if (!sent) {\n            // slither-disable-next-line reentrancy-events\n            emit SendingEtherFailed(refundAmount, receiver);\n        }\n    }\n\n    /// @notice Authorize a contract that can interact with this reimbursment pool.\n    ///         Can be authorized by the owner only.\n    /// @param _contract Authorized contract.\n    function authorize(address _contract) external onlyOwner {\n        isAuthorized[_contract] = true;\n\n        emit AuthorizedContract(_contract);\n    }\n\n    /// @notice Unauthorize a contract that was previously authorized to interact\n    ///         with this reimbursment pool. Can be unauthorized by the\n    ///         owner only.\n    /// @param _contract Authorized contract.\n    function unauthorize(address _contract) external onlyOwner {\n        delete isAuthorized[_contract];\n\n        emit UnauthorizedContract(_contract);\n    }\n\n    /// @notice Setting a static gas cost for executing a transaction. Can be set\n    ///         by the owner only.\n    /// @param _staticGas Static gas cost.\n    function setStaticGas(uint256 _staticGas) external onlyOwner {\n        staticGas = _staticGas;\n\n        emit StaticGasUpdated(_staticGas);\n    }\n\n    /// @notice Setting a max gas price for transactions. Can be set by the\n    ///         owner only.\n    /// @param _maxGasPrice Max gas price used to reimburse tx submitters.\n    function setMaxGasPrice(uint256 _maxGasPrice) external onlyOwner {\n        maxGasPrice = _maxGasPrice;\n\n        emit MaxGasPriceUpdated(_maxGasPrice);\n    }\n\n    /// @notice Withdraws all ETH from this pool which are sent to a given\n    ///         address. Can be set by the owner only.\n    /// @param receiver An address where ETH is sent.\n    function withdrawAll(address receiver) external onlyOwner {\n        withdraw(address(this).balance, receiver);\n    }\n\n    /// @notice Withdraws ETH amount from this pool which are sent to a given\n    ///         address. Can be set by the owner only.\n    /// @param amount Amount to withdraw from the pool.\n    /// @param receiver An address where ETH is sent.\n    function withdraw(uint256 amount, address receiver) public onlyOwner {\n        require(\n            address(this).balance >= amount,\n            \"Insufficient contract balance\"\n        );\n        require(receiver != address(0), \"Receiver's address cannot be zero\");\n\n        emit FundsWithdrawn(amount, receiver);\n\n        /* solhint-disable avoid-low-level-calls */\n        // slither-disable-next-line low-level-calls,arbitrary-send\n        (bool sent, ) = receiver.call{value: amount}(\"\");\n        /* solhint-enable avoid-low-level-calls */\n        require(sent, \"Failed to send Ether\");\n    }\n}\n"
    },
    "@keep-network/random-beacon/contracts/api/IRandomBeacon.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n//\n// ▓▓▌ ▓▓ ▐▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▄\n// ▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n//   ▓▓▓▓▓▓    ▓▓▓▓▓▓▓▀    ▐▓▓▓▓▓▓    ▐▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n//   ▓▓▓▓▓▓▄▄▓▓▓▓▓▓▓▀      ▐▓▓▓▓▓▓▄▄▄▄         ▓▓▓▓▓▓▄▄▄▄         ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n//   ▓▓▓▓▓▓▓▓▓▓▓▓▓▀        ▐▓▓▓▓▓▓▓▓▓▓         ▓▓▓▓▓▓▓▓▓▓         ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n//   ▓▓▓▓▓▓▀▀▓▓▓▓▓▓▄       ▐▓▓▓▓▓▓▀▀▀▀         ▓▓▓▓▓▓▀▀▀▀         ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▀\n//   ▓▓▓▓▓▓   ▀▓▓▓▓▓▓▄     ▐▓▓▓▓▓▓     ▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌\n// ▓▓▓▓▓▓▓▓▓▓ █▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▓▓\n// ▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▓▓\n//\n//                           Trust math, not hardware.\n\npragma solidity 0.8.17;\n\nimport \"./IRandomBeaconConsumer.sol\";\n\n/// @title Random Beacon interface\ninterface IRandomBeacon {\n    /// @notice Creates a request to generate a new relay entry. Requires a\n    ///         request fee denominated in T token.\n    /// @param callbackContract Beacon consumer callback contract.\n    function requestRelayEntry(IRandomBeaconConsumer callbackContract) external;\n}\n"
    },
    "contracts/api/IWalletRegistry.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n//\n// ▓▓▌ ▓▓ ▐▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▄\n// ▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n//   ▓▓▓▓▓▓    ▓▓▓▓▓▓▓▀    ▐▓▓▓▓▓▓    ▐▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n//   ▓▓▓▓▓▓▄▄▓▓▓▓▓▓▓▀      ▐▓▓▓▓▓▓▄▄▄▄         ▓▓▓▓▓▓▄▄▄▄         ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n//   ▓▓▓▓▓▓▓▓▓▓▓▓▓▀        ▐▓▓▓▓▓▓▓▓▓▓         ▓▓▓▓▓▓▓▓▓▓         ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n//   ▓▓▓▓▓▓▀▀▓▓▓▓▓▓▄       ▐▓▓▓▓▓▓▀▀▀▀         ▓▓▓▓▓▓▀▀▀▀         ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▀\n//   ▓▓▓▓▓▓   ▀▓▓▓▓▓▓▄     ▐▓▓▓▓▓▓     ▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌\n// ▓▓▓▓▓▓▓▓▓▓ █▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▓▓\n// ▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▓▓\n//\n//                           Trust math, not hardware.\n\npragma solidity 0.8.17;\n\nimport \"../libraries/EcdsaDkg.sol\";\n\ninterface IWalletRegistry {\n    /// @notice Requests a new wallet creation.\n    /// @dev Only the Wallet Owner can call this function.\n    function requestNewWallet() external;\n\n    /// @notice Closes an existing wallet.\n    /// @param walletID ID of the wallet.\n    /// @dev Only the Wallet Owner can call this function.\n    function closeWallet(bytes32 walletID) external;\n\n    /// @notice Adds all signing group members of the wallet with the given ID\n    ///         to the slashing queue of the staking contract. The notifier will\n    ///         receive reward per each group member from the staking contract\n    ///         notifiers treasury. The reward is scaled by the\n    ///         `rewardMultiplier` provided as a parameter.\n    /// @param amount Amount of tokens to seize from each signing group member\n    /// @param rewardMultiplier Fraction of the staking contract notifiers\n    ///        reward the notifier should receive; should be between [0, 100]\n    /// @param notifier Address of the misbehavior notifier\n    /// @param walletID ID of the wallet\n    /// @param walletMembersIDs Identifiers of the wallet signing group members\n    /// @dev Only the Wallet Owner can call this function.\n    ///      Requirements:\n    ///      - The expression `keccak256(abi.encode(walletMembersIDs))` must\n    ///        be exactly the same as the hash stored under `membersIdsHash`\n    ///        for the given `walletID`. Those IDs are not directly stored\n    ///        in the contract for gas efficiency purposes but they can be\n    ///        read from appropriate `DkgResultSubmitted` and `DkgResultApproved`\n    ///        events.\n    ///      - `rewardMultiplier` must be between [0, 100].\n    ///      - This function does revert if staking contract call reverts.\n    ///        The calling code needs to handle the potential revert.\n    function seize(\n        uint96 amount,\n        uint256 rewardMultiplier,\n        address notifier,\n        bytes32 walletID,\n        uint32[] calldata walletMembersIDs\n    ) external;\n\n    /// @notice Gets public key of a wallet with a given wallet ID.\n    ///         The public key is returned in an uncompressed format as a 64-byte\n    ///         concatenation of X and Y coordinates.\n    /// @param walletID ID of the wallet.\n    /// @return Uncompressed public key of the wallet.\n    function getWalletPublicKey(bytes32 walletID)\n        external\n        view\n        returns (bytes memory);\n\n    /// @notice Check current wallet creation state.\n    function getWalletCreationState() external view returns (EcdsaDkg.State);\n\n    /// @notice Checks whether the given operator is a member of the given\n    ///         wallet signing group.\n    /// @param walletID ID of the wallet\n    /// @param walletMembersIDs Identifiers of the wallet signing group members\n    /// @param operator Address of the checked operator\n    /// @param walletMemberIndex Position of the operator in the wallet signing\n    ///        group members list\n    /// @return True - if the operator is a member of the given wallet signing\n    ///         group. False - otherwise.\n    /// @dev Requirements:\n    ///      - The `operator` parameter must be an actual sortition pool operator.\n    ///      - The expression `keccak256(abi.encode(walletMembersIDs))` must\n    ///        be exactly the same as the hash stored under `membersIdsHash`\n    ///        for the given `walletID`. Those IDs are not directly stored\n    ///        in the contract for gas efficiency purposes but they can be\n    ///        read from appropriate `DkgResultSubmitted` and `DkgResultApproved`\n    ///        events.\n    ///      - The `walletMemberIndex` must be in range [1, walletMembersIDs.length]\n    function isWalletMember(\n        bytes32 walletID,\n        uint32[] calldata walletMembersIDs,\n        address operator,\n        uint256 walletMemberIndex\n    ) external view returns (bool);\n}\n"
    },
    "contracts/libraries/Wallets.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n//\n// ▓▓▌ ▓▓ ▐▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▄\n// ▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n//   ▓▓▓▓▓▓    ▓▓▓▓▓▓▓▀    ▐▓▓▓▓▓▓    ▐▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n//   ▓▓▓▓▓▓▄▄▓▓▓▓▓▓▓▀      ▐▓▓▓▓▓▓▄▄▄▄         ▓▓▓▓▓▓▄▄▄▄         ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n//   ▓▓▓▓▓▓▓▓▓▓▓▓▓▀        ▐▓▓▓▓▓▓▓▓▓▓         ▓▓▓▓▓▓▓▓▓▓         ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n//   ▓▓▓▓▓▓▀▀▓▓▓▓▓▓▄       ▐▓▓▓▓▓▓▀▀▀▀         ▓▓▓▓▓▓▀▀▀▀         ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▀\n//   ▓▓▓▓▓▓   ▀▓▓▓▓▓▓▄     ▐▓▓▓▓▓▓     ▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌\n// ▓▓▓▓▓▓▓▓▓▓ █▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▓▓\n// ▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▓▓\n//\n//                           Trust math, not hardware.\n\npragma solidity 0.8.17;\n\nlibrary Wallets {\n    struct Wallet {\n        // Keccak256 hash of group members identifiers array. Group members do not\n        // include operators selected by the sortition pool that misbehaved during DKG.\n        bytes32 membersIdsHash;\n        // Uncompressed ECDSA public key stored as X and Y coordinates (32 bytes each).\n        bytes32 publicKeyX;\n        bytes32 publicKeyY;\n        // This struct doesn't contain `__gap` property as the structure is stored\n        // in a mapping, mappings store values in different slots and they are\n        // not contiguous with other values.\n    }\n\n    struct Data {\n        // Mapping of keccak256 hashes of wallet public keys to wallet details.\n        // Hash of public key is considered an unique wallet identifier.\n        mapping(bytes32 => Wallet) registry;\n        // Reserved storage space in case we need to add more variables.\n        // See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n        // slither-disable-next-line unused-state\n        uint256[49] __gap;\n    }\n\n    /// @notice Performs preliminary validation of a new group public key.\n    ///         The group public key must be unique and have 64 bytes in length.\n    ///         If the validation fails, the function reverts. This function\n    ///         must be called first for a public key of a wallet added with\n    ///         `addWallet` function.\n    /// @param publicKey Uncompressed public key of a new wallet.\n    function validatePublicKey(Data storage self, bytes calldata publicKey)\n        internal\n        view\n    {\n        require(publicKey.length == 64, \"Invalid length of the public key\");\n\n        bytes32 walletID = keccak256(publicKey);\n        require(\n            self.registry[walletID].publicKeyX == bytes32(0),\n            \"Wallet with the given public key already exists\"\n        );\n\n        bytes32 publicKeyX = bytes32(publicKey[:32]);\n        require(publicKeyX != bytes32(0), \"Wallet public key must be non-zero\");\n    }\n\n    /// @notice Registers a new wallet. This function does not validate\n    ///         parameters. The code calling this function must call\n    ///         `validatePublicKey` first.\n    /// @dev Uses a public key hash as a unique identifier of a wallet.\n    /// @param membersIdsHash Keccak256 hash of group members identifiers array\n    /// @param publicKey Uncompressed public key\n    /// @return walletID Wallet's ID\n    /// @return publicKeyX Wallet's public key's X coordinate\n    /// @return publicKeyY Wallet's public key's Y coordinate\n    function addWallet(\n        Data storage self,\n        bytes32 membersIdsHash,\n        bytes calldata publicKey\n    )\n        internal\n        returns (\n            bytes32 walletID,\n            bytes32 publicKeyX,\n            bytes32 publicKeyY\n        )\n    {\n        walletID = keccak256(publicKey);\n\n        publicKeyX = bytes32(publicKey[:32]);\n        publicKeyY = bytes32(publicKey[32:]);\n\n        self.registry[walletID].membersIdsHash = membersIdsHash;\n        self.registry[walletID].publicKeyX = publicKeyX;\n        self.registry[walletID].publicKeyY = publicKeyY;\n    }\n\n    /// @notice Deletes wallet with the given ID from the registry. Reverts\n    ///         if wallet with the given ID has not been registered or if it\n    ///         has already been closed.\n    function deleteWallet(Data storage self, bytes32 walletID) internal {\n        require(\n            isWalletRegistered(self, walletID),\n            \"Wallet with the given ID has not been registered\"\n        );\n\n        delete self.registry[walletID];\n    }\n\n    /// @notice Checks if a wallet with the given ID is registered.\n    /// @param walletID Wallet's ID\n    /// @return True if a wallet is registered, false otherwise\n    function isWalletRegistered(Data storage self, bytes32 walletID)\n        internal\n        view\n        returns (bool)\n    {\n        return self.registry[walletID].publicKeyX != bytes32(0);\n    }\n\n    /// @notice Returns Keccak256 hash of the wallet signing group members\n    ///         identifiers array. Group members do not include operators\n    ///         selected by the sortition pool that misbehaved during DKG.\n    ///         Reverts if wallet with the given ID is not registered.\n    /// @param walletID ID of the wallet\n    /// @return Wallet signing group members hash\n    function getWalletMembersIdsHash(Data storage self, bytes32 walletID)\n        internal\n        view\n        returns (bytes32)\n    {\n        require(\n            isWalletRegistered(self, walletID),\n            \"Wallet with the given ID has not been registered\"\n        );\n\n        return self.registry[walletID].membersIdsHash;\n    }\n\n    /// @notice Gets public key of a wallet with the given wallet ID.\n    ///         The public key is returned as X and Y coordinates.\n    ///         Reverts if wallet with the given ID is not registered.\n    /// @param walletID ID of the wallet\n    /// @return x Public key X coordinate\n    /// @return y Public key Y coordinate\n    function getWalletPublicKeyCoordinates(Data storage self, bytes32 walletID)\n        internal\n        view\n        returns (bytes32 x, bytes32 y)\n    {\n        require(\n            isWalletRegistered(self, walletID),\n            \"Wallet with the given ID has not been registered\"\n        );\n\n        Wallet storage wallet = self.registry[walletID];\n\n        return (wallet.publicKeyX, wallet.publicKeyY);\n    }\n\n    /// @notice Gets public key of a wallet with the given wallet ID.\n    ///         The public key is returned in an uncompressed format as a 64-byte\n    ///         concatenation of X and Y coordinates.\n    ///         Reverts if wallet with the given ID is not registered.\n    /// @param walletID ID of the wallet\n    /// @return Uncompressed public key of the wallet\n    function getWalletPublicKey(Data storage self, bytes32 walletID)\n        internal\n        view\n        returns (bytes memory)\n    {\n        (bytes32 x, bytes32 y) = getWalletPublicKeyCoordinates(self, walletID);\n        return bytes.concat(x, y);\n    }\n}\n"
    },
    "contracts/libraries/EcdsaAuthorization.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n//\n// ▓▓▌ ▓▓ ▐▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▄\n// ▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n//   ▓▓▓▓▓▓    ▓▓▓▓▓▓▓▀    ▐▓▓▓▓▓▓    ▐▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n//   ▓▓▓▓▓▓▄▄▓▓▓▓▓▓▓▀      ▐▓▓▓▓▓▓▄▄▄▄         ▓▓▓▓▓▓▄▄▄▄         ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n//   ▓▓▓▓▓▓▓▓▓▓▓▓▓▀        ▐▓▓▓▓▓▓▓▓▓▓         ▓▓▓▓▓▓▓▓▓▓         ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n//   ▓▓▓▓▓▓▀▀▓▓▓▓▓▓▄       ▐▓▓▓▓▓▓▀▀▀▀         ▓▓▓▓▓▓▀▀▀▀         ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▀\n//   ▓▓▓▓▓▓   ▀▓▓▓▓▓▓▄     ▐▓▓▓▓▓▓     ▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌\n// ▓▓▓▓▓▓▓▓▓▓ █▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▓▓\n// ▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▓▓\n//\n//\n\npragma solidity 0.8.17;\n\nimport \"@keep-network/sortition-pools/contracts/SortitionPool.sol\";\nimport \"@threshold-network/solidity-contracts/contracts/staking/IStaking.sol\";\n\n/// @notice Library managing the state of stake authorizations for ECDSA\n///         operator contract and the presence of operators in the sortition\n///         pool based on the stake authorized for them.\nlibrary EcdsaAuthorization {\n    struct Parameters {\n        // The minimum authorization required by ECDSA application so that\n        // operator can join the sortition pool and do the work.\n        uint96 minimumAuthorization;\n        // Authorization decrease delay in seconds between the time\n        // authorization decrease is requested and the time the authorization\n        // decrease can be approved. It is always the same value, no matter if\n        // authorization decrease amount is small, significant, or if it is\n        // a decrease to zero.\n        uint64 authorizationDecreaseDelay;\n        // The time period before the authorization decrease delay end,\n        // during which the authorization decrease request can be overwritten.\n        //\n        // When the request is overwritten, the authorization decrease delay is\n        // reset.\n        //\n        // For example, if `authorizationDecraseChangePeriod` is set to 4\n        // days, `authorizationDecreaseDelay` is set to 14 days, and someone\n        // requested authorization decrease, it means they can not\n        // request another decrease for the first 10 days. After 10 days pass,\n        // they can request again and overwrite the previous authorization\n        // decrease request. The delay time will reset for them and they\n        // will have to wait another 10 days to alter it and 14 days to\n        // approve it.\n        //\n        // This value protects against malicious operators who manipulate\n        // their weight by overwriting authorization decrease request, and\n        // lowering or increasing their eligible stake this way.\n        //\n        // If set to a value equal to `authorizationDecreaseDelay, it means\n        // that authorization decrease request can be always overwritten.\n        // If set to zero, it means authorization decrease request can not be\n        // overwritten until the delay end, and one needs to wait for the entire\n        // authorization decrease delay to approve their decrease and request\n        // for another one or to overwrite the pending one.\n        //\n        //   (1) authorization decrease requested timestamp\n        //   (2) from this moment authorization decrease request can be\n        //       overwritten\n        //   (3) from this moment authorization decrease request can be\n        //       approved, assuming it was NOT overwritten in (2)\n        //\n        //  (1)                            (2)                        (3)\n        // --x------------------------------x--------------------------x---->\n        //   |                               \\________________________/\n        //   |                             authorizationDecreaseChangePeriod\n        //    \\______________________________________________________/\n        //                   authorizationDecreaseDelay\n        //\n        uint64 authorizationDecreaseChangePeriod;\n        // This struct doesn't contain `__gap` property as the structure is\n        // stored inside `Data` struct, that already have a gap that can be used\n        // on upgrade.\n    }\n\n    struct AuthorizationDecrease {\n        uint96 decreasingBy; // amount\n        uint64 decreasingAt; // timestamp\n    }\n\n    struct Data {\n        Parameters parameters;\n        mapping(address => address) stakingProviderToOperator;\n        mapping(address => address) operatorToStakingProvider;\n        mapping(address => AuthorizationDecrease) pendingDecreases;\n        // Reserved storage space in case we need to add more variables.\n        // See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n        // slither-disable-next-line unused-state\n        uint256[46] __gap;\n    }\n\n    event OperatorRegistered(\n        address indexed stakingProvider,\n        address indexed operator\n    );\n\n    event AuthorizationIncreased(\n        address indexed stakingProvider,\n        address indexed operator,\n        uint96 fromAmount,\n        uint96 toAmount\n    );\n\n    event AuthorizationDecreaseRequested(\n        address indexed stakingProvider,\n        address indexed operator,\n        uint96 fromAmount,\n        uint96 toAmount,\n        uint64 decreasingAt\n    );\n\n    event AuthorizationDecreaseApproved(address indexed stakingProvider);\n\n    event InvoluntaryAuthorizationDecreaseFailed(\n        address indexed stakingProvider,\n        address indexed operator,\n        uint96 fromAmount,\n        uint96 toAmount\n    );\n\n    event OperatorJoinedSortitionPool(\n        address indexed stakingProvider,\n        address indexed operator\n    );\n\n    event OperatorStatusUpdated(\n        address indexed stakingProvider,\n        address indexed operator\n    );\n\n    /// @notice Sets the minimum authorization for ECDSA application. Without\n    ///         at least the minimum authorization, staking provider is not\n    ///         eligible to join and operate in the network.\n    function setMinimumAuthorization(\n        Data storage self,\n        uint96 _minimumAuthorization\n    ) internal {\n        self.parameters.minimumAuthorization = _minimumAuthorization;\n    }\n\n    /// @notice Sets the authorization decrease delay. It is the time in seconds\n    ///         that needs to pass between the time authorization decrease is\n    ///         requested and the time the authorization decrease can be\n    ///         approved, no matter the authorization decrease amount.\n    function setAuthorizationDecreaseDelay(\n        Data storage self,\n        uint64 _authorizationDecreaseDelay\n    ) internal {\n        self\n            .parameters\n            .authorizationDecreaseDelay = _authorizationDecreaseDelay;\n    }\n\n    /// @notice Sets the authorization decrease change period. It is the time\n    ///         period before the authorization decrease delay end,\n    ///         during which the authorization decrease request can be\n    ///         overwritten.\n    function setAuthorizationDecreaseChangePeriod(\n        Data storage self,\n        uint64 _authorizationDecreaseChangePeriod\n    ) internal {\n        self\n            .parameters\n            .authorizationDecreaseChangePeriod = _authorizationDecreaseChangePeriod;\n    }\n\n    /// @notice Used by staking provider to set operator address that will\n    ///         operate ECDSA node. The given staking provider can set operator\n    ///         address only one time. The operator address can not be changed\n    ///         and must be unique. Reverts if the operator is already set for\n    ///         the staking provider or if the operator address is already in\n    ///         use. Reverts if there is a pending authorization decrease for\n    ///         the staking provider.\n    function registerOperator(Data storage self, address operator) internal {\n        address stakingProvider = msg.sender;\n\n        require(operator != address(0), \"Operator can not be zero address\");\n        require(\n            self.stakingProviderToOperator[stakingProvider] == address(0),\n            \"Operator already set for the staking provider\"\n        );\n        require(\n            self.operatorToStakingProvider[operator] == address(0),\n            \"Operator address already in use\"\n        );\n\n        // Authorization request for a staking provider who has not yet\n        // registered their operator can be approved immediately.\n        // We need to make sure that the approval happens before operator\n        // is registered to do not let the operator join the sortition pool\n        // with an unresolved authorization decrease request that can be\n        // approved at any point.\n        AuthorizationDecrease storage decrease = self.pendingDecreases[\n            stakingProvider\n        ];\n        require(\n            decrease.decreasingAt == 0,\n            \"There is a pending authorization decrease request\"\n        );\n\n        emit OperatorRegistered(stakingProvider, operator);\n\n        self.stakingProviderToOperator[stakingProvider] = operator;\n        self.operatorToStakingProvider[operator] = stakingProvider;\n    }\n\n    /// @notice Used by T staking contract to inform the application that the\n    ///         authorized stake amount for the given staking provider increased.\n    ///\n    ///         Reverts if the authorization amount is below the minimum.\n    ///\n    ///         The function is not updating the sortition pool. Sortition pool\n    ///         state needs to be updated by the operator with a call to\n    ///         `joinSortitionPool` or `updateOperatorStatus`.\n    ///\n    /// @dev Should only be callable by T staking contract.\n    function authorizationIncreased(\n        Data storage self,\n        address stakingProvider,\n        uint96 fromAmount,\n        uint96 toAmount\n    ) internal {\n        require(\n            toAmount >= self.parameters.minimumAuthorization,\n            \"Authorization below the minimum\"\n        );\n\n        // Note that this function does not require the operator address to be\n        // set for the given staking provider. This allows the stake owner\n        // who is also an authorizer to increase the authorization before the\n        // staking provider sets the operator. This allows delegating stake\n        // and increasing authorization immediately one after another without\n        // having to wait for the staking provider to do their part.\n\n        address operator = self.stakingProviderToOperator[stakingProvider];\n        emit AuthorizationIncreased(\n            stakingProvider,\n            operator,\n            fromAmount,\n            toAmount\n        );\n    }\n\n    /// @notice Used by T staking contract to inform the application that the\n    ///         authorization decrease for the given staking provider has been\n    ///         requested.\n    ///\n    ///         Reverts if the amount after deauthorization would be non-zero\n    ///         and lower than the minimum authorization.\n    ///\n    ///         Reverts if another authorization decrease request is pending for\n    ///         the staking provider and not enough time passed since the\n    ///         original request (see `authorizationDecreaseChangePeriod`).\n    ///\n    ///         If the operator is not known (`registerOperator` was not called)\n    ///         it lets to `approveAuthorizationDecrease` immediately. If the\n    ///         operator is known (`registerOperator` was called), the operator\n    ///         needs to update state of the sortition pool with a call to\n    ///         `joinSortitionPool` or `updateOperatorStatus`. After the\n    ///         sortition pool state is in sync, authorization decrease delay\n    ///         starts.\n    ///\n    ///         After authorization decrease delay passes, authorization\n    ///         decrease request needs to be approved with a call to\n    ///         `approveAuthorizationDecrease` function.\n    ///\n    ///         If there is a pending authorization decrease request, it is\n    ///         overwritten, but only if enough time passed since the original\n    ///         request. Otherwise, the function reverts.\n    ///\n    /// @dev Should only be callable by T staking contract.\n    function authorizationDecreaseRequested(\n        Data storage self,\n        address stakingProvider,\n        uint96 fromAmount,\n        uint96 toAmount\n    ) internal {\n        require(\n            toAmount == 0 || toAmount >= self.parameters.minimumAuthorization,\n            \"Authorization amount should be 0 or above the minimum\"\n        );\n\n        address operator = self.stakingProviderToOperator[stakingProvider];\n\n        uint64 decreasingAt;\n\n        if (operator == address(0)) {\n            // Operator is not known. It means `registerOperator` was not\n            // called yet, and there is no chance the operator could\n            // call `joinSortitionPool`. We can let to approve authorization\n            // decrease immediately because that operator was never in the\n            // sortition pool.\n\n            // solhint-disable-next-line not-rely-on-time\n            decreasingAt = uint64(block.timestamp);\n        } else {\n            // Operator is known. It means that this operator is or was in\n            // the sortition pool. Before authorization decrease delay starts,\n            // the operator needs to update the state of the sortition pool\n            // with a call to `joinSortitionPool` or `updateOperatorStatus`.\n            // For now, we set `decreasingAt` as \"never decreasing\" and let\n            // it be updated by `joinSortitionPool` or `updateOperatorStatus`\n            // once we know the sortition pool is in sync.\n            decreasingAt = type(uint64).max;\n        }\n\n        uint96 decreasingBy = fromAmount - toAmount;\n\n        AuthorizationDecrease storage decreaseRequest = self.pendingDecreases[\n            stakingProvider\n        ];\n\n        uint64 pendingDecreaseAt = decreaseRequest.decreasingAt;\n        if (pendingDecreaseAt != 0 && pendingDecreaseAt != type(uint64).max) {\n            // If there is already a pending authorization decrease request for\n            // this staking provider and that request has been activated\n            // (sortition pool was updated), require enough time to pass before\n            // it can be overwritten.\n            require(\n                // solhint-disable-next-line not-rely-on-time\n                block.timestamp >=\n                    pendingDecreaseAt -\n                        self.parameters.authorizationDecreaseChangePeriod,\n                \"Not enough time passed since the original request\"\n            );\n        }\n\n        decreaseRequest.decreasingBy = decreasingBy;\n        decreaseRequest.decreasingAt = decreasingAt;\n\n        emit AuthorizationDecreaseRequested(\n            stakingProvider,\n            operator,\n            fromAmount,\n            toAmount,\n            decreasingAt\n        );\n    }\n\n    /// @notice Approves the previously registered authorization decrease\n    ///         request. Reverts if authorization decrease delay have not passed\n    ///         yet or if the authorization decrease was not requested for the\n    ///         given staking provider.\n    function approveAuthorizationDecrease(\n        Data storage self,\n        IStaking tokenStaking,\n        address stakingProvider\n    ) internal {\n        AuthorizationDecrease storage decrease = self.pendingDecreases[\n            stakingProvider\n        ];\n        require(\n            decrease.decreasingAt > 0,\n            \"Authorization decrease not requested\"\n        );\n        require(\n            decrease.decreasingAt != type(uint64).max,\n            \"Authorization decrease request not activated\"\n        );\n        require(\n            // solhint-disable-next-line not-rely-on-time\n            block.timestamp >= decrease.decreasingAt,\n            \"Authorization decrease delay not passed\"\n        );\n\n        emit AuthorizationDecreaseApproved(stakingProvider);\n\n        // slither-disable-next-line unused-return\n        tokenStaking.approveAuthorizationDecrease(stakingProvider);\n        delete self.pendingDecreases[stakingProvider];\n    }\n\n    /// @notice Used by T staking contract to inform the application the\n    ///         authorization has been decreased for the given staking provider\n    ///         involuntarily, as a result of slashing.\n    ///\n    ///         If the operator is not known (`registerOperator` was not called)\n    ///         the function does nothing. The operator was never in a sortition\n    ///         pool so there is nothing to update.\n    ///\n    ///         If the operator is known, sortition pool is unlocked, and the\n    ///         operator is in the sortition pool, the sortition pool state is\n    ///         updated. If the sortition pool is locked, update needs to be\n    ///         postponed. Every other staker is incentivized to call\n    ///         `updateOperatorStatus` for the problematic operator to increase\n    ///         their own rewards in the pool.\n    ///\n    /// @dev Should only be callable by T staking contract.\n    function involuntaryAuthorizationDecrease(\n        Data storage self,\n        IStaking tokenStaking,\n        SortitionPool sortitionPool,\n        address stakingProvider,\n        uint96 fromAmount,\n        uint96 toAmount\n    ) internal {\n        address operator = self.stakingProviderToOperator[stakingProvider];\n\n        if (operator == address(0)) {\n            // Operator is not known. It means `registerOperator` was not\n            // called yet, and there is no chance the operator could\n            // call `joinSortitionPool`. We can just ignore this update because\n            // operator was never in the sortition pool.\n            return;\n        } else {\n            // Operator is known. It means that this operator is or was in the\n            // sortition pool and the sortition pool may need to be updated.\n            //\n            // If the sortition pool is not locked and the operator is in the\n            // sortition pool, we are updating it.\n            //\n            // To keep stakes synchronized between applications when staking\n            // providers are slashed, without the risk of running out of gas,\n            // the staking contract queues up slashings and let users process\n            // the transactions. When an application slashes one or more staking\n            // providers, it adds them to the slashing queue on the staking\n            // contract. A queue entry contains the staking provider’s address\n            // and the amount they are due to be slashed.\n            //\n            // When there is at least one staking provider in the slashing\n            // queue, any account can submit a transaction processing one or\n            // more staking providers' slashings, and collecting a reward for\n            // doing so. A queued slashing is processed by updating the staking\n            // provider’s stake to the post-slashing amount, updating authorized\n            // amount for each affected application, and notifying all affected\n            // applications that the staking provider’s authorized stake has\n            // been reduced due to slashing.\n            //\n            // The entire idea is that the process transaction is expensive\n            // because each application needs to be updated, so the reward for\n            // the processor is hefty and comes from the slashed tokens.\n            // Practically, it means that if the sortition pool is unlocked, and\n            // can be updated, it should be updated because we already paid\n            // someone for updating it.\n            //\n            // If the sortition pool is locked, update needs to wait. Other\n            // sortition pool members are incentivized to call\n            // `updateOperatorStatus` for the problematic operator because they\n            // will increase their rewards this way.\n            if (sortitionPool.isOperatorInPool(operator)) {\n                if (sortitionPool.isLocked()) {\n                    emit InvoluntaryAuthorizationDecreaseFailed(\n                        stakingProvider,\n                        operator,\n                        fromAmount,\n                        toAmount\n                    );\n                } else {\n                    updateOperatorStatus(\n                        self,\n                        tokenStaking,\n                        sortitionPool,\n                        operator\n                    );\n                }\n            }\n        }\n    }\n\n    /// @notice Lets the operator join the sortition pool. The operator address\n    ///         must be known - before calling this function, it has to be\n    ///         appointed by the staking provider by calling `registerOperator`.\n    ///         Also, the operator must have the minimum authorization required\n    ///         by ECDSA. Function reverts if there is no minimum stake\n    ///         authorized or if the operator is not known. If there was an\n    ///         authorization decrease requested, it is activated by starting\n    ///         the authorization decrease delay.\n    function joinSortitionPool(\n        Data storage self,\n        IStaking tokenStaking,\n        SortitionPool sortitionPool\n    ) internal {\n        address operator = msg.sender;\n\n        address stakingProvider = self.operatorToStakingProvider[operator];\n        require(stakingProvider != address(0), \"Unknown operator\");\n\n        AuthorizationDecrease storage decrease = self.pendingDecreases[\n            stakingProvider\n        ];\n\n        uint96 _eligibleStake = eligibleStake(\n            self,\n            tokenStaking,\n            stakingProvider,\n            decrease.decreasingBy\n        );\n\n        require(_eligibleStake != 0, \"Authorization below the minimum\");\n\n        emit OperatorJoinedSortitionPool(stakingProvider, operator);\n\n        sortitionPool.insertOperator(operator, _eligibleStake);\n\n        // If there is a pending authorization decrease request, activate it.\n        // At this point, the sortition pool state is up to date so the\n        // authorization decrease delay can start counting.\n        if (decrease.decreasingAt == type(uint64).max) {\n            decrease.decreasingAt =\n                // solhint-disable-next-line not-rely-on-time\n                uint64(block.timestamp) +\n                self.parameters.authorizationDecreaseDelay;\n        }\n    }\n\n    /// @notice Updates status of the operator in the sortition pool. If there\n    ///         was an authorization decrease requested, it is activated by\n    ///         starting the authorization decrease delay.\n    ///         Function reverts if the operator is not known.\n    function updateOperatorStatus(\n        Data storage self,\n        IStaking tokenStaking,\n        SortitionPool sortitionPool,\n        address operator\n    ) internal {\n        address stakingProvider = self.operatorToStakingProvider[operator];\n        require(stakingProvider != address(0), \"Unknown operator\");\n\n        AuthorizationDecrease storage decrease = self.pendingDecreases[\n            stakingProvider\n        ];\n\n        emit OperatorStatusUpdated(stakingProvider, operator);\n\n        if (sortitionPool.isOperatorInPool(operator)) {\n            uint96 _eligibleStake = eligibleStake(\n                self,\n                tokenStaking,\n                stakingProvider,\n                decrease.decreasingBy\n            );\n\n            sortitionPool.updateOperatorStatus(operator, _eligibleStake);\n        }\n\n        // If there is a pending authorization decrease request, activate it.\n        // At this point, the sortition pool state is up to date so the\n        // authorization decrease delay can start counting.\n        if (decrease.decreasingAt == type(uint64).max) {\n            decrease.decreasingAt =\n                // solhint-disable-next-line not-rely-on-time\n                uint64(block.timestamp) +\n                self.parameters.authorizationDecreaseDelay;\n        }\n    }\n\n    /// @notice Checks if the operator's authorized stake is in sync with\n    ///         operator's weight in the sortition pool.\n    ///         If the operator is not in the sortition pool and their\n    ///         authorized stake is non-zero, function returns false.\n    function isOperatorUpToDate(\n        Data storage self,\n        IStaking tokenStaking,\n        SortitionPool sortitionPool,\n        address operator\n    ) internal view returns (bool) {\n        address stakingProvider = self.operatorToStakingProvider[operator];\n        require(stakingProvider != address(0), \"Unknown operator\");\n\n        AuthorizationDecrease storage decrease = self.pendingDecreases[\n            stakingProvider\n        ];\n\n        uint96 _eligibleStake = eligibleStake(\n            self,\n            tokenStaking,\n            stakingProvider,\n            decrease.decreasingBy\n        );\n\n        if (!sortitionPool.isOperatorInPool(operator)) {\n            return _eligibleStake == 0;\n        } else {\n            return sortitionPool.isOperatorUpToDate(operator, _eligibleStake);\n        }\n    }\n\n    /// @notice Returns the current value of the staking provider's eligible\n    ///         stake. Eligible stake is defined as the currently authorized\n    ///         stake minus the pending authorization decrease. Eligible stake\n    ///         is what is used for operator's weight in the pool. If the\n    ///         authorized stake minus the pending authorization decrease is\n    ///         below the minimum authorization, eligible stake is 0.\n    /// @dev This function can be exposed to the public in contrast to the\n    ///      second variant accepting `decreasingBy` as a parameter.\n    function eligibleStake(\n        Data storage self,\n        IStaking tokenStaking,\n        address stakingProvider\n    ) internal view returns (uint96) {\n        return\n            eligibleStake(\n                self,\n                tokenStaking,\n                stakingProvider,\n                pendingAuthorizationDecrease(self, stakingProvider)\n            );\n    }\n\n    /// @notice Returns the current value of the staking provider's eligible\n    ///         stake. Eligible stake is defined as the currently authorized\n    ///         stake minus the pending authorization decrease. Eligible stake\n    ///         is what is used for operator's weight in the pool. If the\n    ///         authorized stake minus the pending authorization decrease is\n    ///         below the minimum authorization, eligible stake is 0.\n    /// @dev This function is not intended to be exposes to the public.\n    ///      `decreasingBy` must be fetched from `pendingDecreases` mapping and\n    ///      it is passed as a parameter to optimize gas usage of functions that\n    ///      call `eligibleStake` and need to use `AuthorizationDecrease`\n    ///      fetched from `pendingDecreases` for some additional logic.\n    function eligibleStake(\n        Data storage self,\n        IStaking tokenStaking,\n        address stakingProvider,\n        uint96 decreasingBy\n    ) internal view returns (uint96) {\n        uint96 authorizedStake = tokenStaking.authorizedStake(\n            stakingProvider,\n            address(this)\n        );\n\n        uint96 _eligibleStake = authorizedStake > decreasingBy\n            ? authorizedStake - decreasingBy\n            : 0;\n\n        if (_eligibleStake < self.parameters.minimumAuthorization) {\n            return 0;\n        } else {\n            return _eligibleStake;\n        }\n    }\n\n    /// @notice Returns the amount of stake that is pending authorization\n    ///         decrease for the given staking provider. If no authorization\n    ///         decrease has been requested, returns zero.\n    function pendingAuthorizationDecrease(\n        Data storage self,\n        address stakingProvider\n    ) internal view returns (uint96) {\n        AuthorizationDecrease storage decrease = self.pendingDecreases[\n            stakingProvider\n        ];\n\n        return decrease.decreasingBy;\n    }\n\n    /// @notice Returns the remaining time in seconds that needs to pass before\n    ///         the requested authorization decrease can be approved.\n    ///         If the sortition pool state was not updated yet by the operator\n    ///         after requesting the authorization decrease, returns\n    ///         `type(uint64).max`.\n    function remainingAuthorizationDecreaseDelay(\n        Data storage self,\n        address stakingProvider\n    ) internal view returns (uint64) {\n        AuthorizationDecrease storage decrease = self.pendingDecreases[\n            stakingProvider\n        ];\n\n        if (decrease.decreasingAt == type(uint64).max) {\n            return type(uint64).max;\n        }\n\n        // solhint-disable-next-line not-rely-on-time\n        uint64 _now = uint64(block.timestamp);\n        return _now > decrease.decreasingAt ? 0 : decrease.decreasingAt - _now;\n    }\n}\n"
    },
    "contracts/libraries/EcdsaDkg.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n//\n// ▓▓▌ ▓▓ ▐▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▄\n// ▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n//   ▓▓▓▓▓▓    ▓▓▓▓▓▓▓▀    ▐▓▓▓▓▓▓    ▐▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n//   ▓▓▓▓▓▓▄▄▓▓▓▓▓▓▓▀      ▐▓▓▓▓▓▓▄▄▄▄         ▓▓▓▓▓▓▄▄▄▄         ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n//   ▓▓▓▓▓▓▓▓▓▓▓▓▓▀        ▐▓▓▓▓▓▓▓▓▓▓         ▓▓▓▓▓▓▓▓▓▓         ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n//   ▓▓▓▓▓▓▀▀▓▓▓▓▓▓▄       ▐▓▓▓▓▓▓▀▀▀▀         ▓▓▓▓▓▓▀▀▀▀         ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▀\n//   ▓▓▓▓▓▓   ▀▓▓▓▓▓▓▄     ▐▓▓▓▓▓▓     ▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌\n// ▓▓▓▓▓▓▓▓▓▓ █▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▓▓\n// ▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▓▓\n//\n//\n\n// Initial version copied from Keep Network Random Beacon:\n// https://github.com/keep-network/keep-core/blob/5138c7628868dbeed3ae2164f76fccc6c1fbb9e8/solidity/random-beacon/contracts/libraries/DKG.sol\n//\n// With the following differences:\n// - the group size was set to 100,\n// - offchainDkgTimeout was removed,\n// - submission eligibility verification is not performed on-chain,\n// - submission eligibility delay was replaced with a submission timeout,\n// - seed timeout notification requires seedTimeout period to pass.\n\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/cryptography/ECDSAUpgradeable.sol\";\nimport \"@keep-network/sortition-pools/contracts/SortitionPool.sol\";\nimport \"@keep-network/random-beacon/contracts/libraries/BytesLib.sol\";\nimport \"../EcdsaDkgValidator.sol\";\n\nlibrary EcdsaDkg {\n    using BytesLib for bytes;\n    using ECDSAUpgradeable for bytes32;\n\n    struct Parameters {\n        // Time in blocks during which a seed is expected to be delivered.\n        // DKG starts only after a seed is delivered. The time the contract\n        // awaits for a seed is not included in the DKG timeout.\n        uint256 seedTimeout;\n        // Time in blocks during which a submitted result can be challenged.\n        uint256 resultChallengePeriodLength;\n        // Extra gas required to be left at the end of the challenge DKG result\n        // transaction.\n        uint256 resultChallengeExtraGas;\n        // Time in blocks during which a result is expected to be submitted.\n        uint256 resultSubmissionTimeout;\n        // Time in blocks during which only the result submitter is allowed to\n        // approve it. Once this period ends and the submitter have not approved\n        // the result, anyone can do it.\n        uint256 submitterPrecedencePeriodLength;\n        // This struct doesn't contain `__gap` property as the structure is\n        // stored inside `Data` struct, that already have a gap that can be used\n        // on upgrade.\n    }\n\n    struct Data {\n        // Address of the Sortition Pool contract.\n        SortitionPool sortitionPool;\n        // Address of the EcdsaDkgValidator contract.\n        EcdsaDkgValidator dkgValidator;\n        // DKG parameters. The parameters should persist between DKG executions.\n        // They should be updated with dedicated set functions only when DKG is not\n        // in progress.\n        Parameters parameters;\n        // Time in block at which DKG state was locked.\n        uint256 stateLockBlock;\n        // Time in blocks at which DKG started.\n        uint256 startBlock;\n        // Seed used to start DKG.\n        uint256 seed;\n        // Time in blocks that should be added to result submission eligibility\n        // delay calculation. It is used in case of a challenge to adjust\n        // DKG timeout calculation.\n        uint256 resultSubmissionStartBlockOffset;\n        // Hash of submitted DKG result.\n        bytes32 submittedResultHash;\n        // Block number from the moment of the DKG result submission.\n        uint256 submittedResultBlock;\n        // Reserved storage space in case we need to add more variables.\n        // See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n        // slither-disable-next-line unused-state\n        uint256[38] __gap;\n    }\n\n    /// @notice DKG result.\n    struct Result {\n        // Claimed submitter candidate group member index.\n        // Must be in range [1, groupSize].\n        uint256 submitterMemberIndex;\n        // Generated candidate group public key\n        bytes groupPubKey;\n        // Array of misbehaved members indices (disqualified or inactive).\n        // Indices must be in range [1, groupSize], unique, and sorted in ascending\n        // order.\n        uint8[] misbehavedMembersIndices;\n        // Concatenation of signatures from members supporting the result.\n        // The message to be signed by each member is keccak256 hash of the\n        // calculated group public key, misbehaved members indices and DKG\n        // start block. The calculated hash should be prefixed with prefixed with\n        // `\\x19Ethereum signed message:\\n` before signing, so the message to\n        // sign is:\n        // `\\x19Ethereum signed message:\\n${keccak256(\n        //    groupPubKey, misbehavedMembersIndices, dkgStartBlock\n        // )}`\n        bytes signatures;\n        // Indices of members corresponding to each signature. Indices must be\n        // be in range [1, groupSize], unique, and sorted in ascending order.\n        uint256[] signingMembersIndices;\n        // Identifiers of candidate group members as outputted by the group\n        // selection protocol.\n        uint32[] members;\n        // Keccak256 hash of group members identifiers that actively took part\n        // in DKG (excluding IA/DQ members).\n        bytes32 membersHash;\n        // This struct doesn't contain `__gap` property as the structure is not\n        // stored, it is used as a function's calldata argument.\n    }\n\n    /// @notice States for phases of group creation. The states doesn't include\n    ///         timeouts which should be tracked and notified individually.\n    enum State {\n        // Group creation is not in progress. It is a state set after group creation\n        // completion either by timeout or by a result approval.\n        IDLE,\n        // Group creation is awaiting the seed and sortition pool is locked.\n        AWAITING_SEED,\n        // DKG protocol execution is in progress. A result is being calculated\n        // by the clients in this state and the contract awaits a result submission.\n        // This is a state to which group creation returns in case of a result\n        // challenge notification.\n        AWAITING_RESULT,\n        // DKG result was submitted and awaits an approval or a challenge. If a result\n        // gets challenge the state returns to `AWAITING_RESULT`. If a result gets\n        // approval the state changes to `IDLE`.\n        CHALLENGE\n    }\n\n    /// @dev Size of a group in ECDSA wallet.\n    uint256 public constant groupSize = 100;\n\n    event DkgStarted(uint256 indexed seed);\n\n    // To recreate the members that actively took part in dkg, the selected members\n    // array should be filtered out from misbehavedMembersIndices.\n    event DkgResultSubmitted(\n        bytes32 indexed resultHash,\n        uint256 indexed seed,\n        Result result\n    );\n\n    event DkgTimedOut();\n\n    event DkgResultApproved(\n        bytes32 indexed resultHash,\n        address indexed approver\n    );\n\n    event DkgResultChallenged(\n        bytes32 indexed resultHash,\n        address indexed challenger,\n        string reason\n    );\n\n    event DkgStateLocked();\n\n    event DkgSeedTimedOut();\n\n    /// @notice Initializes SortitionPool and EcdsaDkgValidator addresses.\n    ///        Can be performed only once.\n    /// @param _sortitionPool Sortition Pool reference\n    /// @param _dkgValidator EcdsaDkgValidator reference\n    function init(\n        Data storage self,\n        SortitionPool _sortitionPool,\n        EcdsaDkgValidator _dkgValidator\n    ) internal {\n        require(\n            address(self.sortitionPool) == address(0),\n            \"Sortition Pool address already set\"\n        );\n\n        require(\n            address(self.dkgValidator) == address(0),\n            \"DKG Validator address already set\"\n        );\n\n        self.sortitionPool = _sortitionPool;\n        self.dkgValidator = _dkgValidator;\n    }\n\n    /// @notice Determines the current state of group creation. It doesn't take\n    ///         timeouts into consideration. The timeouts should be tracked and\n    ///         notified separately.\n    function currentState(Data storage self)\n        internal\n        view\n        returns (State state)\n    {\n        state = State.IDLE;\n\n        if (self.sortitionPool.isLocked()) {\n            state = State.AWAITING_SEED;\n\n            if (self.startBlock > 0) {\n                state = State.AWAITING_RESULT;\n\n                if (self.submittedResultBlock > 0) {\n                    state = State.CHALLENGE;\n                }\n            }\n        }\n    }\n\n    /// @notice Locks the sortition pool and starts awaiting for the\n    ///         group creation seed.\n    function lockState(Data storage self) internal {\n        require(currentState(self) == State.IDLE, \"Current state is not IDLE\");\n\n        emit DkgStateLocked();\n\n        self.sortitionPool.lock();\n\n        self.stateLockBlock = block.number;\n    }\n\n    function start(Data storage self, uint256 seed) internal {\n        require(\n            currentState(self) == State.AWAITING_SEED,\n            \"Current state is not AWAITING_SEED\"\n        );\n\n        emit DkgStarted(seed);\n\n        self.startBlock = block.number;\n        self.seed = seed;\n    }\n\n    /// @notice Allows to submit a DKG result. The submitted result does not go\n    ///         through a validation and before it gets accepted, it needs to\n    ///         wait through the challenge period during which everyone has\n    ///         a chance to challenge the result as invalid one. Submitter of\n    ///         the result needs to be in the sortition pool and if the result\n    ///         gets challenged, the submitter will get slashed.\n    function submitResult(Data storage self, Result calldata result) internal {\n        require(\n            currentState(self) == State.AWAITING_RESULT,\n            \"Current state is not AWAITING_RESULT\"\n        );\n        require(!hasDkgTimedOut(self), \"DKG timeout already passed\");\n\n        SortitionPool sortitionPool = self.sortitionPool;\n\n        // Submitter must be an operator in the sortition pool.\n        // Declared submitter's member index in the DKG result needs to match\n        // the address calling this function.\n        require(\n            sortitionPool.isOperatorInPool(msg.sender),\n            \"Submitter not in the sortition pool\"\n        );\n        require(\n            sortitionPool.getIDOperator(\n                result.members[result.submitterMemberIndex - 1]\n            ) == msg.sender,\n            \"Unexpected submitter index\"\n        );\n\n        self.submittedResultHash = keccak256(abi.encode(result));\n        self.submittedResultBlock = block.number;\n\n        emit DkgResultSubmitted(self.submittedResultHash, self.seed, result);\n    }\n\n    /// @notice Checks if awaiting seed timed out.\n    /// @return True if awaiting seed timed out, false otherwise.\n    function hasSeedTimedOut(Data storage self) internal view returns (bool) {\n        return\n            currentState(self) == State.AWAITING_SEED &&\n            block.number > (self.stateLockBlock + self.parameters.seedTimeout);\n    }\n\n    /// @notice Checks if DKG timed out. The DKG timeout period includes time required\n    ///         for off-chain protocol execution and time for the result publication.\n    ///         After this time a result cannot be submitted and DKG can be notified\n    ///         about the timeout. DKG period is adjusted by result submission\n    ///         offset that include blocks that were mined while invalid result\n    ///         has been registered until it got challenged.\n    /// @return True if DKG timed out, false otherwise.\n    function hasDkgTimedOut(Data storage self) internal view returns (bool) {\n        return\n            currentState(self) == State.AWAITING_RESULT &&\n            block.number >\n            (self.startBlock +\n                self.resultSubmissionStartBlockOffset +\n                self.parameters.resultSubmissionTimeout);\n    }\n\n    /// @notice Notifies about the seed was not delivered and restores the\n    ///         initial DKG state (IDLE).\n    function notifySeedTimeout(Data storage self) internal {\n        require(hasSeedTimedOut(self), \"Awaiting seed has not timed out\");\n\n        emit DkgSeedTimedOut();\n\n        complete(self);\n    }\n\n    /// @notice Notifies about DKG timeout.\n    function notifyDkgTimeout(Data storage self) internal {\n        require(hasDkgTimedOut(self), \"DKG has not timed out\");\n\n        emit DkgTimedOut();\n\n        complete(self);\n    }\n\n    /// @notice Approves DKG result. Can be called when the challenge period for\n    ///         the submitted result is finished. Considers the submitted result\n    ///         as valid. For the first `submitterPrecedencePeriodLength`\n    ///         blocks after the end of the challenge period can be called only\n    ///         by the DKG result submitter. After that time, can be called by\n    ///         anyone.\n    /// @dev Can be called after a challenge period for the submitted result.\n    /// @param result Result to approve. Must match the submitted result stored\n    ///        during `submitResult`.\n    /// @return misbehavedMembers Identifiers of members who misbehaved during DKG.\n    function approveResult(Data storage self, Result calldata result)\n        internal\n        returns (uint32[] memory misbehavedMembers)\n    {\n        require(\n            currentState(self) == State.CHALLENGE,\n            \"Current state is not CHALLENGE\"\n        );\n\n        uint256 challengePeriodEnd = self.submittedResultBlock +\n            self.parameters.resultChallengePeriodLength;\n\n        require(\n            block.number > challengePeriodEnd,\n            \"Challenge period has not passed yet\"\n        );\n\n        require(\n            keccak256(abi.encode(result)) == self.submittedResultHash,\n            \"Result under approval is different than the submitted one\"\n        );\n\n        // Extract submitter member address. Submitter member index is in\n        // range [1, groupSize] so we need to -1 when fetching identifier from members\n        // array.\n        address submitterMember = self.sortitionPool.getIDOperator(\n            result.members[result.submitterMemberIndex - 1]\n        );\n\n        require(\n            msg.sender == submitterMember ||\n                block.number >\n                challengePeriodEnd +\n                    self.parameters.submitterPrecedencePeriodLength,\n            \"Only the DKG result submitter can approve the result at this moment\"\n        );\n\n        // Extract misbehaved members identifiers. Misbehaved members indices\n        // are in range [1, groupSize], so we need to -1 when fetching identifiers from\n        // members array.\n        misbehavedMembers = new uint32[](\n            result.misbehavedMembersIndices.length\n        );\n        for (uint256 i = 0; i < result.misbehavedMembersIndices.length; i++) {\n            misbehavedMembers[i] = result.members[\n                result.misbehavedMembersIndices[i] - 1\n            ];\n        }\n\n        emit DkgResultApproved(self.submittedResultHash, msg.sender);\n\n        return misbehavedMembers;\n    }\n\n    /// @notice Challenges DKG result. If the submitted result is proved to be\n    ///         invalid it reverts the DKG back to the result submission phase.\n    /// @dev Can be called during a challenge period for the submitted result.\n    /// @param result Result to challenge. Must match the submitted result\n    ///        stored during `submitResult`.\n    /// @return maliciousResultHash Hash of the malicious result.\n    /// @return maliciousSubmitter Identifier of the malicious submitter.\n    function challengeResult(Data storage self, Result calldata result)\n        internal\n        returns (bytes32 maliciousResultHash, uint32 maliciousSubmitter)\n    {\n        require(\n            currentState(self) == State.CHALLENGE,\n            \"Current state is not CHALLENGE\"\n        );\n\n        require(\n            block.number <=\n                self.submittedResultBlock +\n                    self.parameters.resultChallengePeriodLength,\n            \"Challenge period has already passed\"\n        );\n\n        require(\n            keccak256(abi.encode(result)) == self.submittedResultHash,\n            \"Result under challenge is different than the submitted one\"\n        );\n\n        // https://github.com/crytic/slither/issues/982\n        // slither-disable-next-line unused-return\n        try\n            self.dkgValidator.validate(result, self.seed, self.startBlock)\n        returns (\n            // slither-disable-next-line uninitialized-local,variable-scope\n            bool isValid,\n            // slither-disable-next-line uninitialized-local,variable-scope\n            string memory errorMsg\n        ) {\n            if (isValid) {\n                revert(\"unjustified challenge\");\n            }\n\n            emit DkgResultChallenged(\n                self.submittedResultHash,\n                msg.sender,\n                errorMsg\n            );\n        } catch {\n            // if the validation reverted we consider the DKG result as invalid\n            emit DkgResultChallenged(\n                self.submittedResultHash,\n                msg.sender,\n                \"validation reverted\"\n            );\n        }\n\n        // Consider result hash as malicious.\n        maliciousResultHash = self.submittedResultHash;\n        maliciousSubmitter = result.members[result.submitterMemberIndex - 1];\n\n        // Adjust DKG result submission block start, so submission stage starts\n        // from the beginning.\n        self.resultSubmissionStartBlockOffset = block.number - self.startBlock;\n\n        submittedResultCleanup(self);\n\n        return (maliciousResultHash, maliciousSubmitter);\n    }\n\n    /// @notice Due to EIP150, 1/64 of the gas is not forwarded to the call, and\n    ///         will be kept to execute the remaining operations in the function\n    ///         after the call inside the try-catch.\n    ///\n    ///         To ensure there is no way for the caller to manipulate gas limit\n    ///         in such a way that the call inside try-catch fails with out-of-gas\n    ///         and the rest of the function is executed with the remaining\n    ///         1/64 of gas, we require an extra gas amount to be left at the\n    ///         end of the call to the function challenging DKG result and\n    ///         wrapping the call to EcdsaDkgValidator and TokenStaking\n    ///         contracts inside a try-catch.\n    function requireChallengeExtraGas(Data storage self) internal view {\n        require(\n            gasleft() >= self.parameters.resultChallengeExtraGas,\n            \"Not enough extra gas left\"\n        );\n    }\n\n    /// @notice Checks if DKG result is valid for the current DKG.\n    /// @param result DKG result.\n    /// @return True if the result is valid. If the result is invalid it returns\n    ///         false and an error message.\n    function isResultValid(Data storage self, Result calldata result)\n        internal\n        view\n        returns (bool, string memory)\n    {\n        require(self.startBlock > 0, \"DKG has not been started\");\n\n        return self.dkgValidator.validate(result, self.seed, self.startBlock);\n    }\n\n    /// @notice Set setSeedTimeout parameter.\n    function setSeedTimeout(Data storage self, uint256 newSeedTimeout)\n        internal\n    {\n        require(currentState(self) == State.IDLE, \"Current state is not IDLE\");\n\n        require(newSeedTimeout > 0, \"New value should be greater than zero\");\n\n        self.parameters.seedTimeout = newSeedTimeout;\n    }\n\n    /// @notice Set resultChallengePeriodLength parameter.\n    function setResultChallengePeriodLength(\n        Data storage self,\n        uint256 newResultChallengePeriodLength\n    ) internal {\n        require(currentState(self) == State.IDLE, \"Current state is not IDLE\");\n\n        require(\n            newResultChallengePeriodLength > 0,\n            \"New value should be greater than zero\"\n        );\n\n        self\n            .parameters\n            .resultChallengePeriodLength = newResultChallengePeriodLength;\n    }\n\n    /// @notice Set resultChallengeExtraGas parameter.\n    function setResultChallengeExtraGas(\n        Data storage self,\n        uint256 newResultChallengeExtraGas\n    ) internal {\n        require(currentState(self) == State.IDLE, \"Current state is not IDLE\");\n\n        self.parameters.resultChallengeExtraGas = newResultChallengeExtraGas;\n    }\n\n    /// @notice Set resultSubmissionTimeout parameter.\n    function setResultSubmissionTimeout(\n        Data storage self,\n        uint256 newResultSubmissionTimeout\n    ) internal {\n        require(currentState(self) == State.IDLE, \"Current state is not IDLE\");\n\n        require(\n            newResultSubmissionTimeout > 0,\n            \"New value should be greater than zero\"\n        );\n\n        self.parameters.resultSubmissionTimeout = newResultSubmissionTimeout;\n    }\n\n    /// @notice Set submitterPrecedencePeriodLength parameter.\n    function setSubmitterPrecedencePeriodLength(\n        Data storage self,\n        uint256 newSubmitterPrecedencePeriodLength\n    ) internal {\n        require(currentState(self) == State.IDLE, \"Current state is not IDLE\");\n\n        require(\n            newSubmitterPrecedencePeriodLength <\n                self.parameters.resultSubmissionTimeout,\n            \"New value should be less than result submission period length\"\n        );\n\n        self\n            .parameters\n            .submitterPrecedencePeriodLength = newSubmitterPrecedencePeriodLength;\n    }\n\n    /// @notice Completes DKG by cleaning up state.\n    /// @dev Should be called after DKG times out or a result is approved.\n    function complete(Data storage self) internal {\n        delete self.startBlock;\n        delete self.seed;\n        delete self.resultSubmissionStartBlockOffset;\n        submittedResultCleanup(self);\n        self.sortitionPool.unlock();\n    }\n\n    /// @notice Cleans up submitted result state either after DKG completion\n    ///         (as part of `complete` method) or after justified challenge.\n    function submittedResultCleanup(Data storage self) private {\n        delete self.submittedResultHash;\n        delete self.submittedResultBlock;\n    }\n}\n"
    },
    "contracts/libraries/EcdsaInactivity.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n//\n// ▓▓▌ ▓▓ ▐▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▄\n// ▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n//   ▓▓▓▓▓▓    ▓▓▓▓▓▓▓▀    ▐▓▓▓▓▓▓    ▐▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n//   ▓▓▓▓▓▓▄▄▓▓▓▓▓▓▓▀      ▐▓▓▓▓▓▓▄▄▄▄         ▓▓▓▓▓▓▄▄▄▄         ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n//   ▓▓▓▓▓▓▓▓▓▓▓▓▓▀        ▐▓▓▓▓▓▓▓▓▓▓         ▓▓▓▓▓▓▓▓▓▓         ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n//   ▓▓▓▓▓▓▀▀▓▓▓▓▓▓▄       ▐▓▓▓▓▓▓▀▀▀▀         ▓▓▓▓▓▓▀▀▀▀         ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▀\n//   ▓▓▓▓▓▓   ▀▓▓▓▓▓▓▄     ▐▓▓▓▓▓▓     ▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌\n// ▓▓▓▓▓▓▓▓▓▓ █▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▓▓\n// ▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▓▓\n//\n//                           Trust math, not hardware.\n\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/cryptography/ECDSAUpgradeable.sol\";\n\nimport \"@keep-network/random-beacon/contracts/libraries/BytesLib.sol\";\nimport \"@keep-network/sortition-pools/contracts/SortitionPool.sol\";\n\nimport \"./Wallets.sol\";\n\nlibrary EcdsaInactivity {\n    using BytesLib for bytes;\n    using ECDSAUpgradeable for bytes32;\n\n    struct Claim {\n        // ID of the wallet whose signing group is raising the inactivity claim.\n        bytes32 walletID;\n        // Indices of group members accused of being inactive. Indices must be in\n        // range [1, groupMembers.length], unique, and sorted in ascending order.\n        uint256[] inactiveMembersIndices;\n        // Indicates if inactivity claim is a wallet-wide heartbeat failure.\n        // If wallet failed a heartbeat, this is signalled to the wallet owner\n        // who may decide to move responsibilities to another wallet\n        // given that the wallet who failed the heartbeat is at risk of not\n        // being able to sign messages soon.\n        bool heartbeatFailed;\n        // Concatenation of signatures from members supporting the claim.\n        // The message to be signed by each member is keccak256 hash of the\n        // concatenation of the chain ID, inactivity claim nonce for the given\n        // wallet, wallet public key, inactive members indices, and boolean flag\n        // indicating if this is a wallet-wide heartbeat failure. The calculated\n        // hash should be prefixed with `\\x19Ethereum signed message:\\n` before\n        // signing, so the message to sign is:\n        // `\\x19Ethereum signed message:\\n${keccak256(\n        //    chainID | nonce | walletPubKey | inactiveMembersIndices | heartbeatFailed\n        // )}`\n        bytes signatures;\n        // Indices of members corresponding to each signature. Indices must be\n        // in range [1, groupMembers.length], unique, and sorted in ascending\n        // order.\n        uint256[] signingMembersIndices;\n        // This struct doesn't contain `__gap` property as the structure is not\n        // stored, it is used as a function's calldata argument.\n    }\n\n    /// @notice The minimum number of wallet signing group members needed to\n    ///         interact according to the protocol to produce a valid inactivity\n    ///         claim.\n    uint256 public constant groupThreshold = 51;\n\n    /// @notice Size in bytes of a single signature produced by member\n    ///         supporting the inactivity claim.\n    uint256 public constant signatureByteSize = 65;\n\n    /// @notice Verifies the inactivity claim according to the rules defined in\n    ///         `Claim` struct documentation. Reverts if verification fails.\n    /// @dev Wallet signing group members hash is validated upstream in\n    ///      `WalletRegistry.notifyOperatorInactivity()`\n    /// @param sortitionPool Sortition pool reference\n    /// @param claim Inactivity claim\n    /// @param walletPubKey Public key of the wallet\n    /// @param nonce Current inactivity nonce for wallet used in the claim\n    /// @param groupMembers Identifiers of group members\n    /// @return inactiveMembers Identifiers of members who are inactive\n    function verifyClaim(\n        SortitionPool sortitionPool,\n        Claim calldata claim,\n        bytes memory walletPubKey,\n        uint256 nonce,\n        uint32[] calldata groupMembers\n    ) external view returns (uint32[] memory inactiveMembers) {\n        // Validate inactive members indices. Maximum indices count is equal to\n        // the group size and is not limited deliberately to leave a theoretical\n        // possibility to accuse more members than `groupSize - groupThreshold`.\n        validateMembersIndices(\n            claim.inactiveMembersIndices,\n            groupMembers.length\n        );\n\n        // Validate signatures array is properly formed and number of\n        // signatures and signers is correct.\n        uint256 signaturesCount = claim.signatures.length / signatureByteSize;\n        require(claim.signatures.length != 0, \"No signatures provided\");\n        require(\n            claim.signatures.length % signatureByteSize == 0,\n            \"Malformed signatures array\"\n        );\n        require(\n            signaturesCount == claim.signingMembersIndices.length,\n            \"Unexpected signatures count\"\n        );\n        require(signaturesCount >= groupThreshold, \"Too few signatures\");\n        require(signaturesCount <= groupMembers.length, \"Too many signatures\");\n\n        // Validate signing members indices. Note that `signingMembersIndices`\n        // were already partially validated during `signatures` parameter\n        // validation.\n        validateMembersIndices(\n            claim.signingMembersIndices,\n            groupMembers.length\n        );\n\n        bytes32 signedMessageHash = keccak256(\n            abi.encode(\n                block.chainid,\n                nonce,\n                walletPubKey,\n                claim.inactiveMembersIndices,\n                claim.heartbeatFailed\n            )\n        ).toEthSignedMessageHash();\n\n        address[] memory groupMembersAddresses = sortitionPool.getIDOperators(\n            groupMembers\n        );\n\n        // Verify each signature.\n        bytes memory checkedSignature;\n        bool senderSignatureExists = false;\n        for (uint256 i = 0; i < signaturesCount; i++) {\n            uint256 memberIndex = claim.signingMembersIndices[i];\n            checkedSignature = claim.signatures.slice(\n                signatureByteSize * i,\n                signatureByteSize\n            );\n            address recoveredAddress = signedMessageHash.recover(\n                checkedSignature\n            );\n\n            require(\n                groupMembersAddresses[memberIndex - 1] == recoveredAddress,\n                \"Invalid signature\"\n            );\n\n            if (!senderSignatureExists && msg.sender == recoveredAddress) {\n                senderSignatureExists = true;\n            }\n        }\n\n        require(senderSignatureExists, \"Sender must be claim signer\");\n\n        inactiveMembers = new uint32[](claim.inactiveMembersIndices.length);\n        for (uint256 i = 0; i < claim.inactiveMembersIndices.length; i++) {\n            uint256 memberIndex = claim.inactiveMembersIndices[i];\n            inactiveMembers[i] = groupMembers[memberIndex - 1];\n        }\n\n        return inactiveMembers;\n    }\n\n    /// @notice Validates members indices array. Array is considered valid\n    ///         if its size and each single index are in [1, groupSize] range,\n    ///         indexes are unique, and sorted in an ascending order.\n    ///         Reverts if validation fails.\n    /// @param indices Array to validate.\n    /// @param groupSize Group size used as reference.\n    function validateMembersIndices(\n        uint256[] calldata indices,\n        uint256 groupSize\n    ) internal pure {\n        require(\n            indices.length > 0 && indices.length <= groupSize,\n            \"Corrupted members indices\"\n        );\n\n        // Check if first and last indices are in range [1, groupSize].\n        // This check combined with the loop below makes sure every single\n        // index is in the correct range.\n        require(\n            indices[0] > 0 && indices[indices.length - 1] <= groupSize,\n            \"Corrupted members indices\"\n        );\n\n        for (uint256 i = 0; i < indices.length - 1; i++) {\n            // Check whether given index is smaller than the next one. This\n            // way we are sure indexes are ordered in the ascending order\n            // and there are no duplicates.\n            require(indices[i] < indices[i + 1], \"Corrupted members indices\");\n        }\n    }\n}\n"
    },
    "contracts/EcdsaDkgValidator.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n//\n// ▓▓▌ ▓▓ ▐▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▄\n// ▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n//   ▓▓▓▓▓▓    ▓▓▓▓▓▓▓▀    ▐▓▓▓▓▓▓    ▐▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n//   ▓▓▓▓▓▓▄▄▓▓▓▓▓▓▓▀      ▐▓▓▓▓▓▓▄▄▄▄         ▓▓▓▓▓▓▄▄▄▄         ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n//   ▓▓▓▓▓▓▓▓▓▓▓▓▓▀        ▐▓▓▓▓▓▓▓▓▓▓         ▓▓▓▓▓▓▓▓▓▓         ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n//   ▓▓▓▓▓▓▀▀▓▓▓▓▓▓▄       ▐▓▓▓▓▓▓▀▀▀▀         ▓▓▓▓▓▓▀▀▀▀         ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▀\n//   ▓▓▓▓▓▓   ▀▓▓▓▓▓▓▄     ▐▓▓▓▓▓▓     ▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌\n// ▓▓▓▓▓▓▓▓▓▓ █▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▓▓\n// ▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▓▓\n//\n//                           Trust math, not hardware.\n\n// Initial version copied from Keep Network Random Beacon:\n// https://github.com/keep-network/keep-core/blob/5138c7628868dbeed3ae2164f76fccc6c1fbb9e8/solidity/random-beacon/contracts/DKGValidator.sol\n//\n// With the following differences:\n// - group public key length,\n// - group size and related thresholds,\n// - documentation.\n\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"@keep-network/random-beacon/contracts/libraries/BytesLib.sol\";\nimport \"@keep-network/sortition-pools/contracts/SortitionPool.sol\";\nimport \"./libraries/EcdsaDkg.sol\";\n\n/// @title DKG result validator\n/// @notice EcdsaDkgValidator allows performing a full validation of DKG result,\n///         including checking the format of fields in the result, declared\n///         selected group members, and signatures of operators supporting the\n///         result. The operator submitting the result should perform the\n///         validation using a free contract call before submitting the result\n///         to ensure their result is valid and can not be challenged. All other\n///         network operators should perform validation of the submitted result\n///         using a free contract call and challenge the result if the\n///         validation fails.\ncontract EcdsaDkgValidator {\n    using BytesLib for bytes;\n    using ECDSA for bytes32;\n\n    /// @dev Size of a group in DKG.\n    uint256 public constant groupSize = 100;\n\n    /// @dev The minimum number of group members needed to interact according to\n    ///      the protocol to produce a signature. The adversary can not learn\n    ///      anything about the key as long as it does not break into\n    ///      groupThreshold+1 of members.\n    uint256 public constant groupThreshold = 51;\n\n    /// @dev The minimum number of active and properly behaving group members\n    ///      during the DKG needed to accept the result. This number is higher\n    ///      than `groupThreshold` to keep a safety margin for members becoming\n    ///      inactive after DKG so that the group can still produce signature.\n    uint256 public constant activeThreshold = 90; // 90% of groupSize\n\n    /// @dev Size in bytes of a public key produced by group members during the\n    /// the DKG. The length assumes uncompressed ECDSA public key.\n    uint256 public constant publicKeyByteSize = 64;\n\n    /// @dev Size in bytes of a single signature produced by operator supporting\n    ///      DKG result.\n    uint256 public constant signatureByteSize = 65;\n\n    SortitionPool public immutable sortitionPool;\n\n    constructor(SortitionPool _sortitionPool) {\n        sortitionPool = _sortitionPool;\n    }\n\n    /// @notice Performs a full validation of DKG result, including checking the\n    ///         format of fields in the result, declared selected group members,\n    ///         and signatures of operators supporting the result.\n    /// @param seed seed used to start the DKG and select group members\n    /// @param startBlock DKG start block\n    /// @return isValid true if the result is valid, false otherwise\n    /// @return errorMsg validation error message; empty for a valid result\n    function validate(\n        EcdsaDkg.Result calldata result,\n        uint256 seed,\n        uint256 startBlock\n    ) external view returns (bool isValid, string memory errorMsg) {\n        (bool hasValidFields, string memory error) = validateFields(result);\n        if (!hasValidFields) {\n            return (false, error);\n        }\n\n        if (!validateSignatures(result, startBlock)) {\n            return (false, \"Invalid signatures\");\n        }\n\n        if (!validateGroupMembers(result, seed)) {\n            return (false, \"Invalid group members\");\n        }\n\n        // At this point all group members and misbehaved members were verified\n        if (!validateMembersHash(result)) {\n            return (false, \"Invalid members hash\");\n        }\n\n        return (true, \"\");\n    }\n\n    /// @notice Performs a static validation of DKG result fields: lengths,\n    ///         ranges, and order of arrays.\n    /// @return isValid true if the result is valid, false otherwise\n    /// @return errorMsg validation error message; empty for a valid result\n    function validateFields(EcdsaDkg.Result calldata result)\n        public\n        pure\n        returns (bool isValid, string memory errorMsg)\n    {\n        if (result.groupPubKey.length != publicKeyByteSize) {\n            return (false, \"Malformed group public key\");\n        }\n\n        // The number of misbehaved members can not exceed the threshold.\n        // Misbehaved member indices needs to be unique, between [1, groupSize],\n        // and sorted in ascending order.\n        uint8[] calldata misbehavedMembersIndices = result\n            .misbehavedMembersIndices;\n        if (groupSize - misbehavedMembersIndices.length < activeThreshold) {\n            return (false, \"Too many members misbehaving during DKG\");\n        }\n        if (misbehavedMembersIndices.length > 1) {\n            if (\n                misbehavedMembersIndices[0] < 1 ||\n                misbehavedMembersIndices[misbehavedMembersIndices.length - 1] >\n                groupSize\n            ) {\n                return (false, \"Corrupted misbehaved members indices\");\n            }\n            for (uint256 i = 1; i < misbehavedMembersIndices.length; i++) {\n                if (\n                    misbehavedMembersIndices[i - 1] >=\n                    misbehavedMembersIndices[i]\n                ) {\n                    return (false, \"Corrupted misbehaved members indices\");\n                }\n            }\n        }\n\n        // Each signature needs to have a correct length and signatures need to\n        // be provided.\n        uint256 signaturesCount = result.signatures.length / signatureByteSize;\n        if (result.signatures.length == 0) {\n            return (false, \"No signatures provided\");\n        }\n        if (result.signatures.length % signatureByteSize != 0) {\n            return (false, \"Malformed signatures array\");\n        }\n\n        // We expect the same amount of signatures as the number of declared\n        // group member indices that signed the result.\n        uint256[] calldata signingMembersIndices = result.signingMembersIndices;\n        if (signaturesCount != signingMembersIndices.length) {\n            return (false, \"Unexpected signatures count\");\n        }\n        if (signaturesCount < groupThreshold) {\n            return (false, \"Too few signatures\");\n        }\n        if (signaturesCount > groupSize) {\n            return (false, \"Too many signatures\");\n        }\n\n        // Signing member indices needs to be unique, between [1,groupSize],\n        // and sorted in ascending order.\n        if (\n            signingMembersIndices[0] < 1 ||\n            signingMembersIndices[signingMembersIndices.length - 1] > groupSize\n        ) {\n            return (false, \"Corrupted signing member indices\");\n        }\n        for (uint256 i = 1; i < signingMembersIndices.length; i++) {\n            if (signingMembersIndices[i - 1] >= signingMembersIndices[i]) {\n                return (false, \"Corrupted signing member indices\");\n            }\n        }\n\n        return (true, \"\");\n    }\n\n    /// @notice Performs validation of group members as declared in DKG\n    ///         result against group members selected by the sortition pool.\n    /// @param seed seed used to start the DKG and select group members\n    /// @return true if group members matches; false otherwise\n    function validateGroupMembers(EcdsaDkg.Result calldata result, uint256 seed)\n        public\n        view\n        returns (bool)\n    {\n        uint32[] calldata resultMembers = result.members;\n        uint32[] memory actualGroupMembers = sortitionPool.selectGroup(\n            groupSize,\n            bytes32(seed)\n        );\n        if (resultMembers.length != actualGroupMembers.length) {\n            return false;\n        }\n        for (uint256 i = 0; i < resultMembers.length; i++) {\n            if (resultMembers[i] != actualGroupMembers[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /// @notice Performs validation of signatures supplied in DKG result.\n    ///         Note that this function does not check if addresses which\n    ///         supplied signatures supporting the result are the ones selected\n    ///         to the group by sortition pool. This function should be used\n    ///         together with `validateGroupMembers`.\n    /// @param startBlock DKG start block\n    /// @return true if group members matches; false otherwise\n    function validateSignatures(\n        EcdsaDkg.Result calldata result,\n        uint256 startBlock\n    ) public view returns (bool) {\n        bytes32 hash = keccak256(\n            abi.encode(\n                block.chainid,\n                result.groupPubKey,\n                result.misbehavedMembersIndices,\n                startBlock\n            )\n        ).toEthSignedMessageHash();\n\n        uint256[] calldata signingMembersIndices = result.signingMembersIndices;\n        uint32[] memory signingMemberIds = new uint32[](\n            signingMembersIndices.length\n        );\n        for (uint256 i = 0; i < signingMembersIndices.length; i++) {\n            signingMemberIds[i] = result.members[signingMembersIndices[i] - 1];\n        }\n\n        address[] memory signingMemberAddresses = sortitionPool.getIDOperators(\n            signingMemberIds\n        );\n\n        bytes memory current; // Current signature to be checked.\n\n        uint256 signaturesCount = result.signatures.length / signatureByteSize;\n        for (uint256 i = 0; i < signaturesCount; i++) {\n            current = result.signatures.slice(\n                signatureByteSize * i,\n                signatureByteSize\n            );\n            address recoveredAddress = hash.recover(current);\n\n            if (signingMemberAddresses[i] != recoveredAddress) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /// @notice Performs validation of hashed group members that actively took\n    ///         part in DKG.\n    /// @param result DKG result\n    /// @return true if calculated result's group members hash matches with the\n    /// one that is challenged.\n    function validateMembersHash(EcdsaDkg.Result calldata result)\n        public\n        pure\n        returns (bool)\n    {\n        if (result.misbehavedMembersIndices.length > 0) {\n            // members that generated a group signing key\n            uint32[] memory groupMembers = new uint32[](\n                result.members.length - result.misbehavedMembersIndices.length\n            );\n            uint256 k = 0; // misbehaved members counter\n            uint256 j = 0; // group members counter\n            for (uint256 i = 0; i < result.members.length; i++) {\n                // misbehaved member indices start from 1, so we need to -1 on misbehaved\n                if (i != result.misbehavedMembersIndices[k] - 1) {\n                    groupMembers[j] = result.members[i];\n                    j++;\n                } else if (k < result.misbehavedMembersIndices.length - 1) {\n                    k++;\n                }\n            }\n\n            return keccak256(abi.encode(groupMembers)) == result.membersHash;\n        }\n\n        return keccak256(abi.encode(result.members)) == result.membersHash;\n    }\n}\n"
    },
    "@keep-network/sortition-pools/contracts/SortitionPool.sol": {
      "content": "pragma solidity 0.8.17;\n\nimport \"@thesis/solidity-contracts/contracts/token/IERC20WithPermit.sol\";\nimport \"@thesis/solidity-contracts/contracts/token/IReceiveApproval.sol\";\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"./RNG.sol\";\nimport \"./SortitionTree.sol\";\nimport \"./Rewards.sol\";\nimport \"./Chaosnet.sol\";\n\n/// @title Sortition Pool\n/// @notice A logarithmic data structure used to store the pool of eligible\n/// operators weighted by their stakes. It allows to select a group of operators\n/// based on the provided pseudo-random seed.\ncontract SortitionPool is\n  SortitionTree,\n  Rewards,\n  Ownable,\n  Chaosnet,\n  IReceiveApproval\n{\n  using Branch for uint256;\n  using Leaf for uint256;\n  using Position for uint256;\n\n  IERC20WithPermit public immutable rewardToken;\n\n  uint256 public immutable poolWeightDivisor;\n\n  bool public isLocked;\n\n  event IneligibleForRewards(uint32[] ids, uint256 until);\n\n  event RewardEligibilityRestored(address indexed operator, uint32 indexed id);\n\n  /// @notice Reverts if called while pool is locked.\n  modifier onlyUnlocked() {\n    require(!isLocked, \"Sortition pool locked\");\n    _;\n  }\n\n  /// @notice Reverts if called while pool is unlocked.\n  modifier onlyLocked() {\n    require(isLocked, \"Sortition pool unlocked\");\n    _;\n  }\n\n  constructor(IERC20WithPermit _rewardToken, uint256 _poolWeightDivisor) {\n    rewardToken = _rewardToken;\n    poolWeightDivisor = _poolWeightDivisor;\n  }\n\n  function receiveApproval(\n    address sender,\n    uint256 amount,\n    address token,\n    bytes calldata\n  ) external override {\n    require(token == address(rewardToken), \"Unsupported token\");\n    rewardToken.transferFrom(sender, address(this), amount);\n    Rewards.addRewards(uint96(amount), uint32(root.sumWeight()));\n  }\n\n  /// @notice Withdraws all available rewards for the given operator to the\n  ///         given beneficiary.\n  /// @dev Can be called only be the owner. Does not validate if the provided\n  ///      beneficiary is associated with the provided operator - this needs to\n  ///      be done by the owner calling this function.\n  /// @return The amount of rewards withdrawn in this call.\n  function withdrawRewards(address operator, address beneficiary)\n    public\n    onlyOwner\n    returns (uint96)\n  {\n    uint32 id = getOperatorID(operator);\n    Rewards.updateOperatorRewards(id, uint32(getPoolWeight(operator)));\n    uint96 earned = Rewards.withdrawOperatorRewards(id);\n    rewardToken.transfer(beneficiary, uint256(earned));\n    return earned;\n  }\n\n  /// @notice Withdraws rewards not allocated to operators marked as ineligible\n  ///         to the given recipient address.\n  /// @dev Can be called only by the owner.\n  function withdrawIneligible(address recipient) public onlyOwner {\n    uint96 earned = Rewards.withdrawIneligibleRewards();\n    rewardToken.transfer(recipient, uint256(earned));\n  }\n\n  /// @notice Locks the sortition pool. In locked state, members cannot be\n  ///         inserted and removed from the pool. Members statuses cannot\n  ///         be updated as well.\n  /// @dev Can be called only by the contract owner.\n  function lock() public onlyOwner {\n    isLocked = true;\n  }\n\n  /// @notice Unlocks the sortition pool. Removes all restrictions set by\n  ///         the `lock` method.\n  /// @dev Can be called only by the contract owner.\n  function unlock() public onlyOwner {\n    isLocked = false;\n  }\n\n  /// @notice Inserts an operator to the pool. Reverts if the operator is\n  /// already present. Reverts if the operator is not eligible because of their\n  /// authorized stake. Reverts if the chaosnet is active and the operator is\n  /// not a beta operator.\n  /// @dev Can be called only by the contract owner.\n  /// @param operator Address of the inserted operator.\n  /// @param authorizedStake Inserted operator's authorized stake for the application.\n  function insertOperator(address operator, uint256 authorizedStake)\n    public\n    onlyOwner\n    onlyUnlocked\n  {\n    uint256 weight = getWeight(authorizedStake);\n    require(weight > 0, \"Operator not eligible\");\n\n    if (isChaosnetActive) {\n      require(isBetaOperator[operator], \"Not beta operator for chaosnet\");\n    }\n\n    _insertOperator(operator, weight);\n    uint32 id = getOperatorID(operator);\n    Rewards.updateOperatorRewards(id, uint32(weight));\n  }\n\n  /// @notice Update the operator's weight if present and eligible,\n  /// or remove from the pool if present and ineligible.\n  /// @dev Can be called only by the contract owner.\n  /// @param operator Address of the updated operator.\n  /// @param authorizedStake Operator's authorized stake for the application.\n  function updateOperatorStatus(address operator, uint256 authorizedStake)\n    public\n    onlyOwner\n    onlyUnlocked\n  {\n    uint256 weight = getWeight(authorizedStake);\n\n    uint32 id = getOperatorID(operator);\n    Rewards.updateOperatorRewards(id, uint32(weight));\n\n    if (weight == 0) {\n      _removeOperator(operator);\n    } else {\n      updateOperator(operator, weight);\n    }\n  }\n\n  /// @notice Set the given operators as ineligible for rewards.\n  ///         The operators can restore their eligibility at the given time.\n  function setRewardIneligibility(uint32[] calldata operators, uint256 until)\n    public\n    onlyOwner\n  {\n    Rewards.setIneligible(operators, until);\n    emit IneligibleForRewards(operators, until);\n  }\n\n  /// @notice Restores reward eligibility for the operator.\n  function restoreRewardEligibility(address operator) public {\n    uint32 id = getOperatorID(operator);\n    Rewards.restoreEligibility(id);\n    emit RewardEligibilityRestored(operator, id);\n  }\n\n  /// @notice Returns whether the operator is eligible for rewards or not.\n  function isEligibleForRewards(address operator) public view returns (bool) {\n    uint32 id = getOperatorID(operator);\n    return Rewards.isEligibleForRewards(id);\n  }\n\n  /// @notice Returns the time the operator's reward eligibility can be restored.\n  function rewardsEligibilityRestorableAt(address operator)\n    public\n    view\n    returns (uint256)\n  {\n    uint32 id = getOperatorID(operator);\n    return Rewards.rewardsEligibilityRestorableAt(id);\n  }\n\n  /// @notice Returns whether the operator is able to restore their eligibility\n  ///         for rewards right away.\n  function canRestoreRewardEligibility(address operator)\n    public\n    view\n    returns (bool)\n  {\n    uint32 id = getOperatorID(operator);\n    return Rewards.canRestoreRewardEligibility(id);\n  }\n\n  /// @notice Returns the amount of rewards withdrawable for the given operator.\n  function getAvailableRewards(address operator) public view returns (uint96) {\n    uint32 id = getOperatorID(operator);\n    return availableRewards(id);\n  }\n\n  /// @notice Return whether the operator is present in the pool.\n  function isOperatorInPool(address operator) public view returns (bool) {\n    return getFlaggedLeafPosition(operator) != 0;\n  }\n\n  /// @notice Return whether the operator's weight in the pool\n  /// matches their eligible weight.\n  function isOperatorUpToDate(address operator, uint256 authorizedStake)\n    public\n    view\n    returns (bool)\n  {\n    return getWeight(authorizedStake) == getPoolWeight(operator);\n  }\n\n  /// @notice Return the weight of the operator in the pool,\n  /// which may or may not be out of date.\n  function getPoolWeight(address operator) public view returns (uint256) {\n    uint256 flaggedPosition = getFlaggedLeafPosition(operator);\n    if (flaggedPosition == 0) {\n      return 0;\n    } else {\n      uint256 leafPosition = flaggedPosition.unsetFlag();\n      uint256 leafWeight = getLeafWeight(leafPosition);\n      return leafWeight;\n    }\n  }\n\n  /// @notice Selects a new group of operators of the provided size based on\n  /// the provided pseudo-random seed. At least one operator has to be\n  /// registered in the pool, otherwise the function fails reverting the\n  /// transaction.\n  /// @param groupSize Size of the requested group\n  /// @param seed Pseudo-random number used to select operators to group\n  /// @return selected Members of the selected group\n  function selectGroup(uint256 groupSize, bytes32 seed)\n    public\n    view\n    onlyLocked\n    returns (uint32[] memory)\n  {\n    uint256 _root = root;\n\n    bytes32 rngState = seed;\n    uint256 rngRange = _root.sumWeight();\n    require(rngRange > 0, \"Not enough operators in pool\");\n    uint256 currentIndex;\n\n    uint256 bits = RNG.bitsRequired(rngRange);\n\n    uint32[] memory selected = new uint32[](groupSize);\n\n    for (uint256 i = 0; i < groupSize; i++) {\n      (currentIndex, rngState) = RNG.getIndex(rngRange, rngState, bits);\n\n      uint256 leafPosition = pickWeightedLeaf(currentIndex, _root);\n\n      uint256 leaf = leaves[leafPosition];\n      selected[i] = leaf.id();\n    }\n    return selected;\n  }\n\n  function getWeight(uint256 authorization) internal view returns (uint256) {\n    return authorization / poolWeightDivisor;\n  }\n}\n"
    },
    "@keep-network/random-beacon/contracts/api/IRandomBeaconConsumer.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n//\n// ▓▓▌ ▓▓ ▐▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▄\n// ▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n//   ▓▓▓▓▓▓    ▓▓▓▓▓▓▓▀    ▐▓▓▓▓▓▓    ▐▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n//   ▓▓▓▓▓▓▄▄▓▓▓▓▓▓▓▀      ▐▓▓▓▓▓▓▄▄▄▄         ▓▓▓▓▓▓▄▄▄▄         ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n//   ▓▓▓▓▓▓▓▓▓▓▓▓▓▀        ▐▓▓▓▓▓▓▓▓▓▓         ▓▓▓▓▓▓▓▓▓▓         ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n//   ▓▓▓▓▓▓▀▀▓▓▓▓▓▓▄       ▐▓▓▓▓▓▓▀▀▀▀         ▓▓▓▓▓▓▀▀▀▀         ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▀\n//   ▓▓▓▓▓▓   ▀▓▓▓▓▓▓▄     ▐▓▓▓▓▓▓     ▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌\n// ▓▓▓▓▓▓▓▓▓▓ █▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▓▓\n// ▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▓▓\n//\n//                           Trust math, not hardware.\n\npragma solidity 0.8.17;\n\ninterface IRandomBeaconConsumer {\n    /// @notice Receives relay entry produced by Keep Random Beacon. This function\n    /// should be called only by Keep Random Beacon.\n    ///\n    /// @param relayEntry Relay entry (random number) produced by Keep Random\n    ///                   Beacon.\n    /// @param blockNumber Block number at which the relay entry was submitted\n    ///                    to the chain.\n    function __beaconCallback(uint256 relayEntry, uint256 blockNumber) external;\n}\n"
    },
    "@keep-network/random-beacon/contracts/Reimbursable.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n//\n// ▓▓▌ ▓▓ ▐▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▄\n// ▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n//   ▓▓▓▓▓▓    ▓▓▓▓▓▓▓▀    ▐▓▓▓▓▓▓    ▐▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n//   ▓▓▓▓▓▓▄▄▓▓▓▓▓▓▓▀      ▐▓▓▓▓▓▓▄▄▄▄         ▓▓▓▓▓▓▄▄▄▄         ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n//   ▓▓▓▓▓▓▓▓▓▓▓▓▓▀        ▐▓▓▓▓▓▓▓▓▓▓         ▓▓▓▓▓▓▓▓▓▓         ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n//   ▓▓▓▓▓▓▀▀▓▓▓▓▓▓▄       ▐▓▓▓▓▓▓▀▀▀▀         ▓▓▓▓▓▓▀▀▀▀         ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▀\n//   ▓▓▓▓▓▓   ▀▓▓▓▓▓▓▄     ▐▓▓▓▓▓▓     ▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌\n// ▓▓▓▓▓▓▓▓▓▓ █▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▓▓\n// ▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▓▓\n//\n//                           Trust math, not hardware.\n\npragma solidity 0.8.17;\n\nimport \"./ReimbursementPool.sol\";\n\nabstract contract Reimbursable {\n    // The variable should be initialized by the implementing contract.\n    // slither-disable-next-line uninitialized-state\n    ReimbursementPool public reimbursementPool;\n\n    // Reserved storage space in case we need to add more variables,\n    // since there are upgradeable contracts that inherit from this one.\n    // See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n    // slither-disable-next-line unused-state\n    uint256[49] private __gap;\n\n    event ReimbursementPoolUpdated(address newReimbursementPool);\n\n    modifier refundable(address receiver) {\n        uint256 gasStart = gasleft();\n        _;\n        reimbursementPool.refund(gasStart - gasleft(), receiver);\n    }\n\n    modifier onlyReimbursableAdmin() virtual {\n        _;\n    }\n\n    function updateReimbursementPool(ReimbursementPool _reimbursementPool)\n        external\n        onlyReimbursableAdmin\n    {\n        emit ReimbursementPoolUpdated(address(_reimbursementPool));\n\n        reimbursementPool = _reimbursementPool;\n    }\n}\n"
    },
    "@keep-network/random-beacon/contracts/Governable.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n//\n// ▓▓▌ ▓▓ ▐▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▄\n// ▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n//   ▓▓▓▓▓▓    ▓▓▓▓▓▓▓▀    ▐▓▓▓▓▓▓    ▐▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n//   ▓▓▓▓▓▓▄▄▓▓▓▓▓▓▓▀      ▐▓▓▓▓▓▓▄▄▄▄         ▓▓▓▓▓▓▄▄▄▄         ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n//   ▓▓▓▓▓▓▓▓▓▓▓▓▓▀        ▐▓▓▓▓▓▓▓▓▓▓         ▓▓▓▓▓▓▓▓▓▓         ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n//   ▓▓▓▓▓▓▀▀▓▓▓▓▓▓▄       ▐▓▓▓▓▓▓▀▀▀▀         ▓▓▓▓▓▓▀▀▀▀         ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▀\n//   ▓▓▓▓▓▓   ▀▓▓▓▓▓▓▄     ▐▓▓▓▓▓▓     ▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌\n// ▓▓▓▓▓▓▓▓▓▓ █▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▓▓\n// ▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▓▓\n//\n//                           Trust math, not hardware.\n\npragma solidity 0.8.17;\n\n/// @notice Governable contract.\n/// @dev A constructor is not defined, which makes the contract compatible with\n///      upgradable proxies. This requires calling explicitly `_transferGovernance`\n///      function in a child contract.\nabstract contract Governable {\n    // Governance of the contract\n    // The variable should be initialized by the implementing contract.\n    // slither-disable-next-line uninitialized-state\n    address public governance;\n\n    // Reserved storage space in case we need to add more variables,\n    // since there are upgradeable contracts that inherit from this one.\n    // See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n    // slither-disable-next-line unused-state\n    uint256[49] private __gap;\n\n    event GovernanceTransferred(address oldGovernance, address newGovernance);\n\n    modifier onlyGovernance() virtual {\n        require(governance == msg.sender, \"Caller is not the governance\");\n        _;\n    }\n\n    /// @notice Transfers governance of the contract to `newGovernance`.\n    function transferGovernance(address newGovernance)\n        external\n        virtual\n        onlyGovernance\n    {\n        require(\n            newGovernance != address(0),\n            \"New governance is the zero address\"\n        );\n        _transferGovernance(newGovernance);\n    }\n\n    function _transferGovernance(address newGovernance) internal virtual {\n        address oldGovernance = governance;\n        governance = newGovernance;\n        emit GovernanceTransferred(oldGovernance, newGovernance);\n    }\n}\n"
    },
    "@threshold-network/solidity-contracts/contracts/staking/IApplication.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\n// ██████████████     ▐████▌     ██████████████\n// ██████████████     ▐████▌     ██████████████\n//               ▐████▌    ▐████▌\n//               ▐████▌    ▐████▌\n// ██████████████     ▐████▌     ██████████████\n// ██████████████     ▐████▌     ██████████████\n//               ▐████▌    ▐████▌\n//               ▐████▌    ▐████▌\n//               ▐████▌    ▐████▌\n//               ▐████▌    ▐████▌\n//               ▐████▌    ▐████▌\n//               ▐████▌    ▐████▌\n\npragma solidity ^0.8.9;\n\n/// @title  Application interface for Threshold Network applications\n/// @notice Generic interface for an application. Application is an external\n///         smart contract or a set of smart contracts utilizing functionalities\n///         offered by Threshold Network. Applications authorized for the given\n///         staking provider are eligible to slash the stake delegated to that\n///         staking provider.\ninterface IApplication {\n    /// @dev Event emitted by `withdrawRewards` function.\n    event RewardsWithdrawn(address indexed stakingProvider, uint96 amount);\n\n    /// @notice Withdraws application rewards for the given staking provider.\n    ///         Rewards are withdrawn to the staking provider's beneficiary\n    ///         address set in the staking contract.\n    /// @dev Emits `RewardsWithdrawn` event.\n    function withdrawRewards(address stakingProvider) external;\n\n    /// @notice Used by T staking contract to inform the application that the\n    ///         authorized amount for the given staking provider increased.\n    ///         The application may do any necessary housekeeping. The\n    ///         application must revert the transaction in case the\n    ///         authorization is below the minimum required.\n    function authorizationIncreased(\n        address stakingProvider,\n        uint96 fromAmount,\n        uint96 toAmount\n    ) external;\n\n    /// @notice Used by T staking contract to inform the application that the\n    ///         authorization decrease for the given staking provider has been\n    ///         requested. The application should mark the authorization as\n    ///         pending decrease and respond to the staking contract with\n    ///         `approveAuthorizationDecrease` at its discretion. It may\n    ///         happen right away but it also may happen several months later.\n    ///         If there is already a pending authorization decrease request\n    ///         for the application, and the application does not agree for\n    ///         overwriting it, the function should revert.\n    function authorizationDecreaseRequested(\n        address stakingProvider,\n        uint96 fromAmount,\n        uint96 toAmount\n    ) external;\n\n    /// @notice Used by T staking contract to inform the application the\n    ///         authorization has been decreased for the given staking provider\n    ///         involuntarily, as a result of slashing. Lets the application to\n    ///         do any housekeeping neccessary. Called with 250k gas limit and\n    ///         does not revert the transaction if\n    ///         `involuntaryAuthorizationDecrease` call failed.\n    function involuntaryAuthorizationDecrease(\n        address stakingProvider,\n        uint96 fromAmount,\n        uint96 toAmount\n    ) external;\n\n    /// @notice Returns the amount of application rewards available for\n    ///         withdrawal for the given staking provider.\n    function availableRewards(address stakingProvider)\n        external\n        view\n        returns (uint96);\n\n    /// @notice The minimum authorization amount required for the staking\n    ///         provider so that they can participate in the application.\n    function minimumAuthorization() external view returns (uint96);\n}\n"
    },
    "@threshold-network/solidity-contracts/contracts/staking/IStaking.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\n// ██████████████     ▐████▌     ██████████████\n// ██████████████     ▐████▌     ██████████████\n//               ▐████▌    ▐████▌\n//               ▐████▌    ▐████▌\n// ██████████████     ▐████▌     ██████████████\n// ██████████████     ▐████▌     ██████████████\n//               ▐████▌    ▐████▌\n//               ▐████▌    ▐████▌\n//               ▐████▌    ▐████▌\n//               ▐████▌    ▐████▌\n//               ▐████▌    ▐████▌\n//               ▐████▌    ▐████▌\n\npragma solidity ^0.8.9;\n\n/// @title Interface of Threshold Network staking contract\n/// @notice The staking contract enables T owners to have their wallets offline\n///         and their stake managed by staking providers on their behalf.\n///         The staking contract does not define operator role. The operator\n///         responsible for running off-chain client software is appointed by\n///         the staking provider in the particular application utilizing the\n///         staking contract. All off-chain client software should be able\n///         to run without exposing operator's or staking provider’s private\n///         key and should not require any owner’s keys at all. The stake\n///         delegation optimizes the network throughput without compromising the\n///         security of the owners’ stake.\ninterface IStaking {\n    enum StakeType {\n        NU,\n        KEEP,\n        T\n    }\n\n    //\n    //\n    // Delegating a stake\n    //\n    //\n\n    /// @notice Creates a delegation with `msg.sender` owner with the given\n    ///         staking provider, beneficiary, and authorizer. Transfers the\n    ///         given amount of T to the staking contract.\n    /// @dev The owner of the delegation needs to have the amount approved to\n    ///      transfer to the staking contract.\n    function stake(\n        address stakingProvider,\n        address payable beneficiary,\n        address authorizer,\n        uint96 amount\n    ) external;\n\n    /// @notice Copies delegation from the legacy KEEP staking contract to T\n    ///         staking contract. No tokens are transferred. Caches the active\n    ///         stake amount from KEEP staking contract. Can be called by\n    ///         anyone.\n    /// @dev The staking provider in T staking contract is the legacy KEEP\n    ///      staking contract operator.\n    function stakeKeep(address stakingProvider) external;\n\n    /// @notice Copies delegation from the legacy NU staking contract to T\n    ///         staking contract, additionally appointing staking provider,\n    ///         beneficiary and authorizer roles. Caches the amount staked in NU\n    ///         staking contract. Can be called only by the original delegation\n    ///         owner.\n    function stakeNu(\n        address stakingProvider,\n        address payable beneficiary,\n        address authorizer\n    ) external;\n\n    /// @notice Refresh Keep stake owner. Can be called only by the old owner\n    ///         or their staking provider.\n    /// @dev The staking provider in T staking contract is the legacy KEEP\n    ///      staking contract operator.\n    function refreshKeepStakeOwner(address stakingProvider) external;\n\n    /// @notice Allows the Governance to set the minimum required stake amount.\n    ///         This amount is required to protect against griefing the staking\n    ///         contract and individual applications are allowed to require\n    ///         higher minimum stakes if necessary.\n    function setMinimumStakeAmount(uint96 amount) external;\n\n    //\n    //\n    // Authorizing an application\n    //\n    //\n\n    /// @notice Allows the Governance to approve the particular application\n    ///         before individual stake authorizers are able to authorize it.\n    function approveApplication(address application) external;\n\n    /// @notice Increases the authorization of the given staking provider for\n    ///         the given application by the given amount. Can only be called by\n    ///         the authorizer for that staking provider.\n    /// @dev Calls `authorizationIncreased(address stakingProvider, uint256 amount)`\n    ///      on the given application to notify the application about\n    ///      authorization change. See `IApplication`.\n    function increaseAuthorization(\n        address stakingProvider,\n        address application,\n        uint96 amount\n    ) external;\n\n    /// @notice Requests decrease of the authorization for the given staking\n    ///         provider on the given application by the provided amount.\n    ///         It may not change the authorized amount immediatelly. When\n    ///         it happens depends on the application. Can only be called by the\n    ///         given staking provider’s authorizer. Overwrites pending\n    ///         authorization decrease for the given staking provider and\n    ///         application if the application agrees for that. If the\n    ///         application does not agree for overwriting, the function\n    ///         reverts.\n    /// @dev Calls `authorizationDecreaseRequested(address stakingProvider, uint256 amount)`\n    ///      on the given application. See `IApplication`.\n    function requestAuthorizationDecrease(\n        address stakingProvider,\n        address application,\n        uint96 amount\n    ) external;\n\n    /// @notice Requests decrease of all authorizations for the given staking\n    ///         provider on all applications by all authorized amount.\n    ///         It may not change the authorized amount immediatelly. When\n    ///         it happens depends on the application. Can only be called by the\n    ///         given staking provider’s authorizer. Overwrites pending\n    ///         authorization decrease for the given staking provider and\n    ///         application.\n    /// @dev Calls `authorizationDecreaseRequested(address stakingProvider, uint256 amount)`\n    ///      for each authorized application. See `IApplication`.\n    function requestAuthorizationDecrease(address stakingProvider) external;\n\n    /// @notice Called by the application at its discretion to approve the\n    ///         previously requested authorization decrease request. Can only be\n    ///         called by the application that was previously requested to\n    ///         decrease the authorization for that staking provider.\n    ///         Returns resulting authorized amount for the application.\n    function approveAuthorizationDecrease(address stakingProvider)\n        external\n        returns (uint96);\n\n    /// @notice Decreases the authorization for the given `stakingProvider` on\n    ///         the given disabled `application`, for all authorized amount.\n    ///         Can be called by anyone.\n    function forceDecreaseAuthorization(\n        address stakingProvider,\n        address application\n    ) external;\n\n    /// @notice Pauses the given application’s eligibility to slash stakes.\n    ///         Besides that stakers can't change authorization to the application.\n    ///         Can be called only by the Panic Button of the particular\n    ///         application. The paused application can not slash stakes until\n    ///         it is approved again by the Governance using `approveApplication`\n    ///         function. Should be used only in case of an emergency.\n    function pauseApplication(address application) external;\n\n    /// @notice Disables the given application. The disabled application can't\n    ///         slash stakers. Also stakers can't increase authorization to that\n    ///         application but can decrease without waiting by calling\n    ///         `requestAuthorizationDecrease` at any moment. Can be called only\n    ///         by the governance. The disabled application can't be approved\n    ///         again. Should be used only in case of an emergency.\n    function disableApplication(address application) external;\n\n    /// @notice Sets the Panic Button role for the given application to the\n    ///         provided address. Can only be called by the Governance. If the\n    ///         Panic Button for the given application should be disabled, the\n    ///         role address should be set to 0x0 address.\n    function setPanicButton(address application, address panicButton) external;\n\n    /// @notice Sets the maximum number of applications one staking provider can\n    ///         have authorized. Used to protect against DoSing slashing queue.\n    ///         Can only be called by the Governance.\n    function setAuthorizationCeiling(uint256 ceiling) external;\n\n    //\n    //\n    // Stake top-up\n    //\n    //\n\n    /// @notice Increases the amount of the stake for the given staking provider.\n    /// @dev The sender of this transaction needs to have the amount approved to\n    ///      transfer to the staking contract.\n    function topUp(address stakingProvider, uint96 amount) external;\n\n    /// @notice Propagates information about stake top-up from the legacy KEEP\n    ///         staking contract to T staking contract. Can be called only by\n    ///         the owner or the staking provider.\n    function topUpKeep(address stakingProvider) external;\n\n    /// @notice Propagates information about stake top-up from the legacy NU\n    ///         staking contract to T staking contract. Can be called only by\n    ///         the owner or the staking provider.\n    function topUpNu(address stakingProvider) external;\n\n    //\n    //\n    // Undelegating a stake (unstaking)\n    //\n    //\n\n    /// @notice Reduces the liquid T stake amount by the provided amount and\n    ///         withdraws T to the owner. Reverts if there is at least one\n    ///         authorization higher than the sum of the legacy stake and\n    ///         remaining liquid T stake or if the unstake amount is higher than\n    ///         the liquid T stake amount. Can be called only by the delegation\n    ///         owner or the staking provider.\n    function unstakeT(address stakingProvider, uint96 amount) external;\n\n    /// @notice Sets the legacy KEEP staking contract active stake amount cached\n    ///         in T staking contract to 0. Reverts if the amount of liquid T\n    ///         staked in T staking contract is lower than the highest\n    ///         application authorization. This function allows to unstake from\n    ///         KEEP staking contract and still being able to operate in T\n    ///         network and earning rewards based on the liquid T staked. Can be\n    ///         called only by the delegation owner or the staking provider.\n    function unstakeKeep(address stakingProvider) external;\n\n    /// @notice Reduces cached legacy NU stake amount by the provided amount.\n    ///         Reverts if there is at least one authorization higher than the\n    ///         sum of remaining legacy NU stake and liquid T stake for that\n    ///         staking provider or if the untaked amount is higher than the\n    ///         cached legacy stake amount. If succeeded, the legacy NU stake\n    ///         can be partially or fully undelegated on the legacy staking\n    ///         contract. This function allows to unstake from NU staking\n    ///         contract and still being able to operate in T network and\n    ///         earning rewards based on the liquid T staked. Can be called only\n    ///         by the delegation owner or the staking provider.\n    function unstakeNu(address stakingProvider, uint96 amount) external;\n\n    /// @notice Sets cached legacy stake amount to 0, sets the liquid T stake\n    ///         amount to 0 and withdraws all liquid T from the stake to the\n    ///         owner. Reverts if there is at least one non-zero authorization.\n    ///         Can be called only by the delegation owner or the staking\n    ///         provider.\n    function unstakeAll(address stakingProvider) external;\n\n    //\n    //\n    // Keeping information in sync\n    //\n    //\n\n    /// @notice Notifies about the discrepancy between legacy KEEP active stake\n    ///         and the amount cached in T staking contract. Slashes the staking\n    ///         provider in case the amount cached is higher than the actual\n    ///         active stake amount in KEEP staking contract. Needs to update\n    ///         authorizations of all affected applications and execute an\n    ///         involuntary allocation decrease on all affected applications.\n    ///         Can be called by anyone, notifier receives a reward.\n    function notifyKeepStakeDiscrepancy(address stakingProvider) external;\n\n    /// @notice Notifies about the discrepancy between legacy NU active stake\n    ///         and the amount cached in T staking contract. Slashes the\n    ///         staking provider in case the amount cached is higher than the\n    ///         actual active stake amount in NU staking contract. Needs to\n    ///         update authorizations of all affected applications and execute\n    ///         an involuntary allocation decrease on all affected applications.\n    ///         Can be called by anyone, notifier receives a reward.\n    function notifyNuStakeDiscrepancy(address stakingProvider) external;\n\n    /// @notice Sets the penalty amount for stake discrepancy and reward\n    ///         multiplier for reporting it. The penalty is seized from the\n    ///         delegated stake, and 5% of the penalty, scaled by the\n    ///         multiplier, is given to the notifier. The rest of the tokens are\n    ///         burned. Can only be called by the Governance. See `seize` function.\n    function setStakeDiscrepancyPenalty(\n        uint96 penalty,\n        uint256 rewardMultiplier\n    ) external;\n\n    /// @notice Sets reward in T tokens for notification of misbehaviour\n    ///         of one staking provider. Can only be called by the governance.\n    function setNotificationReward(uint96 reward) external;\n\n    /// @notice Transfer some amount of T tokens as reward for notifications\n    ///         of misbehaviour\n    function pushNotificationReward(uint96 reward) external;\n\n    /// @notice Withdraw some amount of T tokens from notifiers treasury.\n    ///         Can only be called by the governance.\n    function withdrawNotificationReward(address recipient, uint96 amount)\n        external;\n\n    /// @notice Adds staking providers to the slashing queue along with the\n    ///         amount that should be slashed from each one of them. Can only be\n    ///         called by application authorized for all staking providers in\n    ///         the array.\n    function slash(uint96 amount, address[] memory stakingProviders) external;\n\n    /// @notice Adds staking providers to the slashing queue along with the\n    ///         amount. The notifier will receive reward per each staking\n    ///         provider from notifiers treasury. Can only be called by\n    ///         application authorized for all staking providers in the array.\n    function seize(\n        uint96 amount,\n        uint256 rewardMultipier,\n        address notifier,\n        address[] memory stakingProviders\n    ) external;\n\n    /// @notice Takes the given number of queued slashing operations and\n    ///         processes them. Receives 5% of the slashed amount.\n    ///         Executes `involuntaryAllocationDecrease` function on each\n    ///         affected application.\n    function processSlashing(uint256 count) external;\n\n    //\n    //\n    // Auxiliary functions\n    //\n    //\n\n    /// @notice Returns the authorized stake amount of the staking provider for\n    ///         the application.\n    function authorizedStake(address stakingProvider, address application)\n        external\n        view\n        returns (uint96);\n\n    /// @notice Returns staked amount of T, Keep and Nu for the specified\n    ///         staking provider.\n    /// @dev    All values are in T denomination\n    function stakes(address stakingProvider)\n        external\n        view\n        returns (\n            uint96 tStake,\n            uint96 keepInTStake,\n            uint96 nuInTStake\n        );\n\n    /// @notice Returns start staking timestamp.\n    /// @dev    This value is set at most once.\n    function getStartStakingTimestamp(address stakingProvider)\n        external\n        view\n        returns (uint256);\n\n    /// @notice Returns staked amount of NU for the specified staking provider.\n    function stakedNu(address stakingProvider) external view returns (uint256);\n\n    /// @notice Gets the stake owner, the beneficiary and the authorizer\n    ///         for the specified staking provider address.\n    /// @return owner Stake owner address.\n    /// @return beneficiary Beneficiary address.\n    /// @return authorizer Authorizer address.\n    function rolesOf(address stakingProvider)\n        external\n        view\n        returns (\n            address owner,\n            address payable beneficiary,\n            address authorizer\n        );\n\n    /// @notice Returns length of application array\n    function getApplicationsLength() external view returns (uint256);\n\n    /// @notice Returns length of slashing queue\n    function getSlashingQueueLength() external view returns (uint256);\n\n    /// @notice Returns minimum possible stake for T, KEEP or NU in T\n    ///         denomination.\n    /// @dev For example, suppose the given staking provider has 10 T, 20 T\n    ///      worth of KEEP, and 30 T worth of NU all staked, and the maximum\n    ///      application authorization is 40 T, then `getMinStaked` for\n    ///      that staking provider returns:\n    ///          * 0 T if KEEP stake type specified i.e.\n    ///            min = 40 T max - (10 T + 30 T worth of NU) = 0 T\n    ///          * 10 T if NU stake type specified i.e.\n    ///            min = 40 T max - (10 T + 20 T worth of KEEP) = 10 T\n    ///          * 0 T if T stake type specified i.e.\n    ///            min = 40 T max - (20 T worth of KEEP + 30 T worth of NU) < 0 T\n    ///      In other words, the minimum stake amount for the specified\n    ///      stake type is the minimum amount of stake of the given type\n    ///      needed to satisfy the maximum application authorization given the\n    ///      staked amounts of the other stake types for that staking provider.\n    function getMinStaked(address stakingProvider, StakeType stakeTypes)\n        external\n        view\n        returns (uint96);\n\n    /// @notice Returns available amount to authorize for the specified application\n    function getAvailableToAuthorize(\n        address stakingProvider,\n        address application\n    ) external view returns (uint96);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\n     * initialization.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized < type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/cryptography/ECDSAUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.3) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../StringsUpgradeable.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSAUpgradeable {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", StringsUpgradeable.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "@keep-network/random-beacon/contracts/libraries/BytesLib.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n//\n// ▓▓▌ ▓▓ ▐▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▄\n// ▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n//   ▓▓▓▓▓▓    ▓▓▓▓▓▓▓▀    ▐▓▓▓▓▓▓    ▐▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n//   ▓▓▓▓▓▓▄▄▓▓▓▓▓▓▓▀      ▐▓▓▓▓▓▓▄▄▄▄         ▓▓▓▓▓▓▄▄▄▄         ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n//   ▓▓▓▓▓▓▓▓▓▓▓▓▓▀        ▐▓▓▓▓▓▓▓▓▓▓         ▓▓▓▓▓▓▓▓▓▓         ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n//   ▓▓▓▓▓▓▀▀▓▓▓▓▓▓▄       ▐▓▓▓▓▓▓▀▀▀▀         ▓▓▓▓▓▓▀▀▀▀         ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▀\n//   ▓▓▓▓▓▓   ▀▓▓▓▓▓▓▄     ▐▓▓▓▓▓▓     ▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌\n// ▓▓▓▓▓▓▓▓▓▓ █▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▓▓\n// ▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▓▓\n//\n//\n\npragma solidity 0.8.17;\n\n/*\nVersion pulled from keep-core v1:\nhttps://github.com/keep-network/keep-core/blob/f297202db00c027978ad8e7103a356503de5773c/solidity-v1/contracts/utils/BytesLib.sol\n\nTo compile it with solidity 0.8 `_preBytes_slot` was replaced with `_preBytes.slot`.\n*/\n\n/*\nhttps://github.com/GNSPS/solidity-bytes-utils/\nThis is free and unencumbered software released into the public domain.\nAnyone is free to copy, modify, publish, use, compile, sell, or\ndistribute this software, either in source code form or as a compiled\nbinary, for any purpose, commercial or non-commercial, and by any\nmeans.\nIn jurisdictions that recognize copyright laws, the author or authors\nof this software dedicate any and all copyright interest in the\nsoftware to the public domain. We make this dedication for the benefit\nof the public at large and to the detriment of our heirs and\nsuccessors. We intend this dedication to be an overt act of\nrelinquishment in perpetuity of all present and future rights to this\nsoftware under copyright law.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR\nOTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\nARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\nOTHER DEALINGS IN THE SOFTWARE.\nFor more information, please refer to <https://unlicense.org>\n*/\n\n/** @title BytesLib **/\n/** @author https://github.com/GNSPS **/\n\nlibrary BytesLib {\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes)\n        internal\n    {\n        assembly {\n            // Read the first 32 bytes of _preBytes storage, which is the length\n            // of the array. (We don't need to use the offset into the slot\n            // because arrays use the entire slot.)\n            let fslot := sload(_preBytes.slot)\n            // Arrays of 31 bytes or less have an even value in their slot,\n            // while longer arrays have an odd value. The actual length is\n            // the slot divided by two for odd values, and the lowest order\n            // byte divided by two for even values.\n            // If the slot is even, bitwise and the slot with 255 and divide by\n            // two to get the length. If the slot is odd, bitwise and the slot\n            // with -1 and divide by two.\n            let slength := div(\n                and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)),\n                2\n            )\n            let mlength := mload(_postBytes)\n            let newlength := add(slength, mlength)\n            // slength can contain both the length and contents of the array\n            // if length < 32 bytes so let's prepare for that\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n            switch add(lt(slength, 32), lt(newlength, 32))\n            case 2 {\n                // Since the new array still fits in the slot, we just need to\n                // update the contents of the slot.\n                // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\n                sstore(\n                    _preBytes.slot,\n                    // all the modifications to the slot are inside this\n                    // next block\n                    add(\n                        // we can just add to the slot contents because the\n                        // bytes we want to change are the LSBs\n                        fslot,\n                        add(\n                            mul(\n                                div(\n                                    // load the bytes from memory\n                                    mload(add(_postBytes, 0x20)),\n                                    // zero all bytes to the right\n                                    exp(0x100, sub(32, mlength))\n                                ),\n                                // and now shift left the number of bytes to\n                                // leave space for the length in the slot\n                                exp(0x100, sub(32, newlength))\n                            ),\n                            // increase length by the double of the memory\n                            // bytes length\n                            mul(mlength, 2)\n                        )\n                    )\n                )\n            }\n            case 1 {\n                // The stored value fits in the slot, but the combined value\n                // will exceed it.\n                // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes.slot)\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n                // save new length\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n                // The contents of the _postBytes array start 32 bytes into\n                // the structure. Our first read should obtain the `submod`\n                // bytes that can fit into the unused space in the last word\n                // of the stored array. To get this, we read 32 bytes starting\n                // from `submod`, so the data we read overlaps with the array\n                // contents by `submod` bytes. Masking the lowest-order\n                // `submod` bytes allows us to add that value directly to the\n                // stored value.\n\n                let submod := sub(32, slength)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(\n                    sc,\n                    add(\n                        and(\n                            fslot,\n                            0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\n                        ),\n                        and(mload(mc), mask)\n                    )\n                )\n\n                for {\n                    mc := add(mc, 0x20)\n                    sc := add(sc, 1)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n            default {\n                // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes.slot)\n                // Start copying to the last used word of the stored array.\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n                // save new length\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n                // Copy over the first `submod` bytes of the new data as in\n                // case 1 above.\n                let slengthmod := mod(slength, 32)\n                let submod := sub(32, slengthmod)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\n\n                for {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n        }\n    }\n\n    function equalStorage(bytes storage _preBytes, bytes memory _postBytes)\n        internal\n        view\n        returns (bool)\n    {\n        bool success = true;\n\n        assembly {\n            // we know _preBytes_offset is 0\n            let fslot := sload(_preBytes.slot)\n            // Decode the length of the stored array like in concatStorage().\n            let slength := div(\n                and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)),\n                2\n            )\n            let mlength := mload(_postBytes)\n\n            // if lengths don't match the arrays are not equal\n            switch eq(slength, mlength)\n            case 1 {\n                // slength can contain both the length and contents of the array\n                // if length < 32 bytes so let's prepare for that\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n                if iszero(iszero(slength)) {\n                    switch lt(slength, 32)\n                    case 1 {\n                        // blank the last byte which is the length\n                        fslot := mul(div(fslot, 0x100), 0x100)\n\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\n                            // unsuccess:\n                            success := 0\n                        }\n                    }\n                    default {\n                        // cb is a circuit breaker in the for loop since there's\n                        //  no said feature for inline assembly loops\n                        // cb = 1 - don't breaker\n                        // cb = 0 - break\n                        let cb := 1\n\n                        // get the keccak hash to get the contents of the array\n                        mstore(0x0, _preBytes.slot)\n                        let sc := keccak256(0x0, 0x20)\n\n                        let mc := add(_postBytes, 0x20)\n                        let end := add(mc, mlength)\n\n                        // the next line is the loop condition:\n                        // while(uint(mc < end) + cb == 2)\n                        for {\n\n                        } eq(add(lt(mc, end), cb), 2) {\n                            sc := add(sc, 1)\n                            mc := add(mc, 0x20)\n                        } {\n                            if iszero(eq(sload(sc), mload(mc))) {\n                                // unsuccess:\n                                success := 0\n                                cb := 0\n                            }\n                        }\n                    }\n                }\n            }\n            default {\n                // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n\n    function concat(bytes memory _preBytes, bytes memory _postBytes)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        bytes memory tempBytes;\n\n        assembly {\n            // Get a location of some free memory and store it in tempBytes as\n            // Solidity does for memory variables.\n            tempBytes := mload(0x40)\n\n            // Store the length of the first bytes array at the beginning of\n            // the memory for tempBytes.\n            let length := mload(_preBytes)\n            mstore(tempBytes, length)\n\n            // Maintain a memory counter for the current write location in the\n            // temp bytes array by adding the 32 bytes for the array length to\n            // the starting location.\n            let mc := add(tempBytes, 0x20)\n            // Stop copying when the memory counter reaches the length of the\n            // first bytes array.\n            let end := add(mc, length)\n\n            for {\n                // Initialize a copy counter to the start of the _preBytes data,\n                // 32 bytes into its memory.\n                let cc := add(_preBytes, 0x20)\n            } lt(mc, end) {\n                // Increase both counters by 32 bytes each iteration.\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                // Write the _preBytes data into the tempBytes memory 32 bytes\n                // at a time.\n                mstore(mc, mload(cc))\n            }\n\n            // Add the length of _postBytes to the current length of tempBytes\n            // and store it as the new length in the first 32 bytes of the\n            // tempBytes memory.\n            length := mload(_postBytes)\n            mstore(tempBytes, add(length, mload(tempBytes)))\n\n            // Move the memory counter back from a multiple of 0x20 to the\n            // actual end of the _preBytes data.\n            mc := end\n            // Stop copying when the memory counter reaches the new combined\n            // length of the arrays.\n            end := add(mc, length)\n\n            for {\n                let cc := add(_postBytes, 0x20)\n            } lt(mc, end) {\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                mstore(mc, mload(cc))\n            }\n\n            // Update the free-memory pointer by padding our last write location\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\n            // next 32 byte block, then round down to the nearest multiple of\n            // 32. If the sum of the length of the two arrays is zero then add\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\n            mstore(\n                0x40,\n                and(\n                    add(add(end, iszero(add(length, mload(_preBytes)))), 31),\n                    not(31) // Round down to the nearest 32 bytes.\n                )\n            )\n        }\n\n        return tempBytes;\n    }\n\n    function slice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    ) internal pure returns (bytes memory res) {\n        uint256 _end = _start + _length;\n        require(_end > _start && _bytes.length >= _end, \"Slice out of bounds\");\n\n        assembly {\n            // Alloc bytes array with additional 32 bytes afterspace and assign it's size\n            res := mload(0x40)\n            mstore(0x40, add(add(res, 64), _length))\n            mstore(res, _length)\n\n            // Compute distance between source and destination pointers\n            let diff := sub(res, add(_bytes, _start))\n\n            for {\n                let src := add(add(_bytes, 32), _start)\n                let end := add(src, _length)\n            } lt(src, end) {\n                src := add(src, 32)\n            } {\n                mstore(add(src, diff), mload(src))\n            }\n        }\n    }\n\n    function toAddress(bytes memory _bytes, uint256 _start)\n        internal\n        pure\n        returns (address)\n    {\n        uint256 _totalLen = _start + 20;\n        require(\n            _totalLen > _start && _bytes.length >= _totalLen,\n            \"Address conversion out of bounds.\"\n        );\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(\n                mload(add(add(_bytes, 0x20), _start)),\n                0x1000000000000000000000000\n            )\n        }\n\n        return tempAddress;\n    }\n\n    function toUint8(bytes memory _bytes, uint256 _start)\n        internal\n        pure\n        returns (uint8)\n    {\n        require(\n            _bytes.length >= (_start + 1),\n            \"Uint8 conversion out of bounds.\"\n        );\n        uint8 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x1), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint(bytes memory _bytes, uint256 _start)\n        internal\n        pure\n        returns (uint256)\n    {\n        uint256 _totalLen = _start + 32;\n        require(\n            _totalLen > _start && _bytes.length >= _totalLen,\n            \"Uint conversion out of bounds.\"\n        );\n        uint256 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempUint;\n    }\n\n    function equal(bytes memory _preBytes, bytes memory _postBytes)\n        internal\n        pure\n        returns (bool)\n    {\n        bool success = true;\n\n        assembly {\n            let length := mload(_preBytes)\n\n            // if lengths don't match the arrays are not equal\n            switch eq(length, mload(_postBytes))\n            case 1 {\n                // cb is a circuit breaker in the for loop since there's\n                //  no said feature for inline assembly loops\n                // cb = 1 - don't breaker\n                // cb = 0 - break\n                let cb := 1\n\n                let mc := add(_preBytes, 0x20)\n                let end := add(mc, length)\n\n                for {\n                    let cc := add(_postBytes, 0x20)\n                    // the next line is the loop condition:\n                    // while(uint(mc < end) + cb == 2)\n                } eq(add(lt(mc, end), cb), 2) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    // if any of these checks fails then arrays are not equal\n                    if iszero(eq(mload(mc), mload(cc))) {\n                        // unsuccess:\n                        success := 0\n                        cb := 0\n                    }\n                }\n            }\n            default {\n                // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n\n    function toBytes32(bytes memory _source)\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        if (_source.length == 0) {\n            return 0x0;\n        }\n\n        assembly {\n            result := mload(add(_source, 32))\n        }\n    }\n\n    function keccak256Slice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    ) internal pure returns (bytes32 result) {\n        uint256 _end = _start + _length;\n        require(_end > _start && _bytes.length >= _end, \"Slice out of bounds\");\n\n        assembly {\n            result := keccak256(add(add(_bytes, 32), _start), _length)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary StringsUpgradeable {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "@thesis/solidity-contracts/contracts/token/IERC20WithPermit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport \"./IApproveAndCall.sol\";\n\n/// @title  IERC20WithPermit\n/// @notice Burnable ERC20 token with EIP2612 permit functionality. User can\n///         authorize a transfer of their token with a signature conforming\n///         EIP712 standard instead of an on-chain transaction from their\n///         address. Anyone can submit this signature on the user's behalf by\n///         calling the permit function, as specified in EIP2612 standard,\n///         paying gas fees, and possibly performing other actions in the same\n///         transaction.\ninterface IERC20WithPermit is IERC20, IERC20Metadata, IApproveAndCall {\n    /// @notice EIP2612 approval made with secp256k1 signature.\n    ///         Users can authorize a transfer of their tokens with a signature\n    ///         conforming EIP712 standard, rather than an on-chain transaction\n    ///         from their address. Anyone can submit this signature on the\n    ///         user's behalf by calling the permit function, paying gas fees,\n    ///         and possibly performing other actions in the same transaction.\n    /// @dev    The deadline argument can be set to `type(uint256).max to create\n    ///         permits that effectively never expire.\n    function permit(\n        address owner,\n        address spender,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /// @notice Destroys `amount` tokens from the caller.\n    function burn(uint256 amount) external;\n\n    /// @notice Destroys `amount` of tokens from `account`, deducting the amount\n    ///         from caller's allowance.\n    function burnFrom(address account, uint256 amount) external;\n\n    /// @notice Returns hash of EIP712 Domain struct with the token name as\n    ///         a signing domain and token contract as a verifying contract.\n    ///         Used to construct EIP2612 signature provided to `permit`\n    ///         function.\n    /* solhint-disable-next-line func-name-mixedcase */\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    /// @notice Returns the current nonce for EIP2612 permission for the\n    ///         provided token owner for a replay protection. Used to construct\n    ///         EIP2612 signature provided to `permit` function.\n    function nonce(address owner) external view returns (uint256);\n\n    /// @notice Returns EIP2612 Permit message hash. Used to construct EIP2612\n    ///         signature provided to `permit` function.\n    /* solhint-disable-next-line func-name-mixedcase */\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n}\n"
    },
    "@thesis/solidity-contracts/contracts/token/IReceiveApproval.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\n\n/// @notice An interface that should be implemented by contracts supporting\n///         `approveAndCall`/`receiveApproval` pattern.\ninterface IReceiveApproval {\n    /// @notice Receives approval to spend tokens. Called as a result of\n    ///         `approveAndCall` call on the token.\n    function receiveApproval(\n        address from,\n        uint256 amount,\n        address token,\n        bytes calldata extraData\n    ) external;\n}\n"
    },
    "@keep-network/sortition-pools/contracts/RNG.sol": {
      "content": "pragma solidity 0.8.17;\n\nimport \"./Leaf.sol\";\nimport \"./Constants.sol\";\n\nlibrary RNG {\n  /// @notice Get an index in the range `[0 .. range-1]`\n  /// and the new state of the RNG,\n  /// using the provided `state` of the RNG.\n  ///\n  /// @param range The upper bound of the index, exclusive.\n  ///\n  /// @param state The previous state of the RNG.\n  /// The initial state needs to be obtained\n  /// from a trusted randomness oracle (the random beacon),\n  /// or from a chain of earlier calls to `RNG.getIndex()`\n  /// on an originally trusted seed.\n  ///\n  /// @dev Calculates the number of bits required for the desired range,\n  /// takes the least significant bits of `state`\n  /// and checks if the obtained index is within the desired range.\n  /// The original state is hashed with `keccak256` to get a new state.\n  /// If the index is outside the range,\n  /// the function retries until it gets a suitable index.\n  ///\n  /// @return index A random integer between `0` and `range - 1`, inclusive.\n  ///\n  /// @return newState The new state of the RNG.\n  /// When `getIndex()` is called one or more times,\n  /// care must be taken to always use the output `state`\n  /// of the most recent call as the input `state` of a subsequent call.\n  /// At the end of a transaction calling `RNG.getIndex()`,\n  /// the previous stored state must be overwritten with the latest output.\n  function getIndex(\n    uint256 range,\n    bytes32 state,\n    uint256 bits\n  ) internal view returns (uint256, bytes32) {\n    bool found = false;\n    uint256 index = 0;\n    bytes32 newState = state;\n    while (!found) {\n      index = truncate(bits, uint256(newState));\n      newState = keccak256(abi.encodePacked(newState, address(this)));\n      if (index < range) {\n        found = true;\n      }\n    }\n    return (index, newState);\n  }\n\n  /// @notice Calculate how many bits are required\n  /// for an index in the range `[0 .. range-1]`.\n  ///\n  /// @param range The upper bound of the desired range, exclusive.\n  ///\n  /// @return uint The smallest number of bits\n  /// that can contain the number `range-1`.\n  function bitsRequired(uint256 range) internal pure returns (uint256) {\n    unchecked {\n      if (range == 1) {\n        return 0;\n      }\n\n      uint256 bits = Constants.WEIGHT_WIDTH - 1;\n\n      // Left shift by `bits`,\n      // so we have a 1 in the (bits + 1)th least significant bit\n      // and 0 in other bits.\n      // If this number is equal or greater than `range`,\n      // the range [0, range-1] fits in `bits` bits.\n      //\n      // Because we loop from high bits to low bits,\n      // we find the highest number of bits that doesn't fit the range,\n      // and return that number + 1.\n      while (1 << bits >= range) {\n        bits--;\n      }\n\n      return bits + 1;\n    }\n  }\n\n  /// @notice Truncate `input` to the `bits` least significant bits.\n  function truncate(uint256 bits, uint256 input)\n    internal\n    pure\n    returns (uint256)\n  {\n    unchecked {\n      return input & ((1 << bits) - 1);\n    }\n  }\n}\n"
    },
    "@keep-network/sortition-pools/contracts/SortitionTree.sol": {
      "content": "pragma solidity 0.8.17;\n\nimport \"./Branch.sol\";\nimport \"./Position.sol\";\nimport \"./Leaf.sol\";\nimport \"./Constants.sol\";\n\ncontract SortitionTree {\n  using Branch for uint256;\n  using Position for uint256;\n  using Leaf for uint256;\n\n  // implicit tree\n  // root 8\n  // level2 64\n  // level3 512\n  // level4 4k\n  // level5 32k\n  // level6 256k\n  // level7 2M\n  uint256 internal root;\n\n  // A 2-index mapping from layer => (index (0-index) => branch). For example,\n  // to access the 6th branch in the 2nd layer (right below the root node; the\n  // first branch layer), call branches[2][5]. Mappings are used in place of\n  // arrays for efficiency. The root is the first layer, the branches occupy\n  // layers 2 through 7, and layer 8 is for the leaves. Following this\n  // convention, the first index in `branches` is `2`, and the last index is\n  // `7`.\n  mapping(uint256 => mapping(uint256 => uint256)) internal branches;\n\n  // A 0-index mapping from index => leaf, acting as an array. For example, to\n  // access the 42nd leaf, call leaves[41].\n  mapping(uint256 => uint256) internal leaves;\n\n  // the flagged (see setFlag() and unsetFlag() in Position.sol) positions\n  // of all operators present in the pool\n  mapping(address => uint256) internal flaggedLeafPosition;\n\n  // the leaf after the rightmost occupied leaf of each stack\n  uint256 internal rightmostLeaf;\n\n  // the empty leaves in each stack\n  // between 0 and the rightmost occupied leaf\n  uint256[] internal emptyLeaves;\n\n  // Each operator has an uint32 ID number\n  // which is allocated when they first join the pool\n  // and remains unchanged even if they leave and rejoin the pool.\n  mapping(address => uint32) internal operatorID;\n\n  // The idAddress array records the address corresponding to each ID number.\n  // The ID number 0 is initialized with a zero address and is not used.\n  address[] internal idAddress;\n\n  constructor() {\n    root = 0;\n    rightmostLeaf = 0;\n    idAddress.push();\n  }\n\n  /// @notice Return the ID number of the given operator address. An ID number\n  /// of 0 means the operator has not been allocated an ID number yet.\n  /// @param operator Address of the operator.\n  /// @return the ID number of the given operator address\n  function getOperatorID(address operator) public view returns (uint32) {\n    return operatorID[operator];\n  }\n\n  /// @notice Get the operator address corresponding to the given ID number. A\n  /// zero address means the ID number has not been allocated yet.\n  /// @param id ID of the operator\n  /// @return the address of the operator\n  function getIDOperator(uint32 id) public view returns (address) {\n    return idAddress.length > id ? idAddress[id] : address(0);\n  }\n\n  /// @notice Gets the operator addresses corresponding to the given ID\n  /// numbers. A zero address means the ID number has not been allocated yet.\n  /// This function works just like getIDOperator except that it allows to fetch\n  /// operator addresses for multiple IDs in one call.\n  /// @param ids the array of the operator ids\n  /// @return an array of the associated operator addresses\n  function getIDOperators(uint32[] calldata ids)\n    public\n    view\n    returns (address[] memory)\n  {\n    uint256 idCount = idAddress.length;\n\n    address[] memory operators = new address[](ids.length);\n    for (uint256 i = 0; i < ids.length; i++) {\n      uint32 id = ids[i];\n      operators[i] = idCount > id ? idAddress[id] : address(0);\n    }\n    return operators;\n  }\n\n  /// @notice Checks if operator is already registered in the pool.\n  /// @param operator the address of the operator\n  /// @return whether or not the operator is already registered in the pool\n  function isOperatorRegistered(address operator) public view returns (bool) {\n    return getFlaggedLeafPosition(operator) != 0;\n  }\n\n  /// @notice Sum the number of operators in each trunk.\n  /// @return the number of operators in the pool\n  function operatorsInPool() public view returns (uint256) {\n    // Get the number of leaves that might be occupied;\n    // if `rightmostLeaf` equals `firstLeaf()` the tree must be empty,\n    // otherwise the difference between these numbers\n    // gives the number of leaves that may be occupied.\n    uint256 nPossiblyUsedLeaves = rightmostLeaf;\n    // Get the number of empty leaves\n    // not accounted for by the `rightmostLeaf`\n    uint256 nEmptyLeaves = emptyLeaves.length;\n\n    return (nPossiblyUsedLeaves - nEmptyLeaves);\n  }\n\n  /// @notice Convenience method to return the total weight of the pool\n  /// @return the total weight of the pool\n  function totalWeight() public view returns (uint256) {\n    return root.sumWeight();\n  }\n\n  /// @notice Give the operator a new ID number.\n  /// Does not check if the operator already has an ID number.\n  /// @param operator the address of the operator\n  /// @return a new ID for that operator\n  function allocateOperatorID(address operator) internal returns (uint256) {\n    uint256 id = idAddress.length;\n\n    require(id <= type(uint32).max, \"Pool capacity exceeded\");\n\n    operatorID[operator] = uint32(id);\n    idAddress.push(operator);\n    return id;\n  }\n\n  /// @notice Inserts an operator into the sortition pool\n  /// @param operator the address of an operator to insert\n  /// @param weight how much weight that operator has in the pool\n  function _insertOperator(address operator, uint256 weight) internal {\n    require(\n      !isOperatorRegistered(operator),\n      \"Operator is already registered in the pool\"\n    );\n\n    // Fetch the operator's ID, and if they don't have one, allocate them one.\n    uint256 id = getOperatorID(operator);\n    if (id == 0) {\n      id = allocateOperatorID(operator);\n    }\n\n    // Determine which leaf to insert them into\n    uint256 position = getEmptyLeafPosition();\n    // Record the block the operator was inserted in\n    uint256 theLeaf = Leaf.make(operator, block.number, id);\n\n    // Update the leaf, and propagate the weight changes all the way up to the\n    // root.\n    root = setLeaf(position, theLeaf, weight, root);\n\n    // Without position flags,\n    // the position 0x000000 would be treated as empty\n    flaggedLeafPosition[operator] = position.setFlag();\n  }\n\n  /// @notice Remove an operator (and their weight) from the pool.\n  /// @param operator the address of the operator to remove\n  function _removeOperator(address operator) internal {\n    uint256 flaggedPosition = getFlaggedLeafPosition(operator);\n    require(flaggedPosition != 0, \"Operator is not registered in the pool\");\n    uint256 unflaggedPosition = flaggedPosition.unsetFlag();\n\n    // Update the leaf, and propagate the weight changes all the way up to the\n    // root.\n    root = removeLeaf(unflaggedPosition, root);\n    removeLeafPositionRecord(operator);\n  }\n\n  /// @notice Update an operator's weight in the pool.\n  /// @param operator the address of the operator to update\n  /// @param weight the new weight\n  function updateOperator(address operator, uint256 weight) internal {\n    require(\n      isOperatorRegistered(operator),\n      \"Operator is not registered in the pool\"\n    );\n\n    uint256 flaggedPosition = getFlaggedLeafPosition(operator);\n    uint256 unflaggedPosition = flaggedPosition.unsetFlag();\n    root = updateLeaf(unflaggedPosition, weight, root);\n  }\n\n  /// @notice Helper method to remove a leaf position record for an operator.\n  /// @param operator the address of the operator to remove the record for\n  function removeLeafPositionRecord(address operator) internal {\n    flaggedLeafPosition[operator] = 0;\n  }\n\n  /// @notice Removes the data and weight from a particular leaf.\n  /// @param position the leaf index to remove\n  /// @param _root the root node containing the leaf\n  /// @return the updated root node\n  function removeLeaf(uint256 position, uint256 _root)\n    internal\n    returns (uint256)\n  {\n    uint256 rightmostSubOne = rightmostLeaf - 1;\n    bool isRightmost = position == rightmostSubOne;\n\n    // Clears out the data in the leaf node, and then propagates the weight\n    // changes all the way up to the root.\n    uint256 newRoot = setLeaf(position, 0, 0, _root);\n\n    // Infer if need to fall back on emptyLeaves yet\n    if (isRightmost) {\n      rightmostLeaf = rightmostSubOne;\n    } else {\n      emptyLeaves.push(position);\n    }\n    return newRoot;\n  }\n\n  /// @notice Updates the tree to give a particular leaf a new weight.\n  /// @param position the index of the leaf to update\n  /// @param weight the new weight\n  /// @param _root the root node containing the leaf\n  /// @return the updated root node\n  function updateLeaf(\n    uint256 position,\n    uint256 weight,\n    uint256 _root\n  ) internal returns (uint256) {\n    if (getLeafWeight(position) != weight) {\n      return updateTree(position, weight, _root);\n    } else {\n      return _root;\n    }\n  }\n\n  /// @notice Places a leaf into a particular position, with a given weight and\n  /// propagates that change.\n  /// @param position the index to place the leaf in\n  /// @param theLeaf the new leaf to place in the position\n  /// @param leafWeight the weight of the leaf\n  /// @param _root the root containing the new leaf\n  /// @return the updated root node\n  function setLeaf(\n    uint256 position,\n    uint256 theLeaf,\n    uint256 leafWeight,\n    uint256 _root\n  ) internal returns (uint256) {\n    // set leaf\n    leaves[position] = theLeaf;\n\n    return (updateTree(position, leafWeight, _root));\n  }\n\n  /// @notice Propagates a weight change at a position through the tree,\n  /// eventually returning the updated root.\n  /// @param position the index of leaf to update\n  /// @param weight the new weight of the leaf\n  /// @param _root the root node containing the leaf\n  /// @return the updated root node\n  function updateTree(\n    uint256 position,\n    uint256 weight,\n    uint256 _root\n  ) internal returns (uint256) {\n    uint256 childSlot;\n    uint256 treeNode;\n    uint256 newNode;\n    uint256 nodeWeight = weight;\n\n    uint256 parent = position;\n    // set levels 7 to 2\n    for (uint256 level = Constants.LEVELS; level >= 2; level--) {\n      childSlot = parent.slot();\n      parent = parent.parent();\n      treeNode = branches[level][parent];\n      newNode = treeNode.setSlot(childSlot, nodeWeight);\n      branches[level][parent] = newNode;\n      nodeWeight = newNode.sumWeight();\n    }\n\n    // set level Root\n    childSlot = parent.slot();\n    return _root.setSlot(childSlot, nodeWeight);\n  }\n\n  /// @notice Retrieves the next available empty leaf position. Tries to fill\n  /// left to right first, ignoring leaf removals, and then fills\n  /// most-recent-removals first.\n  /// @return the position of the empty leaf\n  function getEmptyLeafPosition() internal returns (uint256) {\n    uint256 rLeaf = rightmostLeaf;\n    bool spaceOnRight = (rLeaf + 1) < Constants.POOL_CAPACITY;\n    if (spaceOnRight) {\n      rightmostLeaf = rLeaf + 1;\n      return rLeaf;\n    } else {\n      uint256 emptyLeafCount = emptyLeaves.length;\n      require(emptyLeafCount > 0, \"Pool is full\");\n      uint256 emptyLeaf = emptyLeaves[emptyLeafCount - 1];\n      emptyLeaves.pop();\n      return emptyLeaf;\n    }\n  }\n\n  /// @notice Gets the flagged leaf position for an operator.\n  /// @param operator the address of the operator\n  /// @return the leaf position of that operator\n  function getFlaggedLeafPosition(address operator)\n    internal\n    view\n    returns (uint256)\n  {\n    return flaggedLeafPosition[operator];\n  }\n\n  /// @notice Gets the weight of a leaf at a particular position.\n  /// @param position the index of the leaf\n  /// @return the weight of the leaf at that position\n  function getLeafWeight(uint256 position) internal view returns (uint256) {\n    uint256 slot = position.slot();\n    uint256 parent = position.parent();\n\n    // A leaf's weight information is stored a 32-bit slot in the branch layer\n    // directly above the leaf layer. To access it, we calculate that slot and\n    // parent position, and always know the hard-coded layer index.\n    uint256 node = branches[Constants.LEVELS][parent];\n    return node.getSlot(slot);\n  }\n\n  /// @notice Picks a leaf given a random index.\n  /// @param index a number in `[0, _root.totalWeight())` used to decide\n  /// between leaves\n  /// @param _root the root of the tree\n  function pickWeightedLeaf(uint256 index, uint256 _root)\n    internal\n    view\n    returns (uint256 leafPosition)\n  {\n    uint256 currentIndex = index;\n    uint256 currentNode = _root;\n    uint256 currentPosition = 0;\n    uint256 currentSlot;\n\n    require(index < currentNode.sumWeight(), \"Index exceeds weight\");\n\n    // get root slot\n    (currentSlot, currentIndex) = currentNode.pickWeightedSlot(currentIndex);\n\n    // get slots from levels 2 to 7\n    for (uint256 level = 2; level <= Constants.LEVELS; level++) {\n      currentPosition = currentPosition.child(currentSlot);\n      currentNode = branches[level][currentPosition];\n      (currentSlot, currentIndex) = currentNode.pickWeightedSlot(currentIndex);\n    }\n\n    // get leaf position\n    leafPosition = currentPosition.child(currentSlot);\n  }\n}\n"
    },
    "@keep-network/sortition-pools/contracts/Rewards.sol": {
      "content": "pragma solidity 0.8.17;\n\n/// @title Rewards\n/// @notice Rewards are allocated proportionally to operators\n/// present in the pool at payout based on their weight in the pool.\n///\n/// To facilitate this, we use a global accumulator value\n/// to track the total rewards one unit of weight would've earned\n/// since the creation of the pool.\n///\n/// Whenever a reward is paid, the accumulator is increased\n/// by the size of the reward divided by the total weight\n/// of all eligible operators in the pool.\n///\n/// Each operator has an individual accumulator value,\n/// set to equal the global accumulator when the operator joins the pool.\n/// This accumulator reflects the amount of rewards\n/// that have already been accounted for with that operator.\n///\n/// Whenever an operator's weight in the pool changes,\n/// we can update the amount of rewards the operator has earned\n/// by subtracting the operator's accumulator from the global accumulator.\n/// This gives us the amount of rewards one unit of weight has earned\n/// since the last time the operator's rewards have been updated.\n/// Then we multiply that by the operator's previous (pre-change) weight\n/// to determine how much rewards in total the operator has earned,\n/// and add this to the operator's earned rewards.\n/// Finally, we set the operator's accumulator to the global accumulator value.\ncontract Rewards {\n  struct OperatorRewards {\n    // The state of the global accumulator\n    // when the operator's rewards were last updated\n    uint96 accumulated;\n    // The amount of rewards collected by the operator after the latest update.\n    // The amount the operator could withdraw may equal `available`\n    // or it may be greater, if more rewards have been paid in since then.\n    // To evaulate the most recent amount including rewards potentially paid\n    // since the last update, use `availableRewards` function.\n    uint96 available;\n    // If nonzero, the operator is ineligible for rewards\n    // and may only re-enable rewards after the specified timestamp.\n    // XXX: unsigned 32-bit integer unix seconds, will break around 2106\n    uint32 ineligibleUntil;\n    // Locally cached weight of the operator,\n    // used to reduce the cost of setting operators ineligible.\n    uint32 weight;\n  }\n\n  // The global accumulator of how much rewards\n  // a hypothetical operator of weight 1 would have earned\n  // since the creation of the pool.\n  uint96 internal globalRewardAccumulator;\n  // If the amount of reward tokens paid in\n  // does not divide cleanly by pool weight,\n  // the difference is recorded as rounding dust\n  // and added to the next reward.\n  uint96 internal rewardRoundingDust;\n\n  // The amount of rewards that would've been earned by ineligible operators\n  // had they not been ineligible.\n  uint96 public ineligibleEarnedRewards;\n\n  // Ineligibility times are calculated from this offset,\n  // set at contract creation.\n  uint256 internal immutable ineligibleOffsetStart;\n\n  mapping(uint32 => OperatorRewards) internal operatorRewards;\n\n  constructor() {\n    // solhint-disable-next-line not-rely-on-time\n    ineligibleOffsetStart = block.timestamp;\n  }\n\n  /// @notice Return whether the operator is eligible for rewards or not.\n  function isEligibleForRewards(uint32 operator) internal view returns (bool) {\n    return operatorRewards[operator].ineligibleUntil == 0;\n  }\n\n  /// @notice Return the time the operator's reward eligibility can be restored.\n  function rewardsEligibilityRestorableAt(uint32 operator)\n    internal\n    view\n    returns (uint256)\n  {\n    uint32 until = operatorRewards[operator].ineligibleUntil;\n    require(until != 0, \"Operator already eligible\");\n    return (uint256(until) + ineligibleOffsetStart);\n  }\n\n  /// @notice Return whether the operator is able to restore their eligibility\n  ///         for rewards right away.\n  function canRestoreRewardEligibility(uint32 operator)\n    internal\n    view\n    returns (bool)\n  {\n    // solhint-disable-next-line not-rely-on-time\n    return rewardsEligibilityRestorableAt(operator) <= block.timestamp;\n  }\n\n  /// @notice Internal function for updating the global state of rewards.\n  function addRewards(uint96 rewardAmount, uint32 currentPoolWeight) internal {\n    require(currentPoolWeight > 0, \"No recipients in pool\");\n\n    uint96 totalAmount = rewardAmount + rewardRoundingDust;\n    uint96 perWeightReward = totalAmount / currentPoolWeight;\n    uint96 newRoundingDust = totalAmount % currentPoolWeight;\n\n    globalRewardAccumulator += perWeightReward;\n    rewardRoundingDust = newRoundingDust;\n  }\n\n  /// @notice Internal function for updating the operator's reward state.\n  function updateOperatorRewards(uint32 operator, uint32 newWeight) internal {\n    uint96 acc = globalRewardAccumulator;\n    OperatorRewards memory o = operatorRewards[operator];\n    uint96 accruedRewards = (acc - o.accumulated) * uint96(o.weight);\n    if (o.ineligibleUntil == 0) {\n      // If operator is not ineligible, update their earned rewards\n      o.available += accruedRewards;\n    } else {\n      // If ineligible, put the rewards into the ineligible pot\n      ineligibleEarnedRewards += accruedRewards;\n    }\n    // In any case, update their accumulator and weight\n    o.accumulated = acc;\n    o.weight = newWeight;\n    operatorRewards[operator] = o;\n  }\n\n  /// @notice Set the amount of withdrawable tokens to zero\n  /// and return the previous withdrawable amount.\n  /// @dev Does not update the withdrawable amount,\n  /// but should usually be accompanied by an update.\n  function withdrawOperatorRewards(uint32 operator)\n    internal\n    returns (uint96 withdrawable)\n  {\n    OperatorRewards storage o = operatorRewards[operator];\n    withdrawable = o.available;\n    o.available = 0;\n  }\n\n  /// @notice Set the amount of ineligible-earned tokens to zero\n  /// and return the previous amount.\n  function withdrawIneligibleRewards() internal returns (uint96 withdrawable) {\n    withdrawable = ineligibleEarnedRewards;\n    ineligibleEarnedRewards = 0;\n  }\n\n  /// @notice Set the given operators as ineligible for rewards.\n  /// The operators can restore their eligibility at the given time.\n  function setIneligible(uint32[] memory operators, uint256 until) internal {\n    OperatorRewards memory o = OperatorRewards(0, 0, 0, 0);\n    uint96 globalAcc = globalRewardAccumulator;\n    uint96 accrued = 0;\n    // Record ineligibility as seconds after contract creation\n    uint32 _until = uint32(until - ineligibleOffsetStart);\n\n    for (uint256 i = 0; i < operators.length; i++) {\n      uint32 operator = operators[i];\n      OperatorRewards storage r = operatorRewards[operator];\n      o.available = r.available;\n      o.accumulated = r.accumulated;\n      o.ineligibleUntil = r.ineligibleUntil;\n      o.weight = r.weight;\n\n      if (o.ineligibleUntil != 0) {\n        // If operator is already ineligible,\n        // don't earn rewards or shorten its ineligibility\n        if (o.ineligibleUntil < _until) {\n          o.ineligibleUntil = _until;\n        }\n      } else {\n        // The operator becomes ineligible -> earn rewards\n        o.ineligibleUntil = _until;\n        accrued = (globalAcc - o.accumulated) * uint96(o.weight);\n        o.available += accrued;\n      }\n      o.accumulated = globalAcc;\n\n      r.available = o.available;\n      r.accumulated = o.accumulated;\n      r.ineligibleUntil = o.ineligibleUntil;\n      r.weight = o.weight;\n    }\n  }\n\n  /// @notice Restore the given operator's eligibility for rewards.\n  function restoreEligibility(uint32 operator) internal {\n    // solhint-disable-next-line not-rely-on-time\n    require(canRestoreRewardEligibility(operator), \"Operator still ineligible\");\n    uint96 acc = globalRewardAccumulator;\n    OperatorRewards memory o = operatorRewards[operator];\n    uint96 accruedRewards = (acc - o.accumulated) * uint96(o.weight);\n    ineligibleEarnedRewards += accruedRewards;\n    o.accumulated = acc;\n    o.ineligibleUntil = 0;\n    operatorRewards[operator] = o;\n  }\n\n  /// @notice Returns the amount of rewards currently available for withdrawal\n  ///         for the given operator.\n  function availableRewards(uint32 operator) internal view returns (uint96) {\n    uint96 acc = globalRewardAccumulator;\n    OperatorRewards memory o = operatorRewards[operator];\n    if (o.ineligibleUntil == 0) {\n      // If operator is not ineligible, calculate newly accrued rewards and add\n      // them to the available ones, calculated during the last update.\n      uint96 accruedRewards = (acc - o.accumulated) * uint96(o.weight);\n      return o.available + accruedRewards;\n    } else {\n      // If ineligible, return only the rewards calculated during the last\n      // update.\n      return o.available;\n    }\n  }\n}\n"
    },
    "@keep-network/sortition-pools/contracts/Chaosnet.sol": {
      "content": "pragma solidity 0.8.17;\n\n/// @title Chaosnet\n/// @notice This is a beta staker program for stakers willing to go the extra\n/// mile with monitoring, share their logs with the dev team, and allow to more\n/// carefully monitor the bootstrapping network. As the network matures, the\n/// beta program will be ended.\ncontract Chaosnet {\n  /// @notice Indicates if the chaosnet is active. The chaosnet is active\n  /// after the contract deployment and can be ended with a call to\n  /// `deactivateChaosnet()`. Once deactivated chaosnet can not be activated\n  /// again.\n  bool public isChaosnetActive;\n\n  /// @notice Indicates if the given operator is a beta operator for chaosnet.\n  mapping(address => bool) public isBetaOperator;\n\n  /// @notice Address controlling chaosnet status and beta operator addresses.\n  address public chaosnetOwner;\n\n  event BetaOperatorsAdded(address[] operators);\n\n  event ChaosnetOwnerRoleTransferred(\n    address oldChaosnetOwner,\n    address newChaosnetOwner\n  );\n\n  event ChaosnetDeactivated();\n\n  constructor() {\n    _transferChaosnetOwner(msg.sender);\n    isChaosnetActive = true;\n  }\n\n  modifier onlyChaosnetOwner() {\n    require(msg.sender == chaosnetOwner, \"Not the chaosnet owner\");\n    _;\n  }\n\n  modifier onlyOnChaosnet() {\n    require(isChaosnetActive, \"Chaosnet is not active\");\n    _;\n  }\n\n  /// @notice Adds beta operator to chaosnet. Can be called only by the\n  /// chaosnet owner when the chaosnet is active. Once the operator is added\n  /// as a beta operator, it can not be removed.\n  function addBetaOperators(address[] calldata operators)\n    public\n    onlyOnChaosnet\n    onlyChaosnetOwner\n  {\n    for (uint256 i = 0; i < operators.length; i++) {\n      isBetaOperator[operators[i]] = true;\n    }\n\n    emit BetaOperatorsAdded(operators);\n  }\n\n  /// @notice Deactivates the chaosnet. Can be called only by the chaosnet\n  /// owner. Once deactivated chaosnet can not be activated again.\n  function deactivateChaosnet() public onlyOnChaosnet onlyChaosnetOwner {\n    isChaosnetActive = false;\n    emit ChaosnetDeactivated();\n  }\n\n  /// @notice Transfers the chaosnet owner role to another non-zero address.\n  function transferChaosnetOwnerRole(address newChaosnetOwner)\n    public\n    onlyChaosnetOwner\n  {\n    require(\n      newChaosnetOwner != address(0),\n      \"New chaosnet owner must not be zero address\"\n    );\n    _transferChaosnetOwner(newChaosnetOwner);\n  }\n\n  function _transferChaosnetOwner(address newChaosnetOwner) internal {\n    address oldChaosnetOwner = chaosnetOwner;\n    chaosnetOwner = newChaosnetOwner;\n    emit ChaosnetOwnerRoleTransferred(oldChaosnetOwner, newChaosnetOwner);\n  }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@thesis/solidity-contracts/contracts/token/IApproveAndCall.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\n\n/// @notice An interface that should be implemented by tokens supporting\n///         `approveAndCall`/`receiveApproval` pattern.\ninterface IApproveAndCall {\n    /// @notice Executes `receiveApproval` function on spender as specified in\n    ///         `IReceiveApproval` interface. Approves spender to withdraw from\n    ///         the caller multiple times, up to the `amount`. If this\n    ///         function is called again, it overwrites the current allowance\n    ///         with `amount`. Reverts if the approval reverted or if\n    ///         `receiveApproval` call on the spender reverted.\n    function approveAndCall(\n        address spender,\n        uint256 amount,\n        bytes memory extraData\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@keep-network/sortition-pools/contracts/Leaf.sol": {
      "content": "pragma solidity 0.8.17;\n\nimport \"./Constants.sol\";\n\nlibrary Leaf {\n  function make(\n    address _operator,\n    uint256 _creationBlock,\n    uint256 _id\n  ) internal pure returns (uint256) {\n    assert(_creationBlock <= type(uint64).max);\n    assert(_id <= type(uint32).max);\n    // Converting a bytesX type into a larger type\n    // adds zero bytes on the right.\n    uint256 op = uint256(bytes32(bytes20(_operator)));\n    // Bitwise AND the id to erase\n    // all but the 32 least significant bits\n    uint256 uid = _id & Constants.ID_MAX;\n    // Erase all but the 64 least significant bits,\n    // then shift left by 32 bits to make room for the id\n    uint256 cb = (_creationBlock & Constants.BLOCKHEIGHT_MAX) <<\n      Constants.ID_WIDTH;\n    // Bitwise OR them all together to get\n    // [address operator || uint64 creationBlock || uint32 id]\n    return (op | cb | uid);\n  }\n\n  function operator(uint256 leaf) internal pure returns (address) {\n    // Converting a bytesX type into a smaller type\n    // truncates it on the right.\n    return address(bytes20(bytes32(leaf)));\n  }\n\n  /// @notice Return the block number the leaf was created in.\n  function creationBlock(uint256 leaf) internal pure returns (uint256) {\n    return ((leaf >> Constants.ID_WIDTH) & Constants.BLOCKHEIGHT_MAX);\n  }\n\n  function id(uint256 leaf) internal pure returns (uint32) {\n    // Id is stored in the 32 least significant bits.\n    // Bitwise AND ensures that we only get the contents of those bits.\n    return uint32(leaf & Constants.ID_MAX);\n  }\n}\n"
    },
    "@keep-network/sortition-pools/contracts/Constants.sol": {
      "content": "pragma solidity 0.8.17;\n\nlibrary Constants {\n  ////////////////////////////////////////////////////////////////////////////\n  // Parameters for configuration\n\n  // How many bits a position uses per level of the tree;\n  // each branch of the tree contains 2**SLOT_BITS slots.\n  uint256 constant SLOT_BITS = 3;\n  uint256 constant LEVELS = 7;\n  ////////////////////////////////////////////////////////////////////////////\n\n  ////////////////////////////////////////////////////////////////////////////\n  // Derived constants, do not touch\n  uint256 constant SLOT_COUNT = 2**SLOT_BITS;\n  uint256 constant SLOT_WIDTH = 256 / SLOT_COUNT;\n  uint256 constant LAST_SLOT = SLOT_COUNT - 1;\n  uint256 constant SLOT_MAX = (2**SLOT_WIDTH) - 1;\n  uint256 constant POOL_CAPACITY = SLOT_COUNT**LEVELS;\n\n  uint256 constant ID_WIDTH = SLOT_WIDTH;\n  uint256 constant ID_MAX = SLOT_MAX;\n\n  uint256 constant BLOCKHEIGHT_WIDTH = 96 - ID_WIDTH;\n  uint256 constant BLOCKHEIGHT_MAX = (2**BLOCKHEIGHT_WIDTH) - 1;\n\n  uint256 constant SLOT_POINTER_MAX = (2**SLOT_BITS) - 1;\n  uint256 constant LEAF_FLAG = 1 << 255;\n\n  uint256 constant WEIGHT_WIDTH = 256 / SLOT_COUNT;\n  ////////////////////////////////////////////////////////////////////////////\n}\n"
    },
    "@keep-network/sortition-pools/contracts/Branch.sol": {
      "content": "pragma solidity 0.8.17;\n\nimport \"./Constants.sol\";\n\n/// @notice The implicit 8-ary trees of the sortition pool\n/// rely on packing 8 \"slots\" of 32-bit values into each uint256.\n/// The Branch library permits efficient calculations on these slots.\nlibrary Branch {\n  /// @notice Calculate the right shift required\n  /// to make the 32 least significant bits of an uint256\n  /// be the bits of the `position`th slot\n  /// when treating the uint256 as a uint32[8].\n  ///\n  /// @dev Not used for efficiency reasons,\n  /// but left to illustrate the meaning of a common pattern.\n  /// I wish solidity had macros, even C macros.\n  function slotShift(uint256 position) internal pure returns (uint256) {\n    unchecked {\n      return position * Constants.SLOT_WIDTH;\n    }\n  }\n\n  /// @notice Return the `position`th slot of the `node`,\n  /// treating `node` as a uint32[32].\n  function getSlot(uint256 node, uint256 position)\n    internal\n    pure\n    returns (uint256)\n  {\n    unchecked {\n      uint256 shiftBits = position * Constants.SLOT_WIDTH;\n      // Doing a bitwise AND with `SLOT_MAX`\n      // clears all but the 32 least significant bits.\n      // Because of the right shift by `slotShift(position)` bits,\n      // those 32 bits contain the 32 bits in the `position`th slot of `node`.\n      return (node >> shiftBits) & Constants.SLOT_MAX;\n    }\n  }\n\n  /// @notice Return `node` with the `position`th slot set to zero.\n  function clearSlot(uint256 node, uint256 position)\n    internal\n    pure\n    returns (uint256)\n  {\n    unchecked {\n      uint256 shiftBits = position * Constants.SLOT_WIDTH;\n      // Shifting `SLOT_MAX` left by `slotShift(position)` bits\n      // gives us a number where all bits of the `position`th slot are set,\n      // and all other bits are unset.\n      //\n      // Using a bitwise NOT on this number,\n      // we get a uint256 where all bits are set\n      // except for those of the `position`th slot.\n      //\n      // Bitwise ANDing the original `node` with this number\n      // sets the bits of `position`th slot to zero,\n      // leaving all other bits unchanged.\n      return node & ~(Constants.SLOT_MAX << shiftBits);\n    }\n  }\n\n  /// @notice Return `node` with the `position`th slot set to `weight`.\n  ///\n  /// @param weight The weight of of the node.\n  /// Safely truncated to a 32-bit number,\n  /// but this should never be called with an overflowing weight regardless.\n  function setSlot(\n    uint256 node,\n    uint256 position,\n    uint256 weight\n  ) internal pure returns (uint256) {\n    unchecked {\n      uint256 shiftBits = position * Constants.SLOT_WIDTH;\n      // Clear the `position`th slot like in `clearSlot()`.\n      uint256 clearedNode = node & ~(Constants.SLOT_MAX << shiftBits);\n      // Bitwise AND `weight` with `SLOT_MAX`\n      // to clear all but the 32 least significant bits.\n      //\n      // Shift this left by `slotShift(position)` bits\n      // to obtain a uint256 with all bits unset\n      // except in the `position`th slot\n      // which contains the 32-bit value of `weight`.\n      uint256 shiftedWeight = (weight & Constants.SLOT_MAX) << shiftBits;\n      // When we bitwise OR these together,\n      // all other slots except the `position`th one come from the left argument,\n      // and the `position`th gets filled with `weight` from the right argument.\n      return clearedNode | shiftedWeight;\n    }\n  }\n\n  /// @notice Calculate the summed weight of all slots in the `node`.\n  function sumWeight(uint256 node) internal pure returns (uint256 sum) {\n    unchecked {\n      sum = node & Constants.SLOT_MAX;\n      // Iterate through each slot\n      // by shifting `node` right in increments of 32 bits,\n      // and adding the 32 least significant bits to the `sum`.\n      uint256 newNode = node >> Constants.SLOT_WIDTH;\n      while (newNode > 0) {\n        sum += (newNode & Constants.SLOT_MAX);\n        newNode = newNode >> Constants.SLOT_WIDTH;\n      }\n      return sum;\n    }\n  }\n\n  /// @notice Pick a slot in `node` that corresponds to `index`.\n  /// Treats the node like an array of virtual stakers,\n  /// the number of virtual stakers in each slot corresponding to its weight,\n  /// and picks which slot contains the `index`th virtual staker.\n  ///\n  /// @dev Requires that `index` be lower than `sumWeight(node)`.\n  /// However, this is not enforced for performance reasons.\n  /// If `index` exceeds the permitted range,\n  /// `pickWeightedSlot()` returns the rightmost slot\n  /// and an excessively high `newIndex`.\n  ///\n  /// @return slot The slot of `node` containing the `index`th virtual staker.\n  ///\n  /// @return newIndex The index of the `index`th virtual staker of `node`\n  /// within the returned slot.\n  function pickWeightedSlot(uint256 node, uint256 index)\n    internal\n    pure\n    returns (uint256 slot, uint256 newIndex)\n  {\n    unchecked {\n      newIndex = index;\n      uint256 newNode = node;\n      uint256 currentSlotWeight = newNode & Constants.SLOT_MAX;\n      while (newIndex >= currentSlotWeight) {\n        newIndex -= currentSlotWeight;\n        slot++;\n        newNode = newNode >> Constants.SLOT_WIDTH;\n        currentSlotWeight = newNode & Constants.SLOT_MAX;\n      }\n      return (slot, newIndex);\n    }\n  }\n}\n"
    },
    "@keep-network/sortition-pools/contracts/Position.sol": {
      "content": "pragma solidity 0.8.17;\n\nimport \"./Constants.sol\";\n\nlibrary Position {\n  // Return the last 3 bits of a position number,\n  // corresponding to its slot in its parent\n  function slot(uint256 a) internal pure returns (uint256) {\n    return a & Constants.SLOT_POINTER_MAX;\n  }\n\n  // Return the parent of a position number\n  function parent(uint256 a) internal pure returns (uint256) {\n    return a >> Constants.SLOT_BITS;\n  }\n\n  // Return the location of the child of a at the given slot\n  function child(uint256 a, uint256 s) internal pure returns (uint256) {\n    return (a << Constants.SLOT_BITS) | (s & Constants.SLOT_POINTER_MAX); // slot(s)\n  }\n\n  // Return the uint p as a flagged position uint:\n  // the least significant 21 bits contain the position\n  // and the 22nd bit is set as a flag\n  // to distinguish the position 0x000000 from an empty field.\n  function setFlag(uint256 p) internal pure returns (uint256) {\n    return p | Constants.LEAF_FLAG;\n  }\n\n  // Turn a flagged position into an unflagged position\n  // by removing the flag at the 22nd least significant bit.\n  //\n  // We shouldn't _actually_ need this\n  // as all position-manipulating code should ignore non-position bits anyway\n  // but it's cheap to call so might as well do it.\n  function unsetFlag(uint256 p) internal pure returns (uint256) {\n    return p & (~Constants.LEAF_FLAG);\n  }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.3) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/test/upgrades/WalletRegistryV2MissingSlot.sol": {
      "content": "// This is a contract used to test WalletRegistry upgradeability. It is a copy\n// of WalletRegistry contract with some differences marked with `TEST:` comments.\n\n// SPDX-License-Identifier: GPL-3.0-only\n//\n// ▓▓▌ ▓▓ ▐▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▄\n// ▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n//   ▓▓▓▓▓▓    ▓▓▓▓▓▓▓▀    ▐▓▓▓▓▓▓    ▐▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n//   ▓▓▓▓▓▓▄▄▓▓▓▓▓▓▓▀      ▐▓▓▓▓▓▓▄▄▄▄         ▓▓▓▓▓▓▄▄▄▄         ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n//   ▓▓▓▓▓▓▓▓▓▓▓▓▓▀        ▐▓▓▓▓▓▓▓▓▓▓         ▓▓▓▓▓▓▓▓▓▓         ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n//   ▓▓▓▓▓▓▀▀▓▓▓▓▓▓▄       ▐▓▓▓▓▓▓▀▀▀▀         ▓▓▓▓▓▓▀▀▀▀         ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▀\n//   ▓▓▓▓▓▓   ▀▓▓▓▓▓▓▄     ▐▓▓▓▓▓▓     ▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌\n// ▓▓▓▓▓▓▓▓▓▓ █▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▓▓\n// ▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▓▓\n//\n//                           Trust math, not hardware.\n\npragma solidity 0.8.17;\n\nimport \"../../api/IWalletRegistry.sol\";\nimport \"../../api/IWalletOwner.sol\";\nimport \"../../libraries/Wallets.sol\";\nimport {EcdsaAuthorization as Authorization} from \"../../libraries/EcdsaAuthorization.sol\";\nimport {EcdsaDkg as DKG} from \"../../libraries/EcdsaDkg.sol\";\nimport {EcdsaInactivity as Inactivity} from \"../../libraries/EcdsaInactivity.sol\";\nimport {EcdsaDkgValidator as DKGValidator} from \"../../EcdsaDkgValidator.sol\";\n\nimport \"@keep-network/sortition-pools/contracts/SortitionPool.sol\";\nimport \"@keep-network/random-beacon/contracts/api/IRandomBeacon.sol\";\nimport \"@keep-network/random-beacon/contracts/api/IRandomBeaconConsumer.sol\";\nimport \"@keep-network/random-beacon/contracts/Reimbursable.sol\";\nimport \"@keep-network/random-beacon/contracts/ReimbursementPool.sol\";\nimport \"@keep-network/random-beacon/contracts/Governable.sol\";\n\nimport \"@threshold-network/solidity-contracts/contracts/staking/IApplication.sol\";\nimport \"@threshold-network/solidity-contracts/contracts/staking/IStaking.sol\";\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\ncontract WalletRegistryV2MissingSlot is\n    IWalletRegistry,\n    IRandomBeaconConsumer,\n    IApplication,\n    Governable,\n    Reimbursable,\n    Initializable\n{\n    using Authorization for Authorization.Data;\n    using DKG for DKG.Data;\n    using Wallets for Wallets.Data;\n\n    // Libraries data storages\n    Authorization.Data internal authorization;\n    DKG.Data internal dkg;\n    Wallets.Data internal wallets;\n\n    /// @notice Slashing amount for submitting a malicious DKG result. Every\n    ///         DKG result submitted can be challenged for the time of\n    ///         `dkg.resultChallengePeriodLength`. If the DKG result submitted\n    ///         is challenged and proven to be malicious, the operator who\n    ///         submitted the malicious result is slashed for\n    ///         `_maliciousDkgResultSlashingAmount`.\n    uint96 internal _maliciousDkgResultSlashingAmount;\n\n    // TEST: Removed a variable to simulate inconsistency in the storage slots.\n    /// @notice Percentage of the staking contract malicious behavior\n    ///         notification reward which will be transferred to the notifier\n    ///         reporting about a malicious DKG result. Notifiers are rewarded\n    ///         from a notifiers treasury pool. For example, if\n    ///         notification reward is 1000 and the value of the multiplier is\n    ///         5, the notifier will receive: 5% of 1000 = 50 per each\n    ///         operator affected.\n    // uint256 internal _maliciousDkgResultNotificationRewardMultiplier;\n\n    /// @notice Duration of the sortition pool rewards ban imposed on operators\n    ///         who missed their turn for DKG result submission or who failed\n    ///         a heartbeat.\n    uint256 internal _sortitionPoolRewardsBanDuration;\n\n    /// @notice Calculated max gas cost for submitting a DKG result. This will\n    ///         be refunded as part of the DKG approval process. It is in the\n    ///         submitter's interest to not skip his priority turn on the approval,\n    ///         otherwise the refund of the DKG submission will be refunded to\n    ///         another group member that will call the DKG approve function.\n    uint256 internal _dkgResultSubmissionGas;\n\n    /// @notice Gas that is meant to balance the DKG result approval's overall\n    ///         cost. It can be updated by the governance based on the current\n    ///         market conditions.\n    uint256 internal _dkgResultApprovalGasOffset;\n\n    /// @notice Gas that is meant to balance the notification of an operator\n    ///         inactivity. It can be updated by the governance based on the\n    ///         current market conditions.\n    uint256 internal _notifyOperatorInactivityGasOffset;\n\n    /// @notice Gas that is meant to balance the notification of a seed for DKG\n    ///         delivery timeout. It can be updated by the governance based on the\n    ///         current market conditions.\n    uint256 internal _notifySeedTimeoutGasOffset;\n\n    /// @notice Gas that is meant to balance the notification of a DKG protocol\n    ///         execution timeout. It can be updated by the governance based on the\n    ///         current market conditions.\n    /// @dev The value is subtracted for the refundable gas calculation, as the\n    ///      DKG timeout notification transaction recovers some gas when cleaning\n    ///      up the storage.\n    uint256 internal _notifyDkgTimeoutNegativeGasOffset;\n\n    /// @notice Stores current operator inactivity claim nonce for the given\n    ///         wallet signing group. Each claim is made with a unique nonce\n    ///         which protects against claim replay.\n    mapping(bytes32 => uint256) public inactivityClaimNonce; // walletID -> nonce\n\n    // Address that is set as owner of all wallets. Only this address can request\n    // new wallets creation and manage their state.\n    IWalletOwner public walletOwner;\n\n    // External dependencies\n\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    SortitionPool public immutable sortitionPool;\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    IStaking public immutable staking;\n    IRandomBeacon public randomBeacon;\n\n    // Events\n    event DkgStarted(uint256 indexed seed);\n\n    event DkgResultSubmitted(\n        bytes32 indexed resultHash,\n        uint256 indexed seed,\n        DKG.Result result\n    );\n\n    event DkgTimedOut();\n\n    event DkgResultApproved(\n        bytes32 indexed resultHash,\n        address indexed approver\n    );\n\n    event DkgResultChallenged(\n        bytes32 indexed resultHash,\n        address indexed challenger,\n        string reason\n    );\n\n    event DkgStateLocked();\n\n    event DkgSeedTimedOut();\n\n    event WalletCreated(\n        bytes32 indexed walletID,\n        bytes32 indexed dkgResultHash\n    );\n\n    event WalletClosed(bytes32 indexed walletID);\n\n    event DkgMaliciousResultSlashed(\n        bytes32 indexed resultHash,\n        uint256 slashingAmount,\n        address maliciousSubmitter\n    );\n\n    event DkgMaliciousResultSlashingFailed(\n        bytes32 indexed resultHash,\n        uint256 slashingAmount,\n        address maliciousSubmitter\n    );\n\n    event AuthorizationParametersUpdated(\n        uint96 minimumAuthorization,\n        uint64 authorizationDecreaseDelay,\n        uint64 authorizationDecreaseChangePeriod\n    );\n\n    event RewardParametersUpdated(\n        uint256 maliciousDkgResultNotificationRewardMultiplier,\n        uint256 sortitionPoolRewardsBanDuration\n    );\n\n    event SlashingParametersUpdated(uint256 maliciousDkgResultSlashingAmount);\n\n    event DkgParametersUpdated(\n        uint256 seedTimeout,\n        uint256 resultChallengePeriodLength,\n        uint256 resultChallengeExtraGas,\n        uint256 resultSubmissionTimeout,\n        uint256 resultSubmitterPrecedencePeriodLength\n    );\n\n    event GasParametersUpdated(\n        uint256 dkgResultSubmissionGas,\n        uint256 dkgResultApprovalGasOffset,\n        uint256 notifyOperatorInactivityGasOffset,\n        uint256 notifySeedTimeoutGasOffset,\n        uint256 notifyDkgTimeoutNegativeGasOffset\n    );\n\n    event RandomBeaconUpgraded(address randomBeacon);\n\n    event WalletOwnerUpdated(address walletOwner);\n\n    event OperatorRegistered(\n        address indexed stakingProvider,\n        address indexed operator\n    );\n\n    event AuthorizationIncreased(\n        address indexed stakingProvider,\n        address indexed operator,\n        uint96 fromAmount,\n        uint96 toAmount\n    );\n\n    event AuthorizationDecreaseRequested(\n        address indexed stakingProvider,\n        address indexed operator,\n        uint96 fromAmount,\n        uint96 toAmount,\n        uint64 decreasingAt\n    );\n\n    event AuthorizationDecreaseApproved(address indexed stakingProvider);\n\n    event InvoluntaryAuthorizationDecreaseFailed(\n        address indexed stakingProvider,\n        address indexed operator,\n        uint96 fromAmount,\n        uint96 toAmount\n    );\n\n    event OperatorJoinedSortitionPool(\n        address indexed stakingProvider,\n        address indexed operator\n    );\n\n    event OperatorStatusUpdated(\n        address indexed stakingProvider,\n        address indexed operator\n    );\n\n    event InactivityClaimed(\n        bytes32 indexed walletID,\n        uint256 nonce,\n        address notifier\n    );\n\n    modifier onlyStakingContract() {\n        require(\n            msg.sender == address(staking),\n            \"Caller is not the staking contract\"\n        );\n        _;\n    }\n\n    /// @notice Reverts if called not by the Wallet Owner.\n    modifier onlyWalletOwner() {\n        require(\n            msg.sender == address(walletOwner),\n            \"Caller is not the Wallet Owner\"\n        );\n        _;\n    }\n\n    modifier onlyReimbursableAdmin() override {\n        require(governance == msg.sender, \"Caller is not the governance\");\n        _;\n    }\n\n    /// @dev Used to initialize immutable variables only, use `initialize` function\n    ///      for upgradable contract initialization on deployment.\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(SortitionPool _sortitionPool, IStaking _staking) {\n        sortitionPool = _sortitionPool;\n        staking = _staking;\n\n        _disableInitializers();\n    }\n\n    /// @dev Initializes upgradable contract on deployment.\n    function initialize(\n        DKGValidator _ecdsaDkgValidator,\n        IRandomBeacon _randomBeacon,\n        ReimbursementPool _reimbursementPool\n    ) external initializer {\n        // TEST: Removed content of V1's initializer. The `initializer` modifier\n        // protects this function from being called again.\n    }\n\n    // TEST: Added initializer for V2\n    function initializeV2(IRandomBeacon _randomBeacon, string memory _newVar)\n        public\n        reinitializer(2)\n    {\n        randomBeacon = _randomBeacon;\n        _newVar;\n    }\n\n    /// @notice Withdraws application rewards for the given staking provider.\n    ///         Rewards are withdrawn to the staking provider's beneficiary\n    ///         address set in the staking contract. Reverts if staking provider\n    ///         has not registered the operator address.\n    /// @dev Emits `RewardsWithdrawn` event.\n    function withdrawRewards(address stakingProvider) external {\n        address operator = stakingProviderToOperator(stakingProvider);\n        require(operator != address(0), \"Unknown operator\");\n        (, address beneficiary, ) = staking.rolesOf(stakingProvider);\n        uint96 amount = sortitionPool.withdrawRewards(operator, beneficiary);\n        // slither-disable-next-line reentrancy-events\n        emit RewardsWithdrawn(stakingProvider, amount);\n    }\n\n    /// @notice Withdraws rewards belonging to operators marked as ineligible\n    ///         for sortition pool rewards.\n    /// @dev Can be called only by the contract guvnor, which should be the\n    ///      wallet registry governance contract.\n    /// @param recipient Recipient of withdrawn rewards.\n    function withdrawIneligibleRewards(address recipient)\n        external\n        onlyGovernance\n    {\n        sortitionPool.withdrawIneligible(recipient);\n    }\n\n    /// @notice Used by staking provider to set operator address that will\n    ///         operate ECDSA node. The given staking provider can set operator\n    ///         address only one time. The operator address can not be changed\n    ///         and must be unique. Reverts if the operator is already set for\n    ///         the staking provider or if the operator address is already in\n    ///         use. Reverts if there is a pending authorization decrease for\n    ///         the staking provider.\n    function registerOperator(address operator) external {\n        authorization.registerOperator(operator);\n    }\n\n    /// @notice Lets the operator join the sortition pool. The operator address\n    ///         must be known - before calling this function, it has to be\n    ///         appointed by the staking provider by calling `registerOperator`.\n    ///         Also, the operator must have the minimum authorization required\n    ///         by ECDSA. Function reverts if there is no minimum stake\n    ///         authorized or if the operator is not known. If there was an\n    ///         authorization decrease requested, it is activated by starting\n    ///         the authorization decrease delay.\n    function joinSortitionPool() external {\n        authorization.joinSortitionPool(staking, sortitionPool);\n    }\n\n    /// @notice Updates status of the operator in the sortition pool. If there\n    ///         was an authorization decrease requested, it is activated by\n    ///         starting the authorization decrease delay.\n    ///         Function reverts if the operator is not known.\n    function updateOperatorStatus(address operator) external {\n        authorization.updateOperatorStatus(staking, sortitionPool, operator);\n    }\n\n    /// @notice Used by T staking contract to inform the application that the\n    ///         authorized stake amount for the given staking provider increased.\n    ///\n    ///         Reverts if the authorization amount is below the minimum.\n    ///\n    ///         The function is not updating the sortition pool. Sortition pool\n    ///         state needs to be updated by the operator with a call to\n    ///         `joinSortitionPool` or `updateOperatorStatus`.\n    ///\n    /// @dev Can only be called by T staking contract.\n    function authorizationIncreased(\n        address stakingProvider,\n        uint96 fromAmount,\n        uint96 toAmount\n    ) external onlyStakingContract {\n        authorization.authorizationIncreased(\n            stakingProvider,\n            fromAmount,\n            toAmount\n        );\n    }\n\n    /// @notice Used by T staking contract to inform the application that the\n    ///         authorization decrease for the given staking provider has been\n    ///         requested.\n    ///\n    ///         Reverts if the amount after deauthorization would be non-zero\n    ///         and lower than the minimum authorization.\n    ///\n    ///         If the operator is not known (`registerOperator` was not called)\n    ///         it lets to `approveAuthorizationDecrease` immediatelly. If the\n    ///         operator is known (`registerOperator` was called), the operator\n    ///         needs to update state of the sortition pool with a call to\n    ///         `joinSortitionPool` or `updateOperatorStatus`. After the\n    ///         sortition pool state is in sync, authorization decrease delay\n    ///         starts.\n    ///\n    ///         After authorization decrease delay passes, authorization\n    ///         decrease request needs to be approved with a call to\n    ///         `approveAuthorizationDecrease` function.\n    ///\n    ///         If there is a pending authorization decrease request, it is\n    ///         overwritten.\n    ///\n    /// @dev Can only be called by T staking contract.\n    function authorizationDecreaseRequested(\n        address stakingProvider,\n        uint96 fromAmount,\n        uint96 toAmount\n    ) external onlyStakingContract {\n        authorization.authorizationDecreaseRequested(\n            stakingProvider,\n            fromAmount,\n            toAmount\n        );\n    }\n\n    /// @notice Approves the previously registered authorization decrease\n    ///         request. Reverts if authorization decrease delay has not passed\n    ///         yet or if the authorization decrease was not requested for the\n    ///         given staking provider.\n    function approveAuthorizationDecrease(address stakingProvider) external {\n        authorization.approveAuthorizationDecrease(staking, stakingProvider);\n    }\n\n    /// @notice Used by T staking contract to inform the application the\n    ///         authorization has been decreased for the given staking provider\n    ///         involuntarily, as a result of slashing.\n    ///\n    ///         If the operator is not known (`registerOperator` was not called)\n    ///         the function does nothing. The operator was never in a sortition\n    ///         pool so there is nothing to update.\n    ///\n    ///         If the operator is known, sortition pool is unlocked, and the\n    ///         operator is in the sortition pool, the sortition pool state is\n    ///         updated. If the sortition pool is locked, update needs to be\n    ///         postponed. Every other staker is incentivized to call\n    ///         `updateOperatorStatus` for the problematic operator to increase\n    ///         their own rewards in the pool.\n    function involuntaryAuthorizationDecrease(\n        address stakingProvider,\n        uint96 fromAmount,\n        uint96 toAmount\n    ) external onlyStakingContract {\n        authorization.involuntaryAuthorizationDecrease(\n            staking,\n            sortitionPool,\n            stakingProvider,\n            fromAmount,\n            toAmount\n        );\n    }\n\n    /// @notice Updates address of the Random Beacon.\n    /// @dev Can be called only by the contract guvnor, which should be the\n    ///      wallet registry governance contract. The caller is responsible for\n    ///      validating parameters.\n    /// @param _randomBeacon Random Beacon address.\n    function upgradeRandomBeacon(IRandomBeacon _randomBeacon)\n        external\n        onlyGovernance\n    {\n        randomBeacon = _randomBeacon;\n        emit RandomBeaconUpgraded(address(_randomBeacon));\n    }\n\n    /// @notice Updates the wallet owner.\n    /// @dev Can be called only by the contract guvnor, which should be the\n    ///      wallet registry governance contract. The caller is responsible for\n    ///      validating parameters. The wallet owner has to implement `IWalletOwner`\n    ///      interface.\n    /// @param _walletOwner New wallet owner address.\n    function updateWalletOwner(IWalletOwner _walletOwner)\n        external\n        onlyGovernance\n    {\n        walletOwner = _walletOwner;\n        emit WalletOwnerUpdated(address(_walletOwner));\n    }\n\n    /// @notice Updates the values of authorization parameters.\n    /// @dev Can be called only by the contract guvnor, which should be the\n    ///      wallet registry governance contract. The caller is responsible for\n    ///      validating parameters.\n    /// @param _minimumAuthorization New minimum authorization amount.\n    /// @param _authorizationDecreaseDelay New authorization decrease delay in\n    ///        seconds.\n    /// @param _authorizationDecreaseChangePeriod New authorization decrease\n    ///        change period in seconds.\n    function updateAuthorizationParameters(\n        uint96 _minimumAuthorization,\n        uint64 _authorizationDecreaseDelay,\n        uint64 _authorizationDecreaseChangePeriod\n    ) external onlyGovernance {\n        authorization.setMinimumAuthorization(_minimumAuthorization);\n        authorization.setAuthorizationDecreaseDelay(\n            _authorizationDecreaseDelay\n        );\n        authorization.setAuthorizationDecreaseChangePeriod(\n            _authorizationDecreaseChangePeriod\n        );\n\n        emit AuthorizationParametersUpdated(\n            _minimumAuthorization,\n            _authorizationDecreaseDelay,\n            _authorizationDecreaseChangePeriod\n        );\n    }\n\n    /// @notice Updates the values of DKG parameters.\n    /// @dev Can be called only by the contract guvnor, which should be the\n    ///      wallet registry governance contract. The caller is responsible for\n    ///      validating parameters.\n    /// @param _seedTimeout New seed timeout.\n    /// @param _resultChallengePeriodLength New DKG result challenge period\n    ///        length.\n    /// @param _resultChallengeExtraGas New extra gas value required to be left\n    ///        at the end of the DKG result challenge transaction.\n    /// @param _resultSubmissionTimeout New DKG result submission timeout.\n    /// @param _submitterPrecedencePeriodLength New submitter precedence period\n    ///        length.\n    function updateDkgParameters(\n        uint256 _seedTimeout,\n        uint256 _resultChallengePeriodLength,\n        uint256 _resultChallengeExtraGas,\n        uint256 _resultSubmissionTimeout,\n        uint256 _submitterPrecedencePeriodLength\n    ) external onlyGovernance {\n        dkg.setSeedTimeout(_seedTimeout);\n        dkg.setResultChallengePeriodLength(_resultChallengePeriodLength);\n        dkg.setResultChallengeExtraGas(_resultChallengeExtraGas);\n        dkg.setResultSubmissionTimeout(_resultSubmissionTimeout);\n        dkg.setSubmitterPrecedencePeriodLength(\n            _submitterPrecedencePeriodLength\n        );\n\n        // slither-disable-next-line reentrancy-events\n        emit DkgParametersUpdated(\n            _seedTimeout,\n            _resultChallengePeriodLength,\n            _resultChallengeExtraGas,\n            _resultSubmissionTimeout,\n            _submitterPrecedencePeriodLength\n        );\n    }\n\n    /// @notice Updates the values of reward parameters.\n    /// @dev Can be called only by the contract guvnor, which should be the\n    ///      wallet registry governance contract. The caller is responsible for\n    ///      validating parameters.\n    /// @param maliciousDkgResultNotificationRewardMultiplier New value of the\n    ///        DKG malicious result notification reward multiplier.\n    /// @param sortitionPoolRewardsBanDuration New sortition pool rewards\n    ///        ban duration in seconds.\n    function updateRewardParameters(\n        uint256 maliciousDkgResultNotificationRewardMultiplier,\n        uint256 sortitionPoolRewardsBanDuration\n    ) external onlyGovernance {\n        // TEST: Removed a variable to simulate inconsistency in the storage slots.\n        // _maliciousDkgResultNotificationRewardMultiplier = maliciousDkgResultNotificationRewardMultiplier;\n        _sortitionPoolRewardsBanDuration = sortitionPoolRewardsBanDuration;\n        emit RewardParametersUpdated(\n            maliciousDkgResultNotificationRewardMultiplier,\n            sortitionPoolRewardsBanDuration\n        );\n    }\n\n    /// @notice Updates the values of slashing parameters.\n    /// @dev Can be called only by the contract guvnor, which should be the\n    ///      wallet registry governance contract. The caller is responsible for\n    ///      validating parameters.\n    /// @param maliciousDkgResultSlashingAmount New malicious DKG result\n    ///        slashing amount.\n    function updateSlashingParameters(uint96 maliciousDkgResultSlashingAmount)\n        external\n        onlyGovernance\n    {\n        _maliciousDkgResultSlashingAmount = maliciousDkgResultSlashingAmount;\n        emit SlashingParametersUpdated(maliciousDkgResultSlashingAmount);\n    }\n\n    /// @notice Updates the values of gas-related parameters.\n    /// @dev Can be called only by the contract guvnor, which should be the\n    ///      wallet registry governance contract. The caller is responsible for\n    ///      validating parameters.\n    /// @param dkgResultSubmissionGas New DKG result submission gas.\n    /// @param dkgResultApprovalGasOffset New DKG result approval gas offset.\n    /// @param notifyOperatorInactivityGasOffset New operator inactivity\n    ///        notification gas offset.\n    /// @param notifySeedTimeoutGasOffset New seed for DKG delivery timeout\n    ///        notification gas offset.\n    /// @param notifyDkgTimeoutNegativeGasOffset New DKG timeout notification gas\n    ///        offset.\n    function updateGasParameters(\n        uint256 dkgResultSubmissionGas,\n        uint256 dkgResultApprovalGasOffset,\n        uint256 notifyOperatorInactivityGasOffset,\n        uint256 notifySeedTimeoutGasOffset,\n        uint256 notifyDkgTimeoutNegativeGasOffset\n    ) external onlyGovernance {\n        _dkgResultSubmissionGas = dkgResultSubmissionGas;\n        _dkgResultApprovalGasOffset = dkgResultApprovalGasOffset;\n        _notifyOperatorInactivityGasOffset = notifyOperatorInactivityGasOffset;\n        _notifySeedTimeoutGasOffset = notifySeedTimeoutGasOffset;\n        _notifyDkgTimeoutNegativeGasOffset = notifyDkgTimeoutNegativeGasOffset;\n\n        emit GasParametersUpdated(\n            dkgResultSubmissionGas,\n            dkgResultApprovalGasOffset,\n            notifyOperatorInactivityGasOffset,\n            _notifySeedTimeoutGasOffset,\n            _notifyDkgTimeoutNegativeGasOffset\n        );\n    }\n\n    /// @notice Requests a new wallet creation.\n    /// @dev Can be called only by the owner of wallets.\n    ///      It locks the DKG and request a new relay entry. It expects\n    ///      that the DKG process will be started once a new relay entry\n    ///      gets generated.\n    function requestNewWallet() external onlyWalletOwner {\n        dkg.lockState();\n\n        randomBeacon.requestRelayEntry(this);\n    }\n\n    /// @notice Closes an existing wallet. Reverts if wallet with the given ID\n    ///         does not exist or if it has already been closed.\n    /// @param walletID ID of the wallet.\n    /// @dev Only a Wallet Owner can call this function.\n    function closeWallet(bytes32 walletID) external onlyWalletOwner {\n        wallets.deleteWallet(walletID);\n        emit WalletClosed(walletID);\n    }\n\n    /// @notice A callback that is executed once a new relay entry gets\n    ///         generated. It starts the DKG process.\n    /// @dev Can be called only by the random beacon contract.\n    /// @param relayEntry Relay entry.\n    function __beaconCallback(uint256 relayEntry, uint256) external {\n        require(\n            msg.sender == address(randomBeacon),\n            \"Caller is not the Random Beacon\"\n        );\n\n        dkg.start(relayEntry);\n    }\n\n    /// @notice Submits result of DKG protocol.\n    ///         The DKG result consists of result submitting member index,\n    ///         calculated group public key, bytes array of misbehaved members,\n    ///         concatenation of signatures from group members, indices of members\n    ///         corresponding to each signature and the list of group members.\n    ///         The result is registered optimistically and waits for an approval.\n    ///         The result can be challenged when it is believed to be incorrect.\n    ///         The challenge verifies the registered result i.a. it checks if members\n    ///         list corresponds to the expected set of members determined\n    ///         by the sortition pool.\n    /// @dev The message to be signed by each member is keccak256 hash of the\n    ///      calculated group public key, misbehaved members indices and DKG\n    ///      start block. The calculated hash should be prefixed with prefixed with\n    ///      `\\x19Ethereum signed message:\\n` before signing, so the message to\n    ///      sign is:\n    ///      `\\x19Ethereum signed message:\\n${keccak256(groupPubKey,misbehavedIndices,startBlock)}`\n    /// @param dkgResult DKG result.\n    function submitDkgResult(DKG.Result calldata dkgResult) external {\n        wallets.validatePublicKey(dkgResult.groupPubKey);\n        dkg.submitResult(dkgResult);\n    }\n\n    /// @notice Approves DKG result. Can be called when the challenge period for\n    ///         the submitted result is finished. Considers the submitted result\n    ///         as valid, bans misbehaved group members from the sortition pool\n    ///         rewards, and completes the group creation by activating the\n    ///         candidate group. For the first `resultSubmissionTimeout` blocks\n    ///         after the end of the challenge period can be called only by the\n    ///         DKG result submitter. After that time, can be called by anyone.\n    ///         A new wallet based on the DKG result details.\n    /// @param dkgResult Result to approve. Must match the submitted result\n    ///        stored during `submitDkgResult`.\n    function approveDkgResult(DKG.Result calldata dkgResult) external {\n        uint256 gasStart = gasleft();\n        uint32[] memory misbehavedMembers = dkg.approveResult(dkgResult);\n\n        (bytes32 walletID, bytes32 publicKeyX, bytes32 publicKeyY) = wallets\n            .addWallet(dkgResult.membersHash, dkgResult.groupPubKey);\n\n        emit WalletCreated(walletID, keccak256(abi.encode(dkgResult)));\n\n        if (misbehavedMembers.length > 0) {\n            sortitionPool.setRewardIneligibility(\n                misbehavedMembers,\n                // solhint-disable-next-line not-rely-on-time\n                block.timestamp + _sortitionPoolRewardsBanDuration\n            );\n        }\n\n        walletOwner.__ecdsaWalletCreatedCallback(\n            walletID,\n            publicKeyX,\n            publicKeyY\n        );\n\n        dkg.complete();\n\n        // Refund msg.sender's ETH for DKG result submission and result approval\n        reimbursementPool.refund(\n            _dkgResultSubmissionGas +\n                (gasStart - gasleft()) +\n                _dkgResultApprovalGasOffset,\n            msg.sender\n        );\n    }\n\n    /// @notice Notifies about seed for DKG delivery timeout. It is expected\n    ///         that a seed is delivered by the Random Beacon as a relay entry in a\n    ///         callback function.\n    function notifySeedTimeout() external {\n        uint256 gasStart = gasleft();\n\n        dkg.notifySeedTimeout();\n\n        reimbursementPool.refund(\n            (gasStart - gasleft()) + _notifySeedTimeoutGasOffset,\n            msg.sender\n        );\n    }\n\n    /// @notice Notifies about DKG timeout.\n    function notifyDkgTimeout() external {\n        uint256 gasStart = gasleft();\n\n        dkg.notifyDkgTimeout();\n\n        // Note that the offset is subtracted as it is expected that the cleanup\n        // performed on DKG timeout notification removes data from the storage\n        // which is recovering gas for the transaction.\n        reimbursementPool.refund(\n            (gasStart - gasleft()) - _notifyDkgTimeoutNegativeGasOffset,\n            msg.sender\n        );\n    }\n\n    /// @notice Challenges DKG result. If the submitted result is proved to be\n    ///         invalid it reverts the DKG back to the result submission phase.\n    /// @param dkgResult Result to challenge. Must match the submitted result\n    ///        stored during `submitDkgResult`.\n    function challengeDkgResult(DKG.Result calldata dkgResult) external {\n        (\n            bytes32 maliciousDkgResultHash,\n            uint32 maliciousDkgResultSubmitterId\n        ) = dkg.challengeResult(dkgResult);\n\n        address maliciousDkgResultSubmitterAddress = sortitionPool\n            .getIDOperator(maliciousDkgResultSubmitterId);\n\n        address[] memory operatorWrapper = new address[](1);\n        operatorWrapper[0] = operatorToStakingProvider(\n            maliciousDkgResultSubmitterAddress\n        );\n\n        try\n            staking.seize(\n                _maliciousDkgResultSlashingAmount,\n                0, // TEST: Removed a variable to simulate inconsistency in the storage slots.\n                msg.sender,\n                operatorWrapper\n            )\n        {\n            // slither-disable-next-line reentrancy-events\n            emit DkgMaliciousResultSlashed(\n                maliciousDkgResultHash,\n                _maliciousDkgResultSlashingAmount,\n                maliciousDkgResultSubmitterAddress\n            );\n        } catch {\n            // Should never happen but we want to ensure a non-critical path\n            // failure from an external contract does not stop the challenge\n            // to complete.\n            emit DkgMaliciousResultSlashingFailed(\n                maliciousDkgResultHash,\n                _maliciousDkgResultSlashingAmount,\n                maliciousDkgResultSubmitterAddress\n            );\n        }\n\n        // Due to EIP150, 1/64 of the gas is not forwarded to the call, and\n        // will be kept to execute the remaining operations in the function\n        // after the call inside the try-catch.\n        //\n        // To ensure there is no way for the caller to manipulate gas limit in\n        // such a way that the call inside try-catch fails with out-of-gas and\n        // the rest of the function is executed with the remaining 1/64 of gas,\n        // we require an extra gas amount to be left at the end of the call to\n        // `challengeDkgResult`.\n        dkg.requireChallengeExtraGas();\n    }\n\n    /// @notice Notifies about operators who are inactive. Using this function,\n    ///         a majority of the wallet signing group can decide about\n    ///         punishing specific group members who constantly fail doing their\n    ///         job. If the provided claim is proved to be valid and signed by\n    ///         sufficient number of group members, operators of members deemed\n    ///         as inactive are banned from sortition pool rewards for the\n    ///         duration specified by `sortitionPoolRewardsBanDuration` parameter.\n    ///         The function allows to signal about single operators being\n    ///         inactive as well as to signal wallet-wide heartbeat failures\n    ///         that are propagated to the wallet owner who should begin the\n    ///         procedure of moving responsibilities to another wallet given\n    ///         that the wallet who failed the heartbeat may soon be not able to\n    ///         function and provide new signatures.\n    ///         The sender of the claim must be one of the claim signers. This\n    ///         function can be called only for registered wallets\n    /// @param claim Operator inactivity claim.\n    /// @param nonce Current inactivity claim nonce for the given wallet signing\n    ///              group. Must be the same as the stored one.\n    /// @param groupMembers Identifiers of the wallet signing group members.\n    function notifyOperatorInactivity(\n        Inactivity.Claim calldata claim,\n        uint256 nonce,\n        uint32[] calldata groupMembers\n    ) external {\n        uint256 gasStart = gasleft();\n\n        bytes32 walletID = claim.walletID;\n\n        require(nonce == inactivityClaimNonce[walletID], \"Invalid nonce\");\n\n        (bytes32 pubKeyX, bytes32 pubKeyY) = wallets\n            .getWalletPublicKeyCoordinates(walletID);\n        bytes32 memberIdsHash = wallets.getWalletMembersIdsHash(walletID);\n\n        require(\n            memberIdsHash == keccak256(abi.encode(groupMembers)),\n            \"Invalid group members\"\n        );\n\n        uint32[] memory ineligibleOperators = Inactivity.verifyClaim(\n            sortitionPool,\n            claim,\n            bytes.concat(pubKeyX, pubKeyY),\n            nonce,\n            groupMembers\n        );\n\n        inactivityClaimNonce[walletID]++;\n\n        emit InactivityClaimed(walletID, nonce, msg.sender);\n\n        sortitionPool.setRewardIneligibility(\n            ineligibleOperators,\n            // solhint-disable-next-line not-rely-on-time\n            block.timestamp + _sortitionPoolRewardsBanDuration\n        );\n\n        if (claim.heartbeatFailed) {\n            walletOwner.__ecdsaWalletHeartbeatFailedCallback(\n                walletID,\n                pubKeyX,\n                pubKeyY\n            );\n        }\n\n        reimbursementPool.refund(\n            (gasStart - gasleft()) + _notifyOperatorInactivityGasOffset,\n            msg.sender\n        );\n    }\n\n    /// @notice Allows the wallet owner to add all signing group members of the\n    ///         wallet with the given ID to the slashing queue of the staking .\n    ///         contract. The notifier will receive reward per each group member\n    ///         from the staking contract notifiers treasury. The reward is\n    ///         scaled by the `rewardMultiplier` provided as a parameter.\n    /// @param amount Amount of tokens to seize from each signing group member.\n    /// @param rewardMultiplier Fraction of the staking contract notifiers\n    ///        reward the notifier should receive; should be between [0, 100].\n    /// @param notifier Address of the misbehavior notifier.\n    /// @param walletID ID of the wallet.\n    /// @param walletMembersIDs Identifiers of the wallet signing group members.\n    /// @dev Requirements:\n    ///      - The expression `keccak256(abi.encode(walletMembersIDs))` must\n    ///        be exactly the same as the hash stored under `membersIdsHash`\n    ///        for the given `walletID`. Those IDs are not directly stored\n    ///        in the contract for gas efficiency purposes but they can be\n    ///        read from appropriate `DkgResultSubmitted` and `DkgResultApproved`\n    ///        events.\n    ///      - `rewardMultiplier` must be between [0, 100].\n    ///      - This function does revert if staking contract call reverts.\n    ///        The calling code needs to handle the potential revert.\n    function seize(\n        uint96 amount,\n        uint256 rewardMultiplier,\n        address notifier,\n        bytes32 walletID,\n        uint32[] calldata walletMembersIDs\n    ) external onlyWalletOwner {\n        bytes32 memberIdsHash = wallets.getWalletMembersIdsHash(walletID);\n        require(\n            memberIdsHash == keccak256(abi.encode(walletMembersIDs)),\n            \"Invalid wallet members identifiers\"\n        );\n\n        address[] memory groupMembersAddresses = sortitionPool.getIDOperators(\n            walletMembersIDs\n        );\n        address[] memory stakingProvidersAddresses = new address[](\n            walletMembersIDs.length\n        );\n        for (uint256 i = 0; i < groupMembersAddresses.length; i++) {\n            stakingProvidersAddresses[i] = operatorToStakingProvider(\n                groupMembersAddresses[i]\n            );\n        }\n\n        staking.seize(\n            amount,\n            rewardMultiplier,\n            notifier,\n            stakingProvidersAddresses\n        );\n    }\n\n    /// @notice Checks if DKG result is valid for the current DKG.\n    /// @param result DKG result.\n    /// @return True if the result is valid. If the result is invalid it returns\n    ///         false and an error message.\n    function isDkgResultValid(DKG.Result calldata result)\n        external\n        view\n        returns (bool, string memory)\n    {\n        return dkg.isResultValid(result);\n    }\n\n    /// @notice Check current wallet creation state.\n    function getWalletCreationState() external view returns (DKG.State) {\n        return dkg.currentState();\n    }\n\n    /// @notice Checks whether the given operator is a member of the given\n    ///         wallet signing group.\n    /// @param walletID ID of the wallet.\n    /// @param walletMembersIDs Identifiers of the wallet signing group members.\n    /// @param operator Address of the checked operator.\n    /// @param walletMemberIndex Position of the operator in the wallet signing\n    ///        group members list.\n    /// @return True - if the operator is a member of the given wallet signing\n    ///         group. False - otherwise.\n    /// @dev Requirements:\n    ///      - The `operator` parameter must be an actual sortition pool operator.\n    ///      - The expression `keccak256(abi.encode(walletMembersIDs))` must\n    ///        be exactly the same as the hash stored under `membersIdsHash`\n    ///        for the given `walletID`. Those IDs are not directly stored\n    ///        in the contract for gas efficiency purposes but they can be\n    ///        read from appropriate `DkgResultSubmitted` and `DkgResultApproved`\n    ///        events.\n    ///      - The `walletMemberIndex` must be in range [1, walletMembersIDs.length]\n    function isWalletMember(\n        bytes32 walletID,\n        uint32[] calldata walletMembersIDs,\n        address operator,\n        uint256 walletMemberIndex\n    ) external view returns (bool) {\n        uint32 operatorID = sortitionPool.getOperatorID(operator);\n\n        require(operatorID != 0, \"Not a sortition pool operator\");\n\n        bytes32 memberIdsHash = wallets.getWalletMembersIdsHash(walletID);\n\n        require(\n            memberIdsHash == keccak256(abi.encode(walletMembersIDs)),\n            \"Invalid wallet members identifiers\"\n        );\n\n        require(\n            1 <= walletMemberIndex &&\n                walletMemberIndex <= walletMembersIDs.length,\n            \"Wallet member index is out of range\"\n        );\n\n        return walletMembersIDs[walletMemberIndex - 1] == operatorID;\n    }\n\n    /// @notice Checks if awaiting seed timed out.\n    /// @return True if awaiting seed timed out, false otherwise.\n    function hasSeedTimedOut() external view returns (bool) {\n        return dkg.hasSeedTimedOut();\n    }\n\n    /// @notice Checks if DKG timed out. The DKG timeout period includes time required\n    ///         for off-chain protocol execution and time for the result publication\n    ///         for all group members. After this time result cannot be submitted\n    ///         and DKG can be notified about the timeout.\n    /// @return True if DKG timed out, false otherwise.\n    function hasDkgTimedOut() external view returns (bool) {\n        return dkg.hasDkgTimedOut();\n    }\n\n    function getWallet(bytes32 walletID)\n        external\n        view\n        returns (Wallets.Wallet memory)\n    {\n        return wallets.registry[walletID];\n    }\n\n    /// @notice Gets public key of a wallet with a given wallet ID.\n    ///         The public key is returned in an uncompressed format as a 64-byte\n    ///         concatenation of X and Y coordinates.\n    /// @param walletID ID of the wallet.\n    /// @return Uncompressed public key of the wallet.\n    function getWalletPublicKey(bytes32 walletID)\n        external\n        view\n        returns (bytes memory)\n    {\n        return wallets.getWalletPublicKey(walletID);\n    }\n\n    /// @notice Checks if a wallet with the given ID is registered.\n    /// @param walletID Wallet's ID.\n    /// @return True if wallet is registered, false otherwise.\n    function isWalletRegistered(bytes32 walletID) external view returns (bool) {\n        return wallets.isWalletRegistered(walletID);\n    }\n\n    /// @notice The minimum authorization amount required so that operator can\n    ///         participate in ECDSA Wallet operations.\n    function minimumAuthorization() external view returns (uint96) {\n        return authorization.parameters.minimumAuthorization;\n    }\n\n    /// @notice Returns the current value of the staking provider's eligible\n    ///         stake. Eligible stake is defined as the currently authorized\n    ///         stake minus the pending authorization decrease. Eligible stake\n    ///         is what is used for operator's weight in the sortition pool.\n    ///         If the authorized stake minus the pending authorization decrease\n    ///         is below the minimum authorization, eligible stake is 0.\n    function eligibleStake(address stakingProvider)\n        external\n        view\n        returns (uint96)\n    {\n        return authorization.eligibleStake(staking, stakingProvider);\n    }\n\n    /// @notice Returns the amount of rewards available for withdrawal for the\n    ///         given staking provider. Reverts if staking provider has not\n    ///         registered the operator address.\n    function availableRewards(address stakingProvider)\n        external\n        view\n        returns (uint96)\n    {\n        address operator = stakingProviderToOperator(stakingProvider);\n        require(operator != address(0), \"Unknown operator\");\n        return sortitionPool.getAvailableRewards(operator);\n    }\n\n    /// @notice Returns the amount of stake that is pending authorization\n    ///         decrease for the given staking provider. If no authorization\n    ///         decrease has been requested, returns zero.\n    function pendingAuthorizationDecrease(address stakingProvider)\n        external\n        view\n        returns (uint96)\n    {\n        return authorization.pendingAuthorizationDecrease(stakingProvider);\n    }\n\n    /// @notice Returns the remaining time in seconds that needs to pass before\n    ///         the requested authorization decrease can be approved.\n    ///         If the sortition pool state was not updated yet by the operator\n    ///         after requesting the authorization decrease, returns\n    ///         `type(uint64).max`.\n    function remainingAuthorizationDecreaseDelay(address stakingProvider)\n        external\n        view\n        returns (uint64)\n    {\n        return\n            authorization.remainingAuthorizationDecreaseDelay(stakingProvider);\n    }\n\n    /// @notice Returns operator registered for the given staking provider.\n    function stakingProviderToOperator(address stakingProvider)\n        public\n        view\n        returns (address)\n    {\n        return authorization.stakingProviderToOperator[stakingProvider];\n    }\n\n    /// @notice Returns staking provider of the given operator.\n    function operatorToStakingProvider(address operator)\n        public\n        view\n        returns (address)\n    {\n        return authorization.operatorToStakingProvider[operator];\n    }\n\n    /// @notice Checks if the operator's authorized stake is in sync with\n    ///         operator's weight in the sortition pool.\n    ///         If the operator is not in the sortition pool and their\n    ///         authorized stake is non-zero, function returns false.\n    function isOperatorUpToDate(address operator) external view returns (bool) {\n        return\n            authorization.isOperatorUpToDate(staking, sortitionPool, operator);\n    }\n\n    /// @notice Returns true if the given operator is in the sortition pool.\n    ///         Otherwise, returns false.\n    function isOperatorInPool(address operator) external view returns (bool) {\n        return sortitionPool.isOperatorInPool(operator);\n    }\n\n    /// @notice Selects a new group of operators. Can only be called when DKG\n    ///         is in progress and the pool is locked.\n    ///         At least one operator has to be registered in the pool,\n    ///         otherwise the function fails reverting the transaction.\n    /// @return IDs of selected group members.\n    function selectGroup() external view returns (uint32[] memory) {\n        return sortitionPool.selectGroup(DKG.groupSize, bytes32(dkg.seed));\n    }\n\n    /// @notice Retrieves dkg parameters that were set in DKG library.\n    function dkgParameters() external view returns (DKG.Parameters memory) {\n        return dkg.parameters;\n    }\n\n    /// @notice Returns authorization-related parameters.\n    /// @dev The minimum authorization is also returned by `minimumAuthorization()`\n    ///      function, as a requirement of `IApplication` interface.\n    /// @return minimumAuthorization The minimum authorization amount required\n    ///         so that operator can participate in the random beacon. This\n    ///         amount is required to execute slashing for providing a malicious\n    ///         DKG result or when a relay entry times out.\n    /// @return authorizationDecreaseDelay Delay in seconds that needs to pass\n    ///         between the time authorization decrease is requested and the\n    ///         time that request gets approved. Protects against free-riders\n    ///         earning rewards and not being active in the network.\n    /// @return authorizationDecreaseChangePeriod Authorization decrease change\n    ///         period in seconds. It is the time, before authorization decrease\n    ///         delay end, during which the pending authorization decrease\n    ///         request can be overwritten.\n    ///         If set to 0, pending authorization decrease request can not be\n    ///         overwritten until the entire `authorizationDecreaseDelay` ends.\n    ///         If set to value equal `authorizationDecreaseDelay`, request can\n    ///         always be overwritten.\n    function authorizationParameters()\n        external\n        view\n        returns (\n            uint96 minimumAuthorization,\n            uint64 authorizationDecreaseDelay,\n            uint64 authorizationDecreaseChangePeriod\n        )\n    {\n        return (\n            authorization.parameters.minimumAuthorization,\n            authorization.parameters.authorizationDecreaseDelay,\n            authorization.parameters.authorizationDecreaseChangePeriod\n        );\n    }\n\n    /// @notice Retrieves reward-related parameters.\n    /// @return maliciousDkgResultNotificationRewardMultiplier Percentage of the\n    ///         staking contract malicious behavior notification reward which\n    ///         will be transferred to the notifier reporting about a malicious\n    ///         DKG result. Notifiers are rewarded from a notifiers treasury\n    ///         pool. For example, if notification reward is 1000 and the value\n    ///         of the multiplier is 5, the notifier will receive:\n    ///         5% of 1000 = 50 per each operator affected.\n    /// @return sortitionPoolRewardsBanDuration Duration of the sortition pool\n    ///         rewards ban imposed on operators who missed their turn for DKG\n    ///         result submission or who failed a heartbeat.\n    function rewardParameters()\n        external\n        view\n        returns (\n            uint256 maliciousDkgResultNotificationRewardMultiplier,\n            uint256 sortitionPoolRewardsBanDuration\n        )\n    {\n        return (0, _sortitionPoolRewardsBanDuration); // TEST: Removed a variable to simulate inconsistency in the storage slots.\n    }\n\n    /// @notice Retrieves slashing-related parameters.\n    /// @return maliciousDkgResultSlashingAmount Slashing amount for submitting\n    ///         a malicious DKG result. Every DKG result submitted can be\n    ///         challenged for the time of `dkg.resultChallengePeriodLength`.\n    ///         If the DKG result submitted is challenged and proven to be\n    ///         malicious, the operator who submitted the malicious result is\n    ///         slashed for `_maliciousDkgResultSlashingAmount`.\n    function slashingParameters()\n        external\n        view\n        returns (uint96 maliciousDkgResultSlashingAmount)\n    {\n        return _maliciousDkgResultSlashingAmount;\n    }\n\n    /// @notice Retrieves gas-related parameters.\n    /// @return dkgResultSubmissionGas Calculated max gas cost for submitting\n    ///         a DKG result. This will be refunded as part of the DKG approval\n    ///         process. It is in the submitter's interest to not skip his\n    ///         priority turn on the approval, otherwise the refund of the DKG\n    ///         submission will be refunded to another group member that will\n    ///         call the DKG approve function.\n    /// @return dkgResultApprovalGasOffset Gas that is meant to balance the DKG\n    ///         result approval's overall cost. It can be updated by the\n    ///         governance based on the current market conditions.\n    /// @return notifyOperatorInactivityGasOffset Gas that is meant to balance\n    ///         the notification of an operator inactivity. It can be updated by\n    ///         the governance based on the current market conditions.\n    /// @return notifySeedTimeoutGasOffset Gas that is meant to balance the\n    ///         notification of a seed for DKG delivery timeout. It can be updated\n    ///         by the governance based on the current market conditions.\n    /// @return notifyDkgTimeoutNegativeGasOffset Gas that is meant to balance\n    ///         the notification of a DKG protocol execution timeout. It can be\n    ///         updated by the governance based on the current market conditions.\n    function gasParameters()\n        external\n        view\n        returns (\n            uint256 dkgResultSubmissionGas,\n            uint256 dkgResultApprovalGasOffset,\n            uint256 notifyOperatorInactivityGasOffset,\n            uint256 notifySeedTimeoutGasOffset,\n            uint256 notifyDkgTimeoutNegativeGasOffset\n        )\n    {\n        return (\n            _dkgResultSubmissionGas,\n            _dkgResultApprovalGasOffset,\n            _notifyOperatorInactivityGasOffset,\n            _notifySeedTimeoutGasOffset,\n            _notifyDkgTimeoutNegativeGasOffset\n        );\n    }\n}\n"
    },
    "contracts/test/upgrades/WalletRegistryV2MisplacedNewSlot.sol": {
      "content": "// This is a contract used to test WalletRegistry upgradeability. It is a copy\n// of WalletRegistry contract with some differences marked with `TEST:` comments.\n\n// SPDX-License-Identifier: GPL-3.0-only\n//\n// ▓▓▌ ▓▓ ▐▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▄\n// ▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n//   ▓▓▓▓▓▓    ▓▓▓▓▓▓▓▀    ▐▓▓▓▓▓▓    ▐▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n//   ▓▓▓▓▓▓▄▄▓▓▓▓▓▓▓▀      ▐▓▓▓▓▓▓▄▄▄▄         ▓▓▓▓▓▓▄▄▄▄         ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n//   ▓▓▓▓▓▓▓▓▓▓▓▓▓▀        ▐▓▓▓▓▓▓▓▓▓▓         ▓▓▓▓▓▓▓▓▓▓         ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n//   ▓▓▓▓▓▓▀▀▓▓▓▓▓▓▄       ▐▓▓▓▓▓▓▀▀▀▀         ▓▓▓▓▓▓▀▀▀▀         ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▀\n//   ▓▓▓▓▓▓   ▀▓▓▓▓▓▓▄     ▐▓▓▓▓▓▓     ▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌\n// ▓▓▓▓▓▓▓▓▓▓ █▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▓▓\n// ▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▓▓\n//\n//                           Trust math, not hardware.\n\npragma solidity 0.8.17;\n\nimport \"../../api/IWalletRegistry.sol\";\nimport \"../../api/IWalletOwner.sol\";\nimport \"../../libraries/Wallets.sol\";\nimport {EcdsaAuthorization as Authorization} from \"../../libraries/EcdsaAuthorization.sol\";\nimport {EcdsaDkg as DKG} from \"../../libraries/EcdsaDkg.sol\";\nimport {EcdsaInactivity as Inactivity} from \"../../libraries/EcdsaInactivity.sol\";\nimport {EcdsaDkgValidator as DKGValidator} from \"../../EcdsaDkgValidator.sol\";\n\nimport \"@keep-network/sortition-pools/contracts/SortitionPool.sol\";\nimport \"@keep-network/random-beacon/contracts/api/IRandomBeacon.sol\";\nimport \"@keep-network/random-beacon/contracts/api/IRandomBeaconConsumer.sol\";\nimport \"@keep-network/random-beacon/contracts/Reimbursable.sol\";\nimport \"@keep-network/random-beacon/contracts/ReimbursementPool.sol\";\nimport \"@keep-network/random-beacon/contracts/Governable.sol\";\n\nimport \"@threshold-network/solidity-contracts/contracts/staking/IApplication.sol\";\nimport \"@threshold-network/solidity-contracts/contracts/staking/IStaking.sol\";\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\ncontract WalletRegistryV2MisplacedNewSlot is\n    IWalletRegistry,\n    IRandomBeaconConsumer,\n    IApplication,\n    Governable,\n    Reimbursable,\n    Initializable\n{\n    using Authorization for Authorization.Data;\n    using DKG for DKG.Data;\n    using Wallets for Wallets.Data;\n\n    // TEST: This is an variable added to fail the upgradeability validation.\n    string public newVar;\n\n    // Libraries data storages\n    Authorization.Data internal authorization;\n    DKG.Data internal dkg;\n    Wallets.Data internal wallets;\n\n    /// @notice Slashing amount for submitting a malicious DKG result. Every\n    ///         DKG result submitted can be challenged for the time of\n    ///         `dkg.resultChallengePeriodLength`. If the DKG result submitted\n    ///         is challenged and proven to be malicious, the operator who\n    ///         submitted the malicious result is slashed for\n    ///         `_maliciousDkgResultSlashingAmount`.\n    uint96 internal _maliciousDkgResultSlashingAmount;\n\n    /// @notice Percentage of the staking contract malicious behavior\n    ///         notification reward which will be transferred to the notifier\n    ///         reporting about a malicious DKG result. Notifiers are rewarded\n    ///         from a notifiers treasury pool. For example, if\n    ///         notification reward is 1000 and the value of the multiplier is\n    ///         5, the notifier will receive: 5% of 1000 = 50 per each\n    ///         operator affected.\n    uint256 internal _maliciousDkgResultNotificationRewardMultiplier;\n\n    /// @notice Duration of the sortition pool rewards ban imposed on operators\n    ///         who missed their turn for DKG result submission or who failed\n    ///         a heartbeat.\n    uint256 internal _sortitionPoolRewardsBanDuration;\n\n    /// @notice Calculated max gas cost for submitting a DKG result. This will\n    ///         be refunded as part of the DKG approval process. It is in the\n    ///         submitter's interest to not skip his priority turn on the approval,\n    ///         otherwise the refund of the DKG submission will be refunded to\n    ///         another group member that will call the DKG approve function.\n    uint256 internal _dkgResultSubmissionGas;\n\n    /// @notice Gas that is meant to balance the DKG result approval's overall\n    ///         cost. It can be updated by the governance based on the current\n    ///         market conditions.\n    uint256 internal _dkgResultApprovalGasOffset;\n\n    /// @notice Gas that is meant to balance the notification of an operator\n    ///         inactivity. It can be updated by the governance based on the\n    ///         current market conditions.\n    uint256 internal _notifyOperatorInactivityGasOffset;\n\n    /// @notice Gas that is meant to balance the notification of a seed for DKG\n    ///         delivery timeout. It can be updated by the governance based on the\n    ///         current market conditions.\n    uint256 internal _notifySeedTimeoutGasOffset;\n\n    /// @notice Gas that is meant to balance the notification of a DKG protocol\n    ///         execution timeout. It can be updated by the governance based on the\n    ///         current market conditions.\n    /// @dev The value is subtracted for the refundable gas calculation, as the\n    ///      DKG timeout notification transaction recovers some gas when cleaning\n    ///      up the storage.\n    uint256 internal _notifyDkgTimeoutNegativeGasOffset;\n\n    /// @notice Stores current operator inactivity claim nonce for the given\n    ///         wallet signing group. Each claim is made with a unique nonce\n    ///         which protects against claim replay.\n    mapping(bytes32 => uint256) public inactivityClaimNonce; // walletID -> nonce\n\n    // Address that is set as owner of all wallets. Only this address can request\n    // new wallets creation and manage their state.\n    IWalletOwner public walletOwner;\n\n    // External dependencies\n\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    SortitionPool public immutable sortitionPool;\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    IStaking public immutable staking;\n    IRandomBeacon public randomBeacon;\n\n    // Events\n    event DkgStarted(uint256 indexed seed);\n\n    event DkgResultSubmitted(\n        bytes32 indexed resultHash,\n        uint256 indexed seed,\n        DKG.Result result\n    );\n\n    event DkgTimedOut();\n\n    event DkgResultApproved(\n        bytes32 indexed resultHash,\n        address indexed approver\n    );\n\n    event DkgResultChallenged(\n        bytes32 indexed resultHash,\n        address indexed challenger,\n        string reason\n    );\n\n    event DkgStateLocked();\n\n    event DkgSeedTimedOut();\n\n    event WalletCreated(\n        bytes32 indexed walletID,\n        bytes32 indexed dkgResultHash\n    );\n\n    event WalletClosed(bytes32 indexed walletID);\n\n    event DkgMaliciousResultSlashed(\n        bytes32 indexed resultHash,\n        uint256 slashingAmount,\n        address maliciousSubmitter\n    );\n\n    event DkgMaliciousResultSlashingFailed(\n        bytes32 indexed resultHash,\n        uint256 slashingAmount,\n        address maliciousSubmitter\n    );\n\n    event AuthorizationParametersUpdated(\n        uint96 minimumAuthorization,\n        uint64 authorizationDecreaseDelay,\n        uint64 authorizationDecreaseChangePeriod\n    );\n\n    event RewardParametersUpdated(\n        uint256 maliciousDkgResultNotificationRewardMultiplier,\n        uint256 sortitionPoolRewardsBanDuration\n    );\n\n    event SlashingParametersUpdated(uint256 maliciousDkgResultSlashingAmount);\n\n    event DkgParametersUpdated(\n        uint256 seedTimeout,\n        uint256 resultChallengePeriodLength,\n        uint256 resultChallengeExtraGas,\n        uint256 resultSubmissionTimeout,\n        uint256 resultSubmitterPrecedencePeriodLength\n    );\n\n    event GasParametersUpdated(\n        uint256 dkgResultSubmissionGas,\n        uint256 dkgResultApprovalGasOffset,\n        uint256 notifyOperatorInactivityGasOffset,\n        uint256 notifySeedTimeoutGasOffset,\n        uint256 notifyDkgTimeoutNegativeGasOffset\n    );\n\n    event RandomBeaconUpgraded(address randomBeacon);\n\n    event WalletOwnerUpdated(address walletOwner);\n\n    event OperatorRegistered(\n        address indexed stakingProvider,\n        address indexed operator\n    );\n\n    event AuthorizationIncreased(\n        address indexed stakingProvider,\n        address indexed operator,\n        uint96 fromAmount,\n        uint96 toAmount\n    );\n\n    event AuthorizationDecreaseRequested(\n        address indexed stakingProvider,\n        address indexed operator,\n        uint96 fromAmount,\n        uint96 toAmount,\n        uint64 decreasingAt\n    );\n\n    event AuthorizationDecreaseApproved(address indexed stakingProvider);\n\n    event InvoluntaryAuthorizationDecreaseFailed(\n        address indexed stakingProvider,\n        address indexed operator,\n        uint96 fromAmount,\n        uint96 toAmount\n    );\n\n    event OperatorJoinedSortitionPool(\n        address indexed stakingProvider,\n        address indexed operator\n    );\n\n    event OperatorStatusUpdated(\n        address indexed stakingProvider,\n        address indexed operator\n    );\n\n    event InactivityClaimed(\n        bytes32 indexed walletID,\n        uint256 nonce,\n        address notifier\n    );\n\n    modifier onlyStakingContract() {\n        require(\n            msg.sender == address(staking),\n            \"Caller is not the staking contract\"\n        );\n        _;\n    }\n\n    /// @notice Reverts if called not by the Wallet Owner.\n    modifier onlyWalletOwner() {\n        require(\n            msg.sender == address(walletOwner),\n            \"Caller is not the Wallet Owner\"\n        );\n        _;\n    }\n\n    modifier onlyReimbursableAdmin() override {\n        require(governance == msg.sender, \"Caller is not the governance\");\n        _;\n    }\n\n    /// @dev Used to initialize immutable variables only, use `initialize` function\n    ///      for upgradable contract initialization on deployment.\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(SortitionPool _sortitionPool, IStaking _staking) {\n        sortitionPool = _sortitionPool;\n        staking = _staking;\n\n        _disableInitializers();\n    }\n\n    /// @dev Initializes upgradable contract on deployment.\n    function initialize(\n        DKGValidator _ecdsaDkgValidator,\n        IRandomBeacon _randomBeacon,\n        ReimbursementPool _reimbursementPool\n    ) external initializer {\n        // TEST: Removed content of V1's initializer. The `initializer` modifier\n        // protects this function from being called again.\n    }\n\n    // TEST: Added initializer for V2\n    function initializeV2(IRandomBeacon _randomBeacon, string memory _newVar)\n        public\n        reinitializer(2)\n    {\n        randomBeacon = _randomBeacon;\n        newVar = _newVar;\n    }\n\n    /// @notice Withdraws application rewards for the given staking provider.\n    ///         Rewards are withdrawn to the staking provider's beneficiary\n    ///         address set in the staking contract. Reverts if staking provider\n    ///         has not registered the operator address.\n    /// @dev Emits `RewardsWithdrawn` event.\n    function withdrawRewards(address stakingProvider) external {\n        address operator = stakingProviderToOperator(stakingProvider);\n        require(operator != address(0), \"Unknown operator\");\n        (, address beneficiary, ) = staking.rolesOf(stakingProvider);\n        uint96 amount = sortitionPool.withdrawRewards(operator, beneficiary);\n        // slither-disable-next-line reentrancy-events\n        emit RewardsWithdrawn(stakingProvider, amount);\n    }\n\n    /// @notice Withdraws rewards belonging to operators marked as ineligible\n    ///         for sortition pool rewards.\n    /// @dev Can be called only by the contract guvnor, which should be the\n    ///      wallet registry governance contract.\n    /// @param recipient Recipient of withdrawn rewards.\n    function withdrawIneligibleRewards(address recipient)\n        external\n        onlyGovernance\n    {\n        sortitionPool.withdrawIneligible(recipient);\n    }\n\n    /// @notice Used by staking provider to set operator address that will\n    ///         operate ECDSA node. The given staking provider can set operator\n    ///         address only one time. The operator address can not be changed\n    ///         and must be unique. Reverts if the operator is already set for\n    ///         the staking provider or if the operator address is already in\n    ///         use. Reverts if there is a pending authorization decrease for\n    ///         the staking provider.\n    function registerOperator(address operator) external {\n        authorization.registerOperator(operator);\n    }\n\n    /// @notice Lets the operator join the sortition pool. The operator address\n    ///         must be known - before calling this function, it has to be\n    ///         appointed by the staking provider by calling `registerOperator`.\n    ///         Also, the operator must have the minimum authorization required\n    ///         by ECDSA. Function reverts if there is no minimum stake\n    ///         authorized or if the operator is not known. If there was an\n    ///         authorization decrease requested, it is activated by starting\n    ///         the authorization decrease delay.\n    function joinSortitionPool() external {\n        authorization.joinSortitionPool(staking, sortitionPool);\n    }\n\n    /// @notice Updates status of the operator in the sortition pool. If there\n    ///         was an authorization decrease requested, it is activated by\n    ///         starting the authorization decrease delay.\n    ///         Function reverts if the operator is not known.\n    function updateOperatorStatus(address operator) external {\n        authorization.updateOperatorStatus(staking, sortitionPool, operator);\n    }\n\n    /// @notice Used by T staking contract to inform the application that the\n    ///         authorized stake amount for the given staking provider increased.\n    ///\n    ///         Reverts if the authorization amount is below the minimum.\n    ///\n    ///         The function is not updating the sortition pool. Sortition pool\n    ///         state needs to be updated by the operator with a call to\n    ///         `joinSortitionPool` or `updateOperatorStatus`.\n    ///\n    /// @dev Can only be called by T staking contract.\n    function authorizationIncreased(\n        address stakingProvider,\n        uint96 fromAmount,\n        uint96 toAmount\n    ) external onlyStakingContract {\n        authorization.authorizationIncreased(\n            stakingProvider,\n            fromAmount,\n            toAmount\n        );\n    }\n\n    /// @notice Used by T staking contract to inform the application that the\n    ///         authorization decrease for the given staking provider has been\n    ///         requested.\n    ///\n    ///         Reverts if the amount after deauthorization would be non-zero\n    ///         and lower than the minimum authorization.\n    ///\n    ///         If the operator is not known (`registerOperator` was not called)\n    ///         it lets to `approveAuthorizationDecrease` immediatelly. If the\n    ///         operator is known (`registerOperator` was called), the operator\n    ///         needs to update state of the sortition pool with a call to\n    ///         `joinSortitionPool` or `updateOperatorStatus`. After the\n    ///         sortition pool state is in sync, authorization decrease delay\n    ///         starts.\n    ///\n    ///         After authorization decrease delay passes, authorization\n    ///         decrease request needs to be approved with a call to\n    ///         `approveAuthorizationDecrease` function.\n    ///\n    ///         If there is a pending authorization decrease request, it is\n    ///         overwritten.\n    ///\n    /// @dev Can only be called by T staking contract.\n    function authorizationDecreaseRequested(\n        address stakingProvider,\n        uint96 fromAmount,\n        uint96 toAmount\n    ) external onlyStakingContract {\n        authorization.authorizationDecreaseRequested(\n            stakingProvider,\n            fromAmount,\n            toAmount\n        );\n    }\n\n    /// @notice Approves the previously registered authorization decrease\n    ///         request. Reverts if authorization decrease delay has not passed\n    ///         yet or if the authorization decrease was not requested for the\n    ///         given staking provider.\n    function approveAuthorizationDecrease(address stakingProvider) external {\n        authorization.approveAuthorizationDecrease(staking, stakingProvider);\n    }\n\n    /// @notice Used by T staking contract to inform the application the\n    ///         authorization has been decreased for the given staking provider\n    ///         involuntarily, as a result of slashing.\n    ///\n    ///         If the operator is not known (`registerOperator` was not called)\n    ///         the function does nothing. The operator was never in a sortition\n    ///         pool so there is nothing to update.\n    ///\n    ///         If the operator is known, sortition pool is unlocked, and the\n    ///         operator is in the sortition pool, the sortition pool state is\n    ///         updated. If the sortition pool is locked, update needs to be\n    ///         postponed. Every other staker is incentivized to call\n    ///         `updateOperatorStatus` for the problematic operator to increase\n    ///         their own rewards in the pool.\n    function involuntaryAuthorizationDecrease(\n        address stakingProvider,\n        uint96 fromAmount,\n        uint96 toAmount\n    ) external onlyStakingContract {\n        authorization.involuntaryAuthorizationDecrease(\n            staking,\n            sortitionPool,\n            stakingProvider,\n            fromAmount,\n            toAmount\n        );\n    }\n\n    /// @notice Updates address of the Random Beacon.\n    /// @dev Can be called only by the contract guvnor, which should be the\n    ///      wallet registry governance contract. The caller is responsible for\n    ///      validating parameters.\n    /// @param _randomBeacon Random Beacon address.\n    function upgradeRandomBeacon(IRandomBeacon _randomBeacon)\n        external\n        onlyGovernance\n    {\n        randomBeacon = _randomBeacon;\n        emit RandomBeaconUpgraded(address(_randomBeacon));\n    }\n\n    /// @notice Updates the wallet owner.\n    /// @dev Can be called only by the contract guvnor, which should be the\n    ///      wallet registry governance contract. The caller is responsible for\n    ///      validating parameters. The wallet owner has to implement `IWalletOwner`\n    ///      interface.\n    /// @param _walletOwner New wallet owner address.\n    function updateWalletOwner(IWalletOwner _walletOwner)\n        external\n        onlyGovernance\n    {\n        walletOwner = _walletOwner;\n        emit WalletOwnerUpdated(address(_walletOwner));\n    }\n\n    /// @notice Updates the values of authorization parameters.\n    /// @dev Can be called only by the contract guvnor, which should be the\n    ///      wallet registry governance contract. The caller is responsible for\n    ///      validating parameters.\n    /// @param _minimumAuthorization New minimum authorization amount.\n    /// @param _authorizationDecreaseDelay New authorization decrease delay in\n    ///        seconds.\n    /// @param _authorizationDecreaseChangePeriod New authorization decrease\n    ///        change period in seconds.\n    function updateAuthorizationParameters(\n        uint96 _minimumAuthorization,\n        uint64 _authorizationDecreaseDelay,\n        uint64 _authorizationDecreaseChangePeriod\n    ) external onlyGovernance {\n        authorization.setMinimumAuthorization(_minimumAuthorization);\n        authorization.setAuthorizationDecreaseDelay(\n            _authorizationDecreaseDelay\n        );\n        authorization.setAuthorizationDecreaseChangePeriod(\n            _authorizationDecreaseChangePeriod\n        );\n\n        emit AuthorizationParametersUpdated(\n            _minimumAuthorization,\n            _authorizationDecreaseDelay,\n            _authorizationDecreaseChangePeriod\n        );\n    }\n\n    /// @notice Updates the values of DKG parameters.\n    /// @dev Can be called only by the contract guvnor, which should be the\n    ///      wallet registry governance contract. The caller is responsible for\n    ///      validating parameters.\n    /// @param _seedTimeout New seed timeout.\n    /// @param _resultChallengePeriodLength New DKG result challenge period\n    ///        length.\n    /// @param _resultChallengeExtraGas New extra gas value required to be left\n    ///        at the end of the DKG result challenge transaction.\n    /// @param _resultSubmissionTimeout New DKG result submission timeout.\n    /// @param _submitterPrecedencePeriodLength New submitter precedence period\n    ///        length.\n    function updateDkgParameters(\n        uint256 _seedTimeout,\n        uint256 _resultChallengePeriodLength,\n        uint256 _resultChallengeExtraGas,\n        uint256 _resultSubmissionTimeout,\n        uint256 _submitterPrecedencePeriodLength\n    ) external onlyGovernance {\n        dkg.setSeedTimeout(_seedTimeout);\n        dkg.setResultChallengePeriodLength(_resultChallengePeriodLength);\n        dkg.setResultChallengeExtraGas(_resultChallengeExtraGas);\n        dkg.setResultSubmissionTimeout(_resultSubmissionTimeout);\n        dkg.setSubmitterPrecedencePeriodLength(\n            _submitterPrecedencePeriodLength\n        );\n\n        // slither-disable-next-line reentrancy-events\n        emit DkgParametersUpdated(\n            _seedTimeout,\n            _resultChallengePeriodLength,\n            _resultChallengeExtraGas,\n            _resultSubmissionTimeout,\n            _submitterPrecedencePeriodLength\n        );\n    }\n\n    /// @notice Updates the values of reward parameters.\n    /// @dev Can be called only by the contract guvnor, which should be the\n    ///      wallet registry governance contract. The caller is responsible for\n    ///      validating parameters.\n    /// @param maliciousDkgResultNotificationRewardMultiplier New value of the\n    ///        DKG malicious result notification reward multiplier.\n    /// @param sortitionPoolRewardsBanDuration New sortition pool rewards\n    ///        ban duration in seconds.\n    function updateRewardParameters(\n        uint256 maliciousDkgResultNotificationRewardMultiplier,\n        uint256 sortitionPoolRewardsBanDuration\n    ) external onlyGovernance {\n        _maliciousDkgResultNotificationRewardMultiplier = maliciousDkgResultNotificationRewardMultiplier;\n        _sortitionPoolRewardsBanDuration = sortitionPoolRewardsBanDuration;\n        emit RewardParametersUpdated(\n            maliciousDkgResultNotificationRewardMultiplier,\n            sortitionPoolRewardsBanDuration\n        );\n    }\n\n    /// @notice Updates the values of slashing parameters.\n    /// @dev Can be called only by the contract guvnor, which should be the\n    ///      wallet registry governance contract. The caller is responsible for\n    ///      validating parameters.\n    /// @param maliciousDkgResultSlashingAmount New malicious DKG result\n    ///        slashing amount.\n    function updateSlashingParameters(uint96 maliciousDkgResultSlashingAmount)\n        external\n        onlyGovernance\n    {\n        _maliciousDkgResultSlashingAmount = maliciousDkgResultSlashingAmount;\n        emit SlashingParametersUpdated(maliciousDkgResultSlashingAmount);\n    }\n\n    /// @notice Updates the values of gas-related parameters.\n    /// @dev Can be called only by the contract guvnor, which should be the\n    ///      wallet registry governance contract. The caller is responsible for\n    ///      validating parameters.\n    /// @param dkgResultSubmissionGas New DKG result submission gas.\n    /// @param dkgResultApprovalGasOffset New DKG result approval gas offset.\n    /// @param notifyOperatorInactivityGasOffset New operator inactivity\n    ///        notification gas offset.\n    /// @param notifySeedTimeoutGasOffset New seed for DKG delivery timeout\n    ///        notification gas offset.\n    /// @param notifyDkgTimeoutNegativeGasOffset New DKG timeout notification gas\n    ///        offset.\n    function updateGasParameters(\n        uint256 dkgResultSubmissionGas,\n        uint256 dkgResultApprovalGasOffset,\n        uint256 notifyOperatorInactivityGasOffset,\n        uint256 notifySeedTimeoutGasOffset,\n        uint256 notifyDkgTimeoutNegativeGasOffset\n    ) external onlyGovernance {\n        _dkgResultSubmissionGas = dkgResultSubmissionGas;\n        _dkgResultApprovalGasOffset = dkgResultApprovalGasOffset;\n        _notifyOperatorInactivityGasOffset = notifyOperatorInactivityGasOffset;\n        _notifySeedTimeoutGasOffset = notifySeedTimeoutGasOffset;\n        _notifyDkgTimeoutNegativeGasOffset = notifyDkgTimeoutNegativeGasOffset;\n\n        emit GasParametersUpdated(\n            dkgResultSubmissionGas,\n            dkgResultApprovalGasOffset,\n            notifyOperatorInactivityGasOffset,\n            _notifySeedTimeoutGasOffset,\n            _notifyDkgTimeoutNegativeGasOffset\n        );\n    }\n\n    /// @notice Requests a new wallet creation.\n    /// @dev Can be called only by the owner of wallets.\n    ///      It locks the DKG and request a new relay entry. It expects\n    ///      that the DKG process will be started once a new relay entry\n    ///      gets generated.\n    function requestNewWallet() external onlyWalletOwner {\n        dkg.lockState();\n\n        randomBeacon.requestRelayEntry(this);\n    }\n\n    /// @notice Closes an existing wallet. Reverts if wallet with the given ID\n    ///         does not exist or if it has already been closed.\n    /// @param walletID ID of the wallet.\n    /// @dev Only a Wallet Owner can call this function.\n    function closeWallet(bytes32 walletID) external onlyWalletOwner {\n        wallets.deleteWallet(walletID);\n        emit WalletClosed(walletID);\n    }\n\n    /// @notice A callback that is executed once a new relay entry gets\n    ///         generated. It starts the DKG process.\n    /// @dev Can be called only by the random beacon contract.\n    /// @param relayEntry Relay entry.\n    function __beaconCallback(uint256 relayEntry, uint256) external {\n        require(\n            msg.sender == address(randomBeacon),\n            \"Caller is not the Random Beacon\"\n        );\n\n        dkg.start(relayEntry);\n    }\n\n    /// @notice Submits result of DKG protocol.\n    ///         The DKG result consists of result submitting member index,\n    ///         calculated group public key, bytes array of misbehaved members,\n    ///         concatenation of signatures from group members, indices of members\n    ///         corresponding to each signature and the list of group members.\n    ///         The result is registered optimistically and waits for an approval.\n    ///         The result can be challenged when it is believed to be incorrect.\n    ///         The challenge verifies the registered result i.a. it checks if members\n    ///         list corresponds to the expected set of members determined\n    ///         by the sortition pool.\n    /// @dev The message to be signed by each member is keccak256 hash of the\n    ///      calculated group public key, misbehaved members indices and DKG\n    ///      start block. The calculated hash should be prefixed with prefixed with\n    ///      `\\x19Ethereum signed message:\\n` before signing, so the message to\n    ///      sign is:\n    ///      `\\x19Ethereum signed message:\\n${keccak256(groupPubKey,misbehavedIndices,startBlock)}`\n    /// @param dkgResult DKG result.\n    function submitDkgResult(DKG.Result calldata dkgResult) external {\n        wallets.validatePublicKey(dkgResult.groupPubKey);\n        dkg.submitResult(dkgResult);\n    }\n\n    /// @notice Approves DKG result. Can be called when the challenge period for\n    ///         the submitted result is finished. Considers the submitted result\n    ///         as valid, bans misbehaved group members from the sortition pool\n    ///         rewards, and completes the group creation by activating the\n    ///         candidate group. For the first `resultSubmissionTimeout` blocks\n    ///         after the end of the challenge period can be called only by the\n    ///         DKG result submitter. After that time, can be called by anyone.\n    ///         A new wallet based on the DKG result details.\n    /// @param dkgResult Result to approve. Must match the submitted result\n    ///        stored during `submitDkgResult`.\n    function approveDkgResult(DKG.Result calldata dkgResult) external {\n        uint256 gasStart = gasleft();\n        uint32[] memory misbehavedMembers = dkg.approveResult(dkgResult);\n\n        (bytes32 walletID, bytes32 publicKeyX, bytes32 publicKeyY) = wallets\n            .addWallet(dkgResult.membersHash, dkgResult.groupPubKey);\n\n        emit WalletCreated(walletID, keccak256(abi.encode(dkgResult)));\n\n        if (misbehavedMembers.length > 0) {\n            sortitionPool.setRewardIneligibility(\n                misbehavedMembers,\n                // solhint-disable-next-line not-rely-on-time\n                block.timestamp + _sortitionPoolRewardsBanDuration\n            );\n        }\n\n        walletOwner.__ecdsaWalletCreatedCallback(\n            walletID,\n            publicKeyX,\n            publicKeyY\n        );\n\n        dkg.complete();\n\n        // Refund msg.sender's ETH for DKG result submission and result approval\n        reimbursementPool.refund(\n            _dkgResultSubmissionGas +\n                (gasStart - gasleft()) +\n                _dkgResultApprovalGasOffset,\n            msg.sender\n        );\n    }\n\n    /// @notice Notifies about seed for DKG delivery timeout. It is expected\n    ///         that a seed is delivered by the Random Beacon as a relay entry in a\n    ///         callback function.\n    function notifySeedTimeout() external {\n        uint256 gasStart = gasleft();\n\n        dkg.notifySeedTimeout();\n\n        reimbursementPool.refund(\n            (gasStart - gasleft()) + _notifySeedTimeoutGasOffset,\n            msg.sender\n        );\n    }\n\n    /// @notice Notifies about DKG timeout.\n    function notifyDkgTimeout() external {\n        uint256 gasStart = gasleft();\n\n        dkg.notifyDkgTimeout();\n\n        // Note that the offset is subtracted as it is expected that the cleanup\n        // performed on DKG timeout notification removes data from the storage\n        // which is recovering gas for the transaction.\n        reimbursementPool.refund(\n            (gasStart - gasleft()) - _notifyDkgTimeoutNegativeGasOffset,\n            msg.sender\n        );\n    }\n\n    /// @notice Challenges DKG result. If the submitted result is proved to be\n    ///         invalid it reverts the DKG back to the result submission phase.\n    /// @param dkgResult Result to challenge. Must match the submitted result\n    ///        stored during `submitDkgResult`.\n    function challengeDkgResult(DKG.Result calldata dkgResult) external {\n        (\n            bytes32 maliciousDkgResultHash,\n            uint32 maliciousDkgResultSubmitterId\n        ) = dkg.challengeResult(dkgResult);\n\n        address maliciousDkgResultSubmitterAddress = sortitionPool\n            .getIDOperator(maliciousDkgResultSubmitterId);\n\n        address[] memory operatorWrapper = new address[](1);\n        operatorWrapper[0] = operatorToStakingProvider(\n            maliciousDkgResultSubmitterAddress\n        );\n\n        try\n            staking.seize(\n                _maliciousDkgResultSlashingAmount,\n                _maliciousDkgResultNotificationRewardMultiplier,\n                msg.sender,\n                operatorWrapper\n            )\n        {\n            // slither-disable-next-line reentrancy-events\n            emit DkgMaliciousResultSlashed(\n                maliciousDkgResultHash,\n                _maliciousDkgResultSlashingAmount,\n                maliciousDkgResultSubmitterAddress\n            );\n        } catch {\n            // Should never happen but we want to ensure a non-critical path\n            // failure from an external contract does not stop the challenge\n            // to complete.\n            emit DkgMaliciousResultSlashingFailed(\n                maliciousDkgResultHash,\n                _maliciousDkgResultSlashingAmount,\n                maliciousDkgResultSubmitterAddress\n            );\n        }\n\n        // Due to EIP150, 1/64 of the gas is not forwarded to the call, and\n        // will be kept to execute the remaining operations in the function\n        // after the call inside the try-catch.\n        //\n        // To ensure there is no way for the caller to manipulate gas limit in\n        // such a way that the call inside try-catch fails with out-of-gas and\n        // the rest of the function is executed with the remaining 1/64 of gas,\n        // we require an extra gas amount to be left at the end of the call to\n        // `challengeDkgResult`.\n        dkg.requireChallengeExtraGas();\n    }\n\n    /// @notice Notifies about operators who are inactive. Using this function,\n    ///         a majority of the wallet signing group can decide about\n    ///         punishing specific group members who constantly fail doing their\n    ///         job. If the provided claim is proved to be valid and signed by\n    ///         sufficient number of group members, operators of members deemed\n    ///         as inactive are banned from sortition pool rewards for the\n    ///         duration specified by `sortitionPoolRewardsBanDuration` parameter.\n    ///         The function allows to signal about single operators being\n    ///         inactive as well as to signal wallet-wide heartbeat failures\n    ///         that are propagated to the wallet owner who should begin the\n    ///         procedure of moving responsibilities to another wallet given\n    ///         that the wallet who failed the heartbeat may soon be not able to\n    ///         function and provide new signatures.\n    ///         The sender of the claim must be one of the claim signers. This\n    ///         function can be called only for registered wallets\n    /// @param claim Operator inactivity claim.\n    /// @param nonce Current inactivity claim nonce for the given wallet signing\n    ///              group. Must be the same as the stored one.\n    /// @param groupMembers Identifiers of the wallet signing group members.\n    function notifyOperatorInactivity(\n        Inactivity.Claim calldata claim,\n        uint256 nonce,\n        uint32[] calldata groupMembers\n    ) external {\n        uint256 gasStart = gasleft();\n\n        bytes32 walletID = claim.walletID;\n\n        require(nonce == inactivityClaimNonce[walletID], \"Invalid nonce\");\n\n        (bytes32 pubKeyX, bytes32 pubKeyY) = wallets\n            .getWalletPublicKeyCoordinates(walletID);\n        bytes32 memberIdsHash = wallets.getWalletMembersIdsHash(walletID);\n\n        require(\n            memberIdsHash == keccak256(abi.encode(groupMembers)),\n            \"Invalid group members\"\n        );\n\n        uint32[] memory ineligibleOperators = Inactivity.verifyClaim(\n            sortitionPool,\n            claim,\n            bytes.concat(pubKeyX, pubKeyY),\n            nonce,\n            groupMembers\n        );\n\n        inactivityClaimNonce[walletID]++;\n\n        emit InactivityClaimed(walletID, nonce, msg.sender);\n\n        sortitionPool.setRewardIneligibility(\n            ineligibleOperators,\n            // solhint-disable-next-line not-rely-on-time\n            block.timestamp + _sortitionPoolRewardsBanDuration\n        );\n\n        if (claim.heartbeatFailed) {\n            walletOwner.__ecdsaWalletHeartbeatFailedCallback(\n                walletID,\n                pubKeyX,\n                pubKeyY\n            );\n        }\n\n        reimbursementPool.refund(\n            (gasStart - gasleft()) + _notifyOperatorInactivityGasOffset,\n            msg.sender\n        );\n    }\n\n    /// @notice Allows the wallet owner to add all signing group members of the\n    ///         wallet with the given ID to the slashing queue of the staking .\n    ///         contract. The notifier will receive reward per each group member\n    ///         from the staking contract notifiers treasury. The reward is\n    ///         scaled by the `rewardMultiplier` provided as a parameter.\n    /// @param amount Amount of tokens to seize from each signing group member.\n    /// @param rewardMultiplier Fraction of the staking contract notifiers\n    ///        reward the notifier should receive; should be between [0, 100].\n    /// @param notifier Address of the misbehavior notifier.\n    /// @param walletID ID of the wallet.\n    /// @param walletMembersIDs Identifiers of the wallet signing group members.\n    /// @dev Requirements:\n    ///      - The expression `keccak256(abi.encode(walletMembersIDs))` must\n    ///        be exactly the same as the hash stored under `membersIdsHash`\n    ///        for the given `walletID`. Those IDs are not directly stored\n    ///        in the contract for gas efficiency purposes but they can be\n    ///        read from appropriate `DkgResultSubmitted` and `DkgResultApproved`\n    ///        events.\n    ///      - `rewardMultiplier` must be between [0, 100].\n    ///      - This function does revert if staking contract call reverts.\n    ///        The calling code needs to handle the potential revert.\n    function seize(\n        uint96 amount,\n        uint256 rewardMultiplier,\n        address notifier,\n        bytes32 walletID,\n        uint32[] calldata walletMembersIDs\n    ) external onlyWalletOwner {\n        bytes32 memberIdsHash = wallets.getWalletMembersIdsHash(walletID);\n        require(\n            memberIdsHash == keccak256(abi.encode(walletMembersIDs)),\n            \"Invalid wallet members identifiers\"\n        );\n\n        address[] memory groupMembersAddresses = sortitionPool.getIDOperators(\n            walletMembersIDs\n        );\n        address[] memory stakingProvidersAddresses = new address[](\n            walletMembersIDs.length\n        );\n        for (uint256 i = 0; i < groupMembersAddresses.length; i++) {\n            stakingProvidersAddresses[i] = operatorToStakingProvider(\n                groupMembersAddresses[i]\n            );\n        }\n\n        staking.seize(\n            amount,\n            rewardMultiplier,\n            notifier,\n            stakingProvidersAddresses\n        );\n    }\n\n    /// @notice Checks if DKG result is valid for the current DKG.\n    /// @param result DKG result.\n    /// @return True if the result is valid. If the result is invalid it returns\n    ///         false and an error message.\n    function isDkgResultValid(DKG.Result calldata result)\n        external\n        view\n        returns (bool, string memory)\n    {\n        return dkg.isResultValid(result);\n    }\n\n    /// @notice Check current wallet creation state.\n    function getWalletCreationState() external view returns (DKG.State) {\n        return dkg.currentState();\n    }\n\n    /// @notice Checks whether the given operator is a member of the given\n    ///         wallet signing group.\n    /// @param walletID ID of the wallet.\n    /// @param walletMembersIDs Identifiers of the wallet signing group members.\n    /// @param operator Address of the checked operator.\n    /// @param walletMemberIndex Position of the operator in the wallet signing\n    ///        group members list.\n    /// @return True - if the operator is a member of the given wallet signing\n    ///         group. False - otherwise.\n    /// @dev Requirements:\n    ///      - The `operator` parameter must be an actual sortition pool operator.\n    ///      - The expression `keccak256(abi.encode(walletMembersIDs))` must\n    ///        be exactly the same as the hash stored under `membersIdsHash`\n    ///        for the given `walletID`. Those IDs are not directly stored\n    ///        in the contract for gas efficiency purposes but they can be\n    ///        read from appropriate `DkgResultSubmitted` and `DkgResultApproved`\n    ///        events.\n    ///      - The `walletMemberIndex` must be in range [1, walletMembersIDs.length]\n    function isWalletMember(\n        bytes32 walletID,\n        uint32[] calldata walletMembersIDs,\n        address operator,\n        uint256 walletMemberIndex\n    ) external view returns (bool) {\n        uint32 operatorID = sortitionPool.getOperatorID(operator);\n\n        require(operatorID != 0, \"Not a sortition pool operator\");\n\n        bytes32 memberIdsHash = wallets.getWalletMembersIdsHash(walletID);\n\n        require(\n            memberIdsHash == keccak256(abi.encode(walletMembersIDs)),\n            \"Invalid wallet members identifiers\"\n        );\n\n        require(\n            1 <= walletMemberIndex &&\n                walletMemberIndex <= walletMembersIDs.length,\n            \"Wallet member index is out of range\"\n        );\n\n        return walletMembersIDs[walletMemberIndex - 1] == operatorID;\n    }\n\n    /// @notice Checks if awaiting seed timed out.\n    /// @return True if awaiting seed timed out, false otherwise.\n    function hasSeedTimedOut() external view returns (bool) {\n        return dkg.hasSeedTimedOut();\n    }\n\n    /// @notice Checks if DKG timed out. The DKG timeout period includes time required\n    ///         for off-chain protocol execution and time for the result publication\n    ///         for all group members. After this time result cannot be submitted\n    ///         and DKG can be notified about the timeout.\n    /// @return True if DKG timed out, false otherwise.\n    function hasDkgTimedOut() external view returns (bool) {\n        return dkg.hasDkgTimedOut();\n    }\n\n    function getWallet(bytes32 walletID)\n        external\n        view\n        returns (Wallets.Wallet memory)\n    {\n        return wallets.registry[walletID];\n    }\n\n    /// @notice Gets public key of a wallet with a given wallet ID.\n    ///         The public key is returned in an uncompressed format as a 64-byte\n    ///         concatenation of X and Y coordinates.\n    /// @param walletID ID of the wallet.\n    /// @return Uncompressed public key of the wallet.\n    function getWalletPublicKey(bytes32 walletID)\n        external\n        view\n        returns (bytes memory)\n    {\n        return wallets.getWalletPublicKey(walletID);\n    }\n\n    /// @notice Checks if a wallet with the given ID is registered.\n    /// @param walletID Wallet's ID.\n    /// @return True if wallet is registered, false otherwise.\n    function isWalletRegistered(bytes32 walletID) external view returns (bool) {\n        return wallets.isWalletRegistered(walletID);\n    }\n\n    /// @notice The minimum authorization amount required so that operator can\n    ///         participate in ECDSA Wallet operations.\n    function minimumAuthorization() external view returns (uint96) {\n        return authorization.parameters.minimumAuthorization;\n    }\n\n    /// @notice Returns the current value of the staking provider's eligible\n    ///         stake. Eligible stake is defined as the currently authorized\n    ///         stake minus the pending authorization decrease. Eligible stake\n    ///         is what is used for operator's weight in the sortition pool.\n    ///         If the authorized stake minus the pending authorization decrease\n    ///         is below the minimum authorization, eligible stake is 0.\n    function eligibleStake(address stakingProvider)\n        external\n        view\n        returns (uint96)\n    {\n        return authorization.eligibleStake(staking, stakingProvider);\n    }\n\n    /// @notice Returns the amount of rewards available for withdrawal for the\n    ///         given staking provider. Reverts if staking provider has not\n    ///         registered the operator address.\n    function availableRewards(address stakingProvider)\n        external\n        view\n        returns (uint96)\n    {\n        address operator = stakingProviderToOperator(stakingProvider);\n        require(operator != address(0), \"Unknown operator\");\n        return sortitionPool.getAvailableRewards(operator);\n    }\n\n    /// @notice Returns the amount of stake that is pending authorization\n    ///         decrease for the given staking provider. If no authorization\n    ///         decrease has been requested, returns zero.\n    function pendingAuthorizationDecrease(address stakingProvider)\n        external\n        view\n        returns (uint96)\n    {\n        return authorization.pendingAuthorizationDecrease(stakingProvider);\n    }\n\n    /// @notice Returns the remaining time in seconds that needs to pass before\n    ///         the requested authorization decrease can be approved.\n    ///         If the sortition pool state was not updated yet by the operator\n    ///         after requesting the authorization decrease, returns\n    ///         `type(uint64).max`.\n    function remainingAuthorizationDecreaseDelay(address stakingProvider)\n        external\n        view\n        returns (uint64)\n    {\n        return\n            authorization.remainingAuthorizationDecreaseDelay(stakingProvider);\n    }\n\n    /// @notice Returns operator registered for the given staking provider.\n    function stakingProviderToOperator(address stakingProvider)\n        public\n        view\n        returns (address)\n    {\n        return authorization.stakingProviderToOperator[stakingProvider];\n    }\n\n    /// @notice Returns staking provider of the given operator.\n    function operatorToStakingProvider(address operator)\n        public\n        view\n        returns (address)\n    {\n        return authorization.operatorToStakingProvider[operator];\n    }\n\n    /// @notice Checks if the operator's authorized stake is in sync with\n    ///         operator's weight in the sortition pool.\n    ///         If the operator is not in the sortition pool and their\n    ///         authorized stake is non-zero, function returns false.\n    function isOperatorUpToDate(address operator) external view returns (bool) {\n        return\n            authorization.isOperatorUpToDate(staking, sortitionPool, operator);\n    }\n\n    /// @notice Returns true if the given operator is in the sortition pool.\n    ///         Otherwise, returns false.\n    function isOperatorInPool(address operator) external view returns (bool) {\n        return sortitionPool.isOperatorInPool(operator);\n    }\n\n    /// @notice Selects a new group of operators. Can only be called when DKG\n    ///         is in progress and the pool is locked.\n    ///         At least one operator has to be registered in the pool,\n    ///         otherwise the function fails reverting the transaction.\n    /// @return IDs of selected group members.\n    function selectGroup() external view returns (uint32[] memory) {\n        return sortitionPool.selectGroup(DKG.groupSize, bytes32(dkg.seed));\n    }\n\n    /// @notice Retrieves dkg parameters that were set in DKG library.\n    function dkgParameters() external view returns (DKG.Parameters memory) {\n        return dkg.parameters;\n    }\n\n    /// @notice Returns authorization-related parameters.\n    /// @dev The minimum authorization is also returned by `minimumAuthorization()`\n    ///      function, as a requirement of `IApplication` interface.\n    /// @return minimumAuthorization The minimum authorization amount required\n    ///         so that operator can participate in the random beacon. This\n    ///         amount is required to execute slashing for providing a malicious\n    ///         DKG result or when a relay entry times out.\n    /// @return authorizationDecreaseDelay Delay in seconds that needs to pass\n    ///         between the time authorization decrease is requested and the\n    ///         time that request gets approved. Protects against free-riders\n    ///         earning rewards and not being active in the network.\n    /// @return authorizationDecreaseChangePeriod Authorization decrease change\n    ///         period in seconds. It is the time, before authorization decrease\n    ///         delay end, during which the pending authorization decrease\n    ///         request can be overwritten.\n    ///         If set to 0, pending authorization decrease request can not be\n    ///         overwritten until the entire `authorizationDecreaseDelay` ends.\n    ///         If set to value equal `authorizationDecreaseDelay`, request can\n    ///         always be overwritten.\n    function authorizationParameters()\n        external\n        view\n        returns (\n            uint96 minimumAuthorization,\n            uint64 authorizationDecreaseDelay,\n            uint64 authorizationDecreaseChangePeriod\n        )\n    {\n        return (\n            authorization.parameters.minimumAuthorization,\n            authorization.parameters.authorizationDecreaseDelay,\n            authorization.parameters.authorizationDecreaseChangePeriod\n        );\n    }\n\n    /// @notice Retrieves reward-related parameters.\n    /// @return maliciousDkgResultNotificationRewardMultiplier Percentage of the\n    ///         staking contract malicious behavior notification reward which\n    ///         will be transferred to the notifier reporting about a malicious\n    ///         DKG result. Notifiers are rewarded from a notifiers treasury\n    ///         pool. For example, if notification reward is 1000 and the value\n    ///         of the multiplier is 5, the notifier will receive:\n    ///         5% of 1000 = 50 per each operator affected.\n    /// @return sortitionPoolRewardsBanDuration Duration of the sortition pool\n    ///         rewards ban imposed on operators who missed their turn for DKG\n    ///         result submission or who failed a heartbeat.\n    function rewardParameters()\n        external\n        view\n        returns (\n            uint256 maliciousDkgResultNotificationRewardMultiplier,\n            uint256 sortitionPoolRewardsBanDuration\n        )\n    {\n        return (\n            _maliciousDkgResultNotificationRewardMultiplier,\n            _sortitionPoolRewardsBanDuration\n        );\n    }\n\n    /// @notice Retrieves slashing-related parameters.\n    /// @return maliciousDkgResultSlashingAmount Slashing amount for submitting\n    ///         a malicious DKG result. Every DKG result submitted can be\n    ///         challenged for the time of `dkg.resultChallengePeriodLength`.\n    ///         If the DKG result submitted is challenged and proven to be\n    ///         malicious, the operator who submitted the malicious result is\n    ///         slashed for `_maliciousDkgResultSlashingAmount`.\n    function slashingParameters()\n        external\n        view\n        returns (uint96 maliciousDkgResultSlashingAmount)\n    {\n        return _maliciousDkgResultSlashingAmount;\n    }\n\n    /// @notice Retrieves gas-related parameters.\n    /// @return dkgResultSubmissionGas Calculated max gas cost for submitting\n    ///         a DKG result. This will be refunded as part of the DKG approval\n    ///         process. It is in the submitter's interest to not skip his\n    ///         priority turn on the approval, otherwise the refund of the DKG\n    ///         submission will be refunded to another group member that will\n    ///         call the DKG approve function.\n    /// @return dkgResultApprovalGasOffset Gas that is meant to balance the DKG\n    ///         result approval's overall cost. It can be updated by the\n    ///         governance based on the current market conditions.\n    /// @return notifyOperatorInactivityGasOffset Gas that is meant to balance\n    ///         the notification of an operator inactivity. It can be updated by\n    ///         the governance based on the current market conditions.\n    /// @return notifySeedTimeoutGasOffset Gas that is meant to balance the\n    ///         notification of a seed for DKG delivery timeout. It can be updated\n    ///         by the governance based on the current market conditions.\n    /// @return notifyDkgTimeoutNegativeGasOffset Gas that is meant to balance\n    ///         the notification of a DKG protocol execution timeout. It can be\n    ///         updated by the governance based on the current market conditions.\n    function gasParameters()\n        external\n        view\n        returns (\n            uint256 dkgResultSubmissionGas,\n            uint256 dkgResultApprovalGasOffset,\n            uint256 notifyOperatorInactivityGasOffset,\n            uint256 notifySeedTimeoutGasOffset,\n            uint256 notifyDkgTimeoutNegativeGasOffset\n        )\n    {\n        return (\n            _dkgResultSubmissionGas,\n            _dkgResultApprovalGasOffset,\n            _notifyOperatorInactivityGasOffset,\n            _notifySeedTimeoutGasOffset,\n            _notifyDkgTimeoutNegativeGasOffset\n        );\n    }\n}\n"
    },
    "contracts/test/upgrades/WalletRegistryV2.sol": {
      "content": "// This is a contract used to test WalletRegistry upgradeability. It is a copy\n// of WalletRegistry contract with some differences marked with `TEST:` comments.\n\n// SPDX-License-Identifier: GPL-3.0-only\n//\n// ▓▓▌ ▓▓ ▐▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▄\n// ▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n//   ▓▓▓▓▓▓    ▓▓▓▓▓▓▓▀    ▐▓▓▓▓▓▓    ▐▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n//   ▓▓▓▓▓▓▄▄▓▓▓▓▓▓▓▀      ▐▓▓▓▓▓▓▄▄▄▄         ▓▓▓▓▓▓▄▄▄▄         ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n//   ▓▓▓▓▓▓▓▓▓▓▓▓▓▀        ▐▓▓▓▓▓▓▓▓▓▓         ▓▓▓▓▓▓▓▓▓▓         ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n//   ▓▓▓▓▓▓▀▀▓▓▓▓▓▓▄       ▐▓▓▓▓▓▓▀▀▀▀         ▓▓▓▓▓▓▀▀▀▀         ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▀\n//   ▓▓▓▓▓▓   ▀▓▓▓▓▓▓▄     ▐▓▓▓▓▓▓     ▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌\n// ▓▓▓▓▓▓▓▓▓▓ █▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▓▓\n// ▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▓▓\n//\n//                           Trust math, not hardware.\n\npragma solidity 0.8.17;\n\nimport \"../../api/IWalletRegistry.sol\";\nimport \"../../api/IWalletOwner.sol\";\nimport \"../../libraries/Wallets.sol\";\nimport {EcdsaAuthorization as Authorization} from \"../../libraries/EcdsaAuthorization.sol\";\nimport {EcdsaDkg as DKG} from \"../../libraries/EcdsaDkg.sol\";\nimport {EcdsaInactivity as Inactivity} from \"../../libraries/EcdsaInactivity.sol\";\nimport {EcdsaDkgValidator as DKGValidator} from \"../../EcdsaDkgValidator.sol\";\n\nimport \"@keep-network/sortition-pools/contracts/SortitionPool.sol\";\nimport \"@keep-network/random-beacon/contracts/api/IRandomBeacon.sol\";\nimport \"@keep-network/random-beacon/contracts/api/IRandomBeaconConsumer.sol\";\nimport \"@keep-network/random-beacon/contracts/Reimbursable.sol\";\nimport \"@keep-network/random-beacon/contracts/ReimbursementPool.sol\";\nimport \"@keep-network/random-beacon/contracts/Governable.sol\";\n\nimport \"@threshold-network/solidity-contracts/contracts/staking/IApplication.sol\";\nimport \"@threshold-network/solidity-contracts/contracts/staking/IStaking.sol\";\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\ncontract WalletRegistryV2 is\n    IWalletRegistry,\n    IRandomBeaconConsumer,\n    IApplication,\n    Governable,\n    Reimbursable,\n    Initializable\n{\n    using Authorization for Authorization.Data;\n    using DKG for DKG.Data;\n    using Wallets for Wallets.Data;\n\n    // Libraries data storages\n    Authorization.Data internal authorization;\n    DKG.Data internal dkg;\n    Wallets.Data internal wallets;\n\n    /// @notice Slashing amount for submitting a malicious DKG result. Every\n    ///         DKG result submitted can be challenged for the time of\n    ///         `dkg.resultChallengePeriodLength`. If the DKG result submitted\n    ///         is challenged and proven to be malicious, the operator who\n    ///         submitted the malicious result is slashed for\n    ///         `_maliciousDkgResultSlashingAmount`.\n    uint96 internal _maliciousDkgResultSlashingAmount;\n\n    /// @notice Percentage of the staking contract malicious behavior\n    ///         notification reward which will be transferred to the notifier\n    ///         reporting about a malicious DKG result. Notifiers are rewarded\n    ///         from a notifiers treasury pool. For example, if\n    ///         notification reward is 1000 and the value of the multiplier is\n    ///         5, the notifier will receive: 5% of 1000 = 50 per each\n    ///         operator affected.\n    uint256 internal _maliciousDkgResultNotificationRewardMultiplier;\n\n    /// @notice Duration of the sortition pool rewards ban imposed on operators\n    ///         who missed their turn for DKG result submission or who failed\n    ///         a heartbeat.\n    uint256 internal _sortitionPoolRewardsBanDuration;\n\n    /// @notice Calculated max gas cost for submitting a DKG result. This will\n    ///         be refunded as part of the DKG approval process. It is in the\n    ///         submitter's interest to not skip his priority turn on the approval,\n    ///         otherwise the refund of the DKG submission will be refunded to\n    ///         another group member that will call the DKG approve function.\n    uint256 internal _dkgResultSubmissionGas;\n\n    /// @notice Gas that is meant to balance the DKG result approval's overall\n    ///         cost. It can be updated by the governance based on the current\n    ///         market conditions.\n    uint256 internal _dkgResultApprovalGasOffset;\n\n    /// @notice Gas that is meant to balance the notification of an operator\n    ///         inactivity. It can be updated by the governance based on the\n    ///         current market conditions.\n    uint256 internal _notifyOperatorInactivityGasOffset;\n\n    /// @notice Gas that is meant to balance the notification of a seed for DKG\n    ///         delivery timeout. It can be updated by the governance based on the\n    ///         current market conditions.\n    uint256 internal _notifySeedTimeoutGasOffset;\n\n    /// @notice Gas that is meant to balance the notification of a DKG protocol\n    ///         execution timeout. It can be updated by the governance based on the\n    ///         current market conditions.\n    /// @dev The value is subtracted for the refundable gas calculation, as the\n    ///      DKG timeout notification transaction recovers some gas when cleaning\n    ///      up the storage.\n    uint256 internal _notifyDkgTimeoutNegativeGasOffset;\n\n    /// @notice Stores current operator inactivity claim nonce for the given\n    ///         wallet signing group. Each claim is made with a unique nonce\n    ///         which protects against claim replay.\n    mapping(bytes32 => uint256) public inactivityClaimNonce; // walletID -> nonce\n\n    // Address that is set as owner of all wallets. Only this address can request\n    // new wallets creation and manage their state.\n    IWalletOwner public walletOwner;\n\n    // External dependencies\n\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    SortitionPool public immutable sortitionPool;\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    IStaking public immutable staking;\n    IRandomBeacon public randomBeacon;\n\n    // TEST: New variable\n    string public newVar;\n\n    // Events\n    event DkgStarted(uint256 indexed seed);\n\n    event DkgResultSubmitted(\n        bytes32 indexed resultHash,\n        uint256 indexed seed,\n        DKG.Result result\n    );\n\n    event DkgTimedOut();\n\n    event DkgResultApproved(\n        bytes32 indexed resultHash,\n        address indexed approver\n    );\n\n    event DkgResultChallenged(\n        bytes32 indexed resultHash,\n        address indexed challenger,\n        string reason\n    );\n\n    event DkgStateLocked();\n\n    event DkgSeedTimedOut();\n\n    event WalletCreated(\n        bytes32 indexed walletID,\n        bytes32 indexed dkgResultHash\n    );\n\n    event WalletClosed(bytes32 indexed walletID);\n\n    event DkgMaliciousResultSlashed(\n        bytes32 indexed resultHash,\n        uint256 slashingAmount,\n        address maliciousSubmitter\n    );\n\n    event DkgMaliciousResultSlashingFailed(\n        bytes32 indexed resultHash,\n        uint256 slashingAmount,\n        address maliciousSubmitter\n    );\n\n    event AuthorizationParametersUpdated(\n        uint96 minimumAuthorization,\n        uint64 authorizationDecreaseDelay,\n        uint64 authorizationDecreaseChangePeriod\n    );\n\n    event RewardParametersUpdated(\n        uint256 maliciousDkgResultNotificationRewardMultiplier,\n        uint256 sortitionPoolRewardsBanDuration\n    );\n\n    event SlashingParametersUpdated(uint256 maliciousDkgResultSlashingAmount);\n\n    event DkgParametersUpdated(\n        uint256 seedTimeout,\n        uint256 resultChallengePeriodLength,\n        uint256 resultChallengeExtraGas,\n        uint256 resultSubmissionTimeout,\n        uint256 resultSubmitterPrecedencePeriodLength\n    );\n\n    event GasParametersUpdated(\n        uint256 dkgResultSubmissionGas,\n        uint256 dkgResultApprovalGasOffset,\n        uint256 notifyOperatorInactivityGasOffset,\n        uint256 notifySeedTimeoutGasOffset,\n        uint256 notifyDkgTimeoutNegativeGasOffset\n    );\n\n    event RandomBeaconUpgraded(address randomBeacon);\n\n    event WalletOwnerUpdated(address walletOwner);\n\n    event OperatorRegistered(\n        address indexed stakingProvider,\n        address indexed operator\n    );\n\n    event AuthorizationIncreased(\n        address indexed stakingProvider,\n        address indexed operator,\n        uint96 fromAmount,\n        uint96 toAmount\n    );\n\n    event AuthorizationDecreaseRequested(\n        address indexed stakingProvider,\n        address indexed operator,\n        uint96 fromAmount,\n        uint96 toAmount,\n        uint64 decreasingAt\n    );\n\n    event AuthorizationDecreaseApproved(address indexed stakingProvider);\n\n    event InvoluntaryAuthorizationDecreaseFailed(\n        address indexed stakingProvider,\n        address indexed operator,\n        uint96 fromAmount,\n        uint96 toAmount\n    );\n\n    event OperatorJoinedSortitionPool(\n        address indexed stakingProvider,\n        address indexed operator\n    );\n\n    event OperatorStatusUpdated(\n        address indexed stakingProvider,\n        address indexed operator\n    );\n\n    event InactivityClaimed(\n        bytes32 indexed walletID,\n        uint256 nonce,\n        address notifier\n    );\n\n    modifier onlyStakingContract() {\n        require(\n            msg.sender == address(staking),\n            \"Caller is not the staking contract\"\n        );\n        _;\n    }\n\n    /// @notice Reverts if called not by the Wallet Owner.\n    modifier onlyWalletOwner() {\n        require(\n            msg.sender == address(walletOwner),\n            \"Caller is not the Wallet Owner\"\n        );\n        _;\n    }\n\n    modifier onlyReimbursableAdmin() override {\n        require(governance == msg.sender, \"Caller is not the governance\");\n        _;\n    }\n\n    /// @dev Used to initialize immutable variables only, use `initialize` function\n    ///      for upgradable contract initialization on deployment.\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(SortitionPool _sortitionPool, IStaking _staking) {\n        sortitionPool = _sortitionPool;\n        staking = _staking;\n\n        _disableInitializers();\n    }\n\n    /// @dev Initializes upgradable contract on deployment.\n    function initialize(\n        DKGValidator _ecdsaDkgValidator,\n        IRandomBeacon _randomBeacon,\n        ReimbursementPool _reimbursementPool\n    ) external initializer {\n        // TEST: Removed content of V1's initializer. The `initializer` modifier\n        // protects this function from being called again.\n    }\n\n    // TEST: Added initializer for V2\n    function initializeV2(IRandomBeacon _randomBeacon, string memory _newVar)\n        public\n        reinitializer(2)\n    {\n        randomBeacon = _randomBeacon;\n        newVar = _newVar;\n    }\n\n    /// @notice Withdraws application rewards for the given staking provider.\n    ///         Rewards are withdrawn to the staking provider's beneficiary\n    ///         address set in the staking contract. Reverts if staking provider\n    ///         has not registered the operator address.\n    /// @dev Emits `RewardsWithdrawn` event.\n    function withdrawRewards(address stakingProvider) external {\n        address operator = stakingProviderToOperator(stakingProvider);\n        require(operator != address(0), \"Unknown operator\");\n        (, address beneficiary, ) = staking.rolesOf(stakingProvider);\n        uint96 amount = sortitionPool.withdrawRewards(operator, beneficiary);\n        // slither-disable-next-line reentrancy-events\n        emit RewardsWithdrawn(stakingProvider, amount);\n    }\n\n    /// @notice Withdraws rewards belonging to operators marked as ineligible\n    ///         for sortition pool rewards.\n    /// @dev Can be called only by the contract guvnor, which should be the\n    ///      wallet registry governance contract.\n    /// @param recipient Recipient of withdrawn rewards.\n    function withdrawIneligibleRewards(address recipient)\n        external\n        onlyGovernance\n    {\n        sortitionPool.withdrawIneligible(recipient);\n    }\n\n    /// @notice Used by staking provider to set operator address that will\n    ///         operate ECDSA node. The given staking provider can set operator\n    ///         address only one time. The operator address can not be changed\n    ///         and must be unique. Reverts if the operator is already set for\n    ///         the staking provider or if the operator address is already in\n    ///         use. Reverts if there is a pending authorization decrease for\n    ///         the staking provider.\n    function registerOperator(address operator) external {\n        authorization.registerOperator(operator);\n    }\n\n    /// @notice Lets the operator join the sortition pool. The operator address\n    ///         must be known - before calling this function, it has to be\n    ///         appointed by the staking provider by calling `registerOperator`.\n    ///         Also, the operator must have the minimum authorization required\n    ///         by ECDSA. Function reverts if there is no minimum stake\n    ///         authorized or if the operator is not known. If there was an\n    ///         authorization decrease requested, it is activated by starting\n    ///         the authorization decrease delay.\n    function joinSortitionPool() external {\n        authorization.joinSortitionPool(staking, sortitionPool);\n    }\n\n    /// @notice Updates status of the operator in the sortition pool. If there\n    ///         was an authorization decrease requested, it is activated by\n    ///         starting the authorization decrease delay.\n    ///         Function reverts if the operator is not known.\n    function updateOperatorStatus(address operator) external {\n        authorization.updateOperatorStatus(staking, sortitionPool, operator);\n    }\n\n    /// @notice Used by T staking contract to inform the application that the\n    ///         authorized stake amount for the given staking provider increased.\n    ///\n    ///         Reverts if the authorization amount is below the minimum.\n    ///\n    ///         The function is not updating the sortition pool. Sortition pool\n    ///         state needs to be updated by the operator with a call to\n    ///         `joinSortitionPool` or `updateOperatorStatus`.\n    ///\n    /// @dev Can only be called by T staking contract.\n    function authorizationIncreased(\n        address stakingProvider,\n        uint96 fromAmount,\n        uint96 toAmount\n    ) external onlyStakingContract {\n        authorization.authorizationIncreased(\n            stakingProvider,\n            fromAmount,\n            toAmount\n        );\n    }\n\n    /// @notice Used by T staking contract to inform the application that the\n    ///         authorization decrease for the given staking provider has been\n    ///         requested.\n    ///\n    ///         Reverts if the amount after deauthorization would be non-zero\n    ///         and lower than the minimum authorization.\n    ///\n    ///         If the operator is not known (`registerOperator` was not called)\n    ///         it lets to `approveAuthorizationDecrease` immediatelly. If the\n    ///         operator is known (`registerOperator` was called), the operator\n    ///         needs to update state of the sortition pool with a call to\n    ///         `joinSortitionPool` or `updateOperatorStatus`. After the\n    ///         sortition pool state is in sync, authorization decrease delay\n    ///         starts.\n    ///\n    ///         After authorization decrease delay passes, authorization\n    ///         decrease request needs to be approved with a call to\n    ///         `approveAuthorizationDecrease` function.\n    ///\n    ///         If there is a pending authorization decrease request, it is\n    ///         overwritten.\n    ///\n    /// @dev Can only be called by T staking contract.\n    function authorizationDecreaseRequested(\n        address stakingProvider,\n        uint96 fromAmount,\n        uint96 toAmount\n    ) external onlyStakingContract {\n        authorization.authorizationDecreaseRequested(\n            stakingProvider,\n            fromAmount,\n            toAmount\n        );\n    }\n\n    /// @notice Approves the previously registered authorization decrease\n    ///         request. Reverts if authorization decrease delay has not passed\n    ///         yet or if the authorization decrease was not requested for the\n    ///         given staking provider.\n    function approveAuthorizationDecrease(address stakingProvider) external {\n        authorization.approveAuthorizationDecrease(staking, stakingProvider);\n    }\n\n    /// @notice Used by T staking contract to inform the application the\n    ///         authorization has been decreased for the given staking provider\n    ///         involuntarily, as a result of slashing.\n    ///\n    ///         If the operator is not known (`registerOperator` was not called)\n    ///         the function does nothing. The operator was never in a sortition\n    ///         pool so there is nothing to update.\n    ///\n    ///         If the operator is known, sortition pool is unlocked, and the\n    ///         operator is in the sortition pool, the sortition pool state is\n    ///         updated. If the sortition pool is locked, update needs to be\n    ///         postponed. Every other staker is incentivized to call\n    ///         `updateOperatorStatus` for the problematic operator to increase\n    ///         their own rewards in the pool.\n    function involuntaryAuthorizationDecrease(\n        address stakingProvider,\n        uint96 fromAmount,\n        uint96 toAmount\n    ) external onlyStakingContract {\n        authorization.involuntaryAuthorizationDecrease(\n            staking,\n            sortitionPool,\n            stakingProvider,\n            fromAmount,\n            toAmount\n        );\n    }\n\n    /// @notice Updates address of the Random Beacon.\n    /// @dev Can be called only by the contract guvnor, which should be the\n    ///      wallet registry governance contract. The caller is responsible for\n    ///      validating parameters.\n    /// @param _randomBeacon Random Beacon address.\n    function upgradeRandomBeacon(IRandomBeacon _randomBeacon)\n        external\n        onlyGovernance\n    {\n        randomBeacon = _randomBeacon;\n        emit RandomBeaconUpgraded(address(_randomBeacon));\n    }\n\n    /// @notice Updates the wallet owner.\n    /// @dev Can be called only by the contract guvnor, which should be the\n    ///      wallet registry governance contract. The caller is responsible for\n    ///      validating parameters. The wallet owner has to implement `IWalletOwner`\n    ///      interface.\n    /// @param _walletOwner New wallet owner address.\n    function updateWalletOwner(IWalletOwner _walletOwner)\n        external\n        onlyGovernance\n    {\n        walletOwner = _walletOwner;\n        emit WalletOwnerUpdated(address(_walletOwner));\n    }\n\n    /// @notice Updates the values of authorization parameters.\n    /// @dev Can be called only by the contract guvnor, which should be the\n    ///      wallet registry governance contract. The caller is responsible for\n    ///      validating parameters.\n    /// @param _minimumAuthorization New minimum authorization amount.\n    /// @param _authorizationDecreaseDelay New authorization decrease delay in\n    ///        seconds.\n    /// @param _authorizationDecreaseChangePeriod New authorization decrease\n    ///        change period in seconds.\n    function updateAuthorizationParameters(\n        uint96 _minimumAuthorization,\n        uint64 _authorizationDecreaseDelay,\n        uint64 _authorizationDecreaseChangePeriod\n    ) external onlyGovernance {\n        authorization.setMinimumAuthorization(_minimumAuthorization);\n        authorization.setAuthorizationDecreaseDelay(\n            _authorizationDecreaseDelay\n        );\n        authorization.setAuthorizationDecreaseChangePeriod(\n            _authorizationDecreaseChangePeriod\n        );\n\n        emit AuthorizationParametersUpdated(\n            _minimumAuthorization,\n            _authorizationDecreaseDelay,\n            _authorizationDecreaseChangePeriod\n        );\n    }\n\n    /// @notice Updates the values of DKG parameters.\n    /// @dev Can be called only by the contract guvnor, which should be the\n    ///      wallet registry governance contract. The caller is responsible for\n    ///      validating parameters.\n    /// @param _seedTimeout New seed timeout.\n    /// @param _resultChallengePeriodLength New DKG result challenge period\n    ///        length.\n    /// @param _resultChallengeExtraGas New extra gas value required to be left\n    ///        at the end of the DKG result challenge transaction.\n    /// @param _resultSubmissionTimeout New DKG result submission timeout.\n    /// @param _submitterPrecedencePeriodLength New submitter precedence period\n    ///        length.\n    function updateDkgParameters(\n        uint256 _seedTimeout,\n        uint256 _resultChallengePeriodLength,\n        uint256 _resultChallengeExtraGas,\n        uint256 _resultSubmissionTimeout,\n        uint256 _submitterPrecedencePeriodLength\n    ) external onlyGovernance {\n        dkg.setSeedTimeout(_seedTimeout);\n        dkg.setResultChallengePeriodLength(_resultChallengePeriodLength);\n        dkg.setResultChallengeExtraGas(_resultChallengeExtraGas);\n        dkg.setResultSubmissionTimeout(_resultSubmissionTimeout);\n        dkg.setSubmitterPrecedencePeriodLength(\n            _submitterPrecedencePeriodLength\n        );\n\n        // slither-disable-next-line reentrancy-events\n        emit DkgParametersUpdated(\n            _seedTimeout,\n            _resultChallengePeriodLength,\n            _resultChallengeExtraGas,\n            _resultSubmissionTimeout,\n            _submitterPrecedencePeriodLength\n        );\n    }\n\n    /// @notice Updates the values of reward parameters.\n    /// @dev Can be called only by the contract guvnor, which should be the\n    ///      wallet registry governance contract. The caller is responsible for\n    ///      validating parameters.\n    /// @param maliciousDkgResultNotificationRewardMultiplier New value of the\n    ///        DKG malicious result notification reward multiplier.\n    /// @param sortitionPoolRewardsBanDuration New sortition pool rewards\n    ///        ban duration in seconds.\n    function updateRewardParameters(\n        uint256 maliciousDkgResultNotificationRewardMultiplier,\n        uint256 sortitionPoolRewardsBanDuration\n    ) external onlyGovernance {\n        _maliciousDkgResultNotificationRewardMultiplier = maliciousDkgResultNotificationRewardMultiplier;\n        _sortitionPoolRewardsBanDuration = sortitionPoolRewardsBanDuration;\n        emit RewardParametersUpdated(\n            maliciousDkgResultNotificationRewardMultiplier,\n            sortitionPoolRewardsBanDuration\n        );\n    }\n\n    /// @notice Updates the values of slashing parameters.\n    /// @dev Can be called only by the contract guvnor, which should be the\n    ///      wallet registry governance contract. The caller is responsible for\n    ///      validating parameters.\n    /// @param maliciousDkgResultSlashingAmount New malicious DKG result\n    ///        slashing amount.\n    function updateSlashingParameters(uint96 maliciousDkgResultSlashingAmount)\n        external\n        onlyGovernance\n    {\n        _maliciousDkgResultSlashingAmount = maliciousDkgResultSlashingAmount;\n        emit SlashingParametersUpdated(maliciousDkgResultSlashingAmount);\n    }\n\n    /// @notice Updates the values of gas-related parameters.\n    /// @dev Can be called only by the contract guvnor, which should be the\n    ///      wallet registry governance contract. The caller is responsible for\n    ///      validating parameters.\n    /// @param dkgResultSubmissionGas New DKG result submission gas.\n    /// @param dkgResultApprovalGasOffset New DKG result approval gas offset.\n    /// @param notifyOperatorInactivityGasOffset New operator inactivity\n    ///        notification gas offset.\n    /// @param notifySeedTimeoutGasOffset New seed for DKG delivery timeout\n    ///        notification gas offset.\n    /// @param notifyDkgTimeoutNegativeGasOffset New DKG timeout notification gas\n    ///        offset.\n    function updateGasParameters(\n        uint256 dkgResultSubmissionGas,\n        uint256 dkgResultApprovalGasOffset,\n        uint256 notifyOperatorInactivityGasOffset,\n        uint256 notifySeedTimeoutGasOffset,\n        uint256 notifyDkgTimeoutNegativeGasOffset\n    ) external onlyGovernance {\n        _dkgResultSubmissionGas = dkgResultSubmissionGas;\n        _dkgResultApprovalGasOffset = dkgResultApprovalGasOffset;\n        _notifyOperatorInactivityGasOffset = notifyOperatorInactivityGasOffset;\n        _notifySeedTimeoutGasOffset = notifySeedTimeoutGasOffset;\n        _notifyDkgTimeoutNegativeGasOffset = notifyDkgTimeoutNegativeGasOffset;\n\n        emit GasParametersUpdated(\n            dkgResultSubmissionGas,\n            dkgResultApprovalGasOffset,\n            notifyOperatorInactivityGasOffset,\n            _notifySeedTimeoutGasOffset,\n            _notifyDkgTimeoutNegativeGasOffset\n        );\n    }\n\n    /// @notice Requests a new wallet creation.\n    /// @dev Can be called only by the owner of wallets.\n    ///      It locks the DKG and request a new relay entry. It expects\n    ///      that the DKG process will be started once a new relay entry\n    ///      gets generated.\n    function requestNewWallet() external onlyWalletOwner {\n        dkg.lockState();\n\n        randomBeacon.requestRelayEntry(this);\n    }\n\n    /// @notice Closes an existing wallet. Reverts if wallet with the given ID\n    ///         does not exist or if it has already been closed.\n    /// @param walletID ID of the wallet.\n    /// @dev Only a Wallet Owner can call this function.\n    function closeWallet(bytes32 walletID) external onlyWalletOwner {\n        wallets.deleteWallet(walletID);\n        emit WalletClosed(walletID);\n    }\n\n    /// @notice A callback that is executed once a new relay entry gets\n    ///         generated. It starts the DKG process.\n    /// @dev Can be called only by the random beacon contract.\n    /// @param relayEntry Relay entry.\n    function __beaconCallback(uint256 relayEntry, uint256) external {\n        require(\n            msg.sender == address(randomBeacon),\n            \"Caller is not the Random Beacon\"\n        );\n\n        dkg.start(relayEntry);\n    }\n\n    /// @notice Submits result of DKG protocol.\n    ///         The DKG result consists of result submitting member index,\n    ///         calculated group public key, bytes array of misbehaved members,\n    ///         concatenation of signatures from group members, indices of members\n    ///         corresponding to each signature and the list of group members.\n    ///         The result is registered optimistically and waits for an approval.\n    ///         The result can be challenged when it is believed to be incorrect.\n    ///         The challenge verifies the registered result i.a. it checks if members\n    ///         list corresponds to the expected set of members determined\n    ///         by the sortition pool.\n    /// @dev The message to be signed by each member is keccak256 hash of the\n    ///      calculated group public key, misbehaved members indices and DKG\n    ///      start block. The calculated hash should be prefixed with prefixed with\n    ///      `\\x19Ethereum signed message:\\n` before signing, so the message to\n    ///      sign is:\n    ///      `\\x19Ethereum signed message:\\n${keccak256(groupPubKey,misbehavedIndices,startBlock)}`\n    /// @param dkgResult DKG result.\n    function submitDkgResult(DKG.Result calldata dkgResult) external {\n        wallets.validatePublicKey(dkgResult.groupPubKey);\n        dkg.submitResult(dkgResult);\n    }\n\n    /// @notice Approves DKG result. Can be called when the challenge period for\n    ///         the submitted result is finished. Considers the submitted result\n    ///         as valid, bans misbehaved group members from the sortition pool\n    ///         rewards, and completes the group creation by activating the\n    ///         candidate group. For the first `resultSubmissionTimeout` blocks\n    ///         after the end of the challenge period can be called only by the\n    ///         DKG result submitter. After that time, can be called by anyone.\n    ///         A new wallet based on the DKG result details.\n    /// @param dkgResult Result to approve. Must match the submitted result\n    ///        stored during `submitDkgResult`.\n    function approveDkgResult(DKG.Result calldata dkgResult) external {\n        uint256 gasStart = gasleft();\n        uint32[] memory misbehavedMembers = dkg.approveResult(dkgResult);\n\n        (bytes32 walletID, bytes32 publicKeyX, bytes32 publicKeyY) = wallets\n            .addWallet(dkgResult.membersHash, dkgResult.groupPubKey);\n\n        emit WalletCreated(walletID, keccak256(abi.encode(dkgResult)));\n\n        if (misbehavedMembers.length > 0) {\n            sortitionPool.setRewardIneligibility(\n                misbehavedMembers,\n                // solhint-disable-next-line not-rely-on-time\n                block.timestamp + _sortitionPoolRewardsBanDuration\n            );\n        }\n\n        walletOwner.__ecdsaWalletCreatedCallback(\n            walletID,\n            publicKeyX,\n            publicKeyY\n        );\n\n        dkg.complete();\n\n        // Refund msg.sender's ETH for DKG result submission and result approval\n        reimbursementPool.refund(\n            _dkgResultSubmissionGas +\n                (gasStart - gasleft()) +\n                _dkgResultApprovalGasOffset,\n            msg.sender\n        );\n    }\n\n    // TEST: Removed function.\n    // /// @notice Notifies about seed for DKG delivery timeout. It is expected\n    // ///         that a seed is delivered by the Random Beacon as a relay entry in a\n    // ///         callback function.\n    // function notifySeedTimeout() external refundable(msg.sender) {\n    //     dkg.notifySeedTimeout();\n    // }\n\n    // TEST: Modified function.\n    /// @notice Notifies about DKG timeout.\n    function notifyDkgTimeout() external refundable(msg.sender) {\n        revert(\"nice try, but no\");\n    }\n\n    /// @notice Challenges DKG result. If the submitted result is proved to be\n    ///         invalid it reverts the DKG back to the result submission phase.\n    /// @param dkgResult Result to challenge. Must match the submitted result\n    ///        stored during `submitDkgResult`.\n    function challengeDkgResult(DKG.Result calldata dkgResult) external {\n        (\n            bytes32 maliciousDkgResultHash,\n            uint32 maliciousDkgResultSubmitterId\n        ) = dkg.challengeResult(dkgResult);\n\n        address maliciousDkgResultSubmitterAddress = sortitionPool\n            .getIDOperator(maliciousDkgResultSubmitterId);\n\n        address[] memory operatorWrapper = new address[](1);\n        operatorWrapper[0] = operatorToStakingProvider(\n            maliciousDkgResultSubmitterAddress\n        );\n\n        try\n            staking.seize(\n                _maliciousDkgResultSlashingAmount,\n                _maliciousDkgResultNotificationRewardMultiplier,\n                msg.sender,\n                operatorWrapper\n            )\n        {\n            // slither-disable-next-line reentrancy-events\n            emit DkgMaliciousResultSlashed(\n                maliciousDkgResultHash,\n                _maliciousDkgResultSlashingAmount,\n                maliciousDkgResultSubmitterAddress\n            );\n        } catch {\n            // Should never happen but we want to ensure a non-critical path\n            // failure from an external contract does not stop the challenge\n            // to complete.\n            emit DkgMaliciousResultSlashingFailed(\n                maliciousDkgResultHash,\n                _maliciousDkgResultSlashingAmount,\n                maliciousDkgResultSubmitterAddress\n            );\n        }\n\n        // Due to EIP150, 1/64 of the gas is not forwarded to the call, and\n        // will be kept to execute the remaining operations in the function\n        // after the call inside the try-catch.\n        //\n        // To ensure there is no way for the caller to manipulate gas limit in\n        // such a way that the call inside try-catch fails with out-of-gas and\n        // the rest of the function is executed with the remaining 1/64 of gas,\n        // we require an extra gas amount to be left at the end of the call to\n        // `challengeDkgResult`.\n        dkg.requireChallengeExtraGas();\n    }\n\n    /// @notice Notifies about operators who are inactive. Using this function,\n    ///         a majority of the wallet signing group can decide about\n    ///         punishing specific group members who constantly fail doing their\n    ///         job. If the provided claim is proved to be valid and signed by\n    ///         sufficient number of group members, operators of members deemed\n    ///         as inactive are banned from sortition pool rewards for the\n    ///         duration specified by `sortitionPoolRewardsBanDuration` parameter.\n    ///         The function allows to signal about single operators being\n    ///         inactive as well as to signal wallet-wide heartbeat failures\n    ///         that are propagated to the wallet owner who should begin the\n    ///         procedure of moving responsibilities to another wallet given\n    ///         that the wallet who failed the heartbeat may soon be not able to\n    ///         function and provide new signatures.\n    ///         The sender of the claim must be one of the claim signers. This\n    ///         function can be called only for registered wallets\n    /// @param claim Operator inactivity claim.\n    /// @param nonce Current inactivity claim nonce for the given wallet signing\n    ///              group. Must be the same as the stored one.\n    /// @param groupMembers Identifiers of the wallet signing group members.\n    function notifyOperatorInactivity(\n        Inactivity.Claim calldata claim,\n        uint256 nonce,\n        uint32[] calldata groupMembers\n    ) external {\n        uint256 gasStart = gasleft();\n\n        bytes32 walletID = claim.walletID;\n\n        require(nonce == inactivityClaimNonce[walletID], \"Invalid nonce\");\n\n        (bytes32 pubKeyX, bytes32 pubKeyY) = wallets\n            .getWalletPublicKeyCoordinates(walletID);\n        bytes32 memberIdsHash = wallets.getWalletMembersIdsHash(walletID);\n\n        require(\n            memberIdsHash == keccak256(abi.encode(groupMembers)),\n            \"Invalid group members\"\n        );\n\n        uint32[] memory ineligibleOperators = Inactivity.verifyClaim(\n            sortitionPool,\n            claim,\n            bytes.concat(pubKeyX, pubKeyY),\n            nonce,\n            groupMembers\n        );\n\n        inactivityClaimNonce[walletID]++;\n\n        emit InactivityClaimed(walletID, nonce, msg.sender);\n\n        sortitionPool.setRewardIneligibility(\n            ineligibleOperators,\n            // solhint-disable-next-line not-rely-on-time\n            block.timestamp + _sortitionPoolRewardsBanDuration\n        );\n\n        if (claim.heartbeatFailed) {\n            walletOwner.__ecdsaWalletHeartbeatFailedCallback(\n                walletID,\n                pubKeyX,\n                pubKeyY\n            );\n        }\n\n        reimbursementPool.refund(\n            (gasStart - gasleft()) + _notifyOperatorInactivityGasOffset,\n            msg.sender\n        );\n    }\n\n    /// @notice Allows the wallet owner to add all signing group members of the\n    ///         wallet with the given ID to the slashing queue of the staking .\n    ///         contract. The notifier will receive reward per each group member\n    ///         from the staking contract notifiers treasury. The reward is\n    ///         scaled by the `rewardMultiplier` provided as a parameter.\n    /// @param amount Amount of tokens to seize from each signing group member.\n    /// @param rewardMultiplier Fraction of the staking contract notifiers\n    ///        reward the notifier should receive; should be between [0, 100].\n    /// @param notifier Address of the misbehavior notifier.\n    /// @param walletID ID of the wallet.\n    /// @param walletMembersIDs Identifiers of the wallet signing group members.\n    /// @dev Requirements:\n    ///      - The expression `keccak256(abi.encode(walletMembersIDs))` must\n    ///        be exactly the same as the hash stored under `membersIdsHash`\n    ///        for the given `walletID`. Those IDs are not directly stored\n    ///        in the contract for gas efficiency purposes but they can be\n    ///        read from appropriate `DkgResultSubmitted` and `DkgResultApproved`\n    ///        events.\n    ///      - `rewardMultiplier` must be between [0, 100].\n    ///      - This function does revert if staking contract call reverts.\n    ///        The calling code needs to handle the potential revert.\n    function seize(\n        uint96 amount,\n        uint256 rewardMultiplier,\n        address notifier,\n        bytes32 walletID,\n        uint32[] calldata walletMembersIDs\n    ) external onlyWalletOwner {\n        bytes32 memberIdsHash = wallets.getWalletMembersIdsHash(walletID);\n        require(\n            memberIdsHash == keccak256(abi.encode(walletMembersIDs)),\n            \"Invalid wallet members identifiers\"\n        );\n\n        address[] memory groupMembersAddresses = sortitionPool.getIDOperators(\n            walletMembersIDs\n        );\n        address[] memory stakingProvidersAddresses = new address[](\n            walletMembersIDs.length\n        );\n        for (uint256 i = 0; i < groupMembersAddresses.length; i++) {\n            stakingProvidersAddresses[i] = operatorToStakingProvider(\n                groupMembersAddresses[i]\n            );\n        }\n\n        staking.seize(\n            amount,\n            rewardMultiplier,\n            notifier,\n            stakingProvidersAddresses\n        );\n    }\n\n    /// @notice Checks if DKG result is valid for the current DKG.\n    /// @param result DKG result.\n    /// @return True if the result is valid. If the result is invalid it returns\n    ///         false and an error message.\n    function isDkgResultValid(DKG.Result calldata result)\n        external\n        view\n        returns (bool, string memory)\n    {\n        return dkg.isResultValid(result);\n    }\n\n    /// @notice Check current wallet creation state.\n    function getWalletCreationState() external view returns (DKG.State) {\n        return dkg.currentState();\n    }\n\n    /// @notice Checks whether the given operator is a member of the given\n    ///         wallet signing group.\n    /// @param walletID ID of the wallet.\n    /// @param walletMembersIDs Identifiers of the wallet signing group members.\n    /// @param operator Address of the checked operator.\n    /// @param walletMemberIndex Position of the operator in the wallet signing\n    ///        group members list.\n    /// @return True - if the operator is a member of the given wallet signing\n    ///         group. False - otherwise.\n    /// @dev Requirements:\n    ///      - The `operator` parameter must be an actual sortition pool operator.\n    ///      - The expression `keccak256(abi.encode(walletMembersIDs))` must\n    ///        be exactly the same as the hash stored under `membersIdsHash`\n    ///        for the given `walletID`. Those IDs are not directly stored\n    ///        in the contract for gas efficiency purposes but they can be\n    ///        read from appropriate `DkgResultSubmitted` and `DkgResultApproved`\n    ///        events.\n    ///      - The `walletMemberIndex` must be in range [1, walletMembersIDs.length]\n    function isWalletMember(\n        bytes32 walletID,\n        uint32[] calldata walletMembersIDs,\n        address operator,\n        uint256 walletMemberIndex\n    ) external view returns (bool) {\n        uint32 operatorID = sortitionPool.getOperatorID(operator);\n\n        require(operatorID != 0, \"Not a sortition pool operator\");\n\n        bytes32 memberIdsHash = wallets.getWalletMembersIdsHash(walletID);\n\n        require(\n            memberIdsHash == keccak256(abi.encode(walletMembersIDs)),\n            \"Invalid wallet members identifiers\"\n        );\n\n        require(\n            1 <= walletMemberIndex &&\n                walletMemberIndex <= walletMembersIDs.length,\n            \"Wallet member index is out of range\"\n        );\n\n        return walletMembersIDs[walletMemberIndex - 1] == operatorID;\n    }\n\n    /// @notice Checks if awaiting seed timed out.\n    /// @return True if awaiting seed timed out, false otherwise.\n    function hasSeedTimedOut() external view returns (bool) {\n        return dkg.hasSeedTimedOut();\n    }\n\n    /// @notice Checks if DKG timed out. The DKG timeout period includes time required\n    ///         for off-chain protocol execution and time for the result publication\n    ///         for all group members. After this time result cannot be submitted\n    ///         and DKG can be notified about the timeout.\n    /// @return True if DKG timed out, false otherwise.\n    function hasDkgTimedOut() external view returns (bool) {\n        return dkg.hasDkgTimedOut();\n    }\n\n    function getWallet(bytes32 walletID)\n        external\n        view\n        returns (Wallets.Wallet memory)\n    {\n        return wallets.registry[walletID];\n    }\n\n    /// @notice Gets public key of a wallet with a given wallet ID.\n    ///         The public key is returned in an uncompressed format as a 64-byte\n    ///         concatenation of X and Y coordinates.\n    /// @param walletID ID of the wallet.\n    /// @return Uncompressed public key of the wallet.\n    function getWalletPublicKey(bytes32 walletID)\n        external\n        view\n        returns (bytes memory)\n    {\n        return wallets.getWalletPublicKey(walletID);\n    }\n\n    /// @notice Checks if a wallet with the given ID is registered.\n    /// @param walletID Wallet's ID.\n    /// @return True if wallet is registered, false otherwise.\n    function isWalletRegistered(bytes32 walletID) external view returns (bool) {\n        return wallets.isWalletRegistered(walletID);\n    }\n\n    /// @notice The minimum authorization amount required so that operator can\n    ///         participate in ECDSA Wallet operations.\n    function minimumAuthorization() external view returns (uint96) {\n        return authorization.parameters.minimumAuthorization;\n    }\n\n    /// @notice Returns the current value of the staking provider's eligible\n    ///         stake. Eligible stake is defined as the currently authorized\n    ///         stake minus the pending authorization decrease. Eligible stake\n    ///         is what is used for operator's weight in the sortition pool.\n    ///         If the authorized stake minus the pending authorization decrease\n    ///         is below the minimum authorization, eligible stake is 0.\n    function eligibleStake(address stakingProvider)\n        external\n        view\n        returns (uint96)\n    {\n        return authorization.eligibleStake(staking, stakingProvider);\n    }\n\n    /// @notice Returns the amount of rewards available for withdrawal for the\n    ///         given staking provider. Reverts if staking provider has not\n    ///         registered the operator address.\n    function availableRewards(address stakingProvider)\n        external\n        view\n        returns (uint96)\n    {\n        address operator = stakingProviderToOperator(stakingProvider);\n        require(operator != address(0), \"Unknown operator\");\n        return sortitionPool.getAvailableRewards(operator);\n    }\n\n    /// @notice Returns the amount of stake that is pending authorization\n    ///         decrease for the given staking provider. If no authorization\n    ///         decrease has been requested, returns zero.\n    function pendingAuthorizationDecrease(address stakingProvider)\n        external\n        view\n        returns (uint96)\n    {\n        return authorization.pendingAuthorizationDecrease(stakingProvider);\n    }\n\n    /// @notice Returns the remaining time in seconds that needs to pass before\n    ///         the requested authorization decrease can be approved.\n    ///         If the sortition pool state was not updated yet by the operator\n    ///         after requesting the authorization decrease, returns\n    ///         `type(uint64).max`.\n    function remainingAuthorizationDecreaseDelay(address stakingProvider)\n        external\n        view\n        returns (uint64)\n    {\n        return\n            authorization.remainingAuthorizationDecreaseDelay(stakingProvider);\n    }\n\n    /// @notice Returns operator registered for the given staking provider.\n    function stakingProviderToOperator(address stakingProvider)\n        public\n        view\n        returns (address)\n    {\n        return authorization.stakingProviderToOperator[stakingProvider];\n    }\n\n    /// @notice Returns staking provider of the given operator.\n    function operatorToStakingProvider(address operator)\n        public\n        view\n        returns (address)\n    {\n        return authorization.operatorToStakingProvider[operator];\n    }\n\n    /// @notice Checks if the operator's authorized stake is in sync with\n    ///         operator's weight in the sortition pool.\n    ///         If the operator is not in the sortition pool and their\n    ///         authorized stake is non-zero, function returns false.\n    function isOperatorUpToDate(address operator) external view returns (bool) {\n        return\n            authorization.isOperatorUpToDate(staking, sortitionPool, operator);\n    }\n\n    /// @notice Returns true if the given operator is in the sortition pool.\n    ///         Otherwise, returns false.\n    function isOperatorInPool(address operator) external view returns (bool) {\n        return sortitionPool.isOperatorInPool(operator);\n    }\n\n    /// @notice Selects a new group of operators. Can only be called when DKG\n    ///         is in progress and the pool is locked.\n    ///         At least one operator has to be registered in the pool,\n    ///         otherwise the function fails reverting the transaction.\n    /// @return IDs of selected group members.\n    function selectGroup() external view returns (uint32[] memory) {\n        return sortitionPool.selectGroup(DKG.groupSize, bytes32(dkg.seed));\n    }\n\n    /// @notice Retrieves dkg parameters that were set in DKG library.\n    function dkgParameters() external view returns (DKG.Parameters memory) {\n        return dkg.parameters;\n    }\n\n    /// @notice Returns authorization-related parameters.\n    /// @dev The minimum authorization is also returned by `minimumAuthorization()`\n    ///      function, as a requirement of `IApplication` interface.\n    /// @return minimumAuthorization The minimum authorization amount required\n    ///         so that operator can participate in the random beacon. This\n    ///         amount is required to execute slashing for providing a malicious\n    ///         DKG result or when a relay entry times out.\n    /// @return authorizationDecreaseDelay Delay in seconds that needs to pass\n    ///         between the time authorization decrease is requested and the\n    ///         time that request gets approved. Protects against free-riders\n    ///         earning rewards and not being active in the network.\n    /// @return authorizationDecreaseChangePeriod Authorization decrease change\n    ///         period in seconds. It is the time, before authorization decrease\n    ///         delay end, during which the pending authorization decrease\n    ///         request can be overwritten.\n    ///         If set to 0, pending authorization decrease request can not be\n    ///         overwritten until the entire `authorizationDecreaseDelay` ends.\n    ///         If set to value equal `authorizationDecreaseDelay`, request can\n    ///         always be overwritten.\n    function authorizationParameters()\n        external\n        view\n        returns (\n            uint96 minimumAuthorization,\n            uint64 authorizationDecreaseDelay,\n            uint64 authorizationDecreaseChangePeriod\n        )\n    {\n        return (\n            authorization.parameters.minimumAuthorization,\n            authorization.parameters.authorizationDecreaseDelay,\n            authorization.parameters.authorizationDecreaseChangePeriod\n        );\n    }\n\n    /// @notice Retrieves reward-related parameters.\n    /// @return maliciousDkgResultNotificationRewardMultiplier Percentage of the\n    ///         staking contract malicious behavior notification reward which\n    ///         will be transferred to the notifier reporting about a malicious\n    ///         DKG result. Notifiers are rewarded from a notifiers treasury\n    ///         pool. For example, if notification reward is 1000 and the value\n    ///         of the multiplier is 5, the notifier will receive:\n    ///         5% of 1000 = 50 per each operator affected.\n    /// @return sortitionPoolRewardsBanDuration Duration of the sortition pool\n    ///         rewards ban imposed on operators who missed their turn for DKG\n    ///         result submission or who failed a heartbeat.\n    function rewardParameters()\n        external\n        view\n        returns (\n            uint256 maliciousDkgResultNotificationRewardMultiplier,\n            uint256 sortitionPoolRewardsBanDuration\n        )\n    {\n        return (\n            _maliciousDkgResultNotificationRewardMultiplier,\n            _sortitionPoolRewardsBanDuration\n        );\n    }\n\n    /// @notice Retrieves slashing-related parameters.\n    /// @return maliciousDkgResultSlashingAmount Slashing amount for submitting\n    ///         a malicious DKG result. Every DKG result submitted can be\n    ///         challenged for the time of `dkg.resultChallengePeriodLength`.\n    ///         If the DKG result submitted is challenged and proven to be\n    ///         malicious, the operator who submitted the malicious result is\n    ///         slashed for `_maliciousDkgResultSlashingAmount`.\n    function slashingParameters()\n        external\n        view\n        returns (uint96 maliciousDkgResultSlashingAmount)\n    {\n        return _maliciousDkgResultSlashingAmount;\n    }\n\n    /// @notice Retrieves gas-related parameters.\n    /// @return dkgResultSubmissionGas Calculated max gas cost for submitting\n    ///         a DKG result. This will be refunded as part of the DKG approval\n    ///         process. It is in the submitter's interest to not skip his\n    ///         priority turn on the approval, otherwise the refund of the DKG\n    ///         submission will be refunded to another group member that will\n    ///         call the DKG approve function.\n    /// @return dkgResultApprovalGasOffset Gas that is meant to balance the DKG\n    ///         result approval's overall cost. It can be updated by the\n    ///         governance based on the current market conditions.\n    /// @return notifyOperatorInactivityGasOffset Gas that is meant to balance\n    ///         the notification of an operator inactivity. It can be updated by\n    ///         the governance based on the current market conditions.\n    /// @return notifySeedTimeoutGasOffset Gas that is meant to balance the\n    ///         notification of a seed for DKG delivery timeout. It can be updated\n    ///         by the governance based on the current market conditions.\n    /// @return notifyDkgTimeoutNegativeGasOffset Gas that is meant to balance\n    ///         the notification of a DKG protocol execution timeout. It can be\n    ///         updated by the governance based on the current market conditions.\n    function gasParameters()\n        external\n        view\n        returns (\n            uint256 dkgResultSubmissionGas,\n            uint256 dkgResultApprovalGasOffset,\n            uint256 notifyOperatorInactivityGasOffset,\n            uint256 notifySeedTimeoutGasOffset,\n            uint256 notifyDkgTimeoutNegativeGasOffset\n        )\n    {\n        return (\n            _dkgResultSubmissionGas,\n            _dkgResultApprovalGasOffset,\n            _notifyOperatorInactivityGasOffset,\n            _notifySeedTimeoutGasOffset,\n            _notifyDkgTimeoutNegativeGasOffset\n        );\n    }\n}\n"
    },
    "contracts/test/WalletRegistryStub.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@keep-network/sortition-pools/contracts/SortitionPool.sol\";\nimport \"@keep-network/random-beacon/contracts/ReimbursementPool.sol\";\nimport \"../WalletRegistry.sol\";\nimport \"../EcdsaDkgValidator.sol\";\nimport \"../libraries/Wallets.sol\";\n\ncontract WalletRegistryStub is WalletRegistry {\n    using Wallets for Wallets.Data;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(SortitionPool _sortitionPool, IStaking _staking)\n        WalletRegistry(_sortitionPool, _staking)\n    {}\n\n    function forceAddWallet(bytes calldata groupPubKey, bytes32 membersIdsHash)\n        external\n    {\n        wallets.addWallet(membersIdsHash, groupPubKey);\n    }\n\n    function getDkgData() external view returns (EcdsaDkg.Data memory) {\n        return dkg;\n    }\n}\n"
    },
    "@thesis/solidity-contracts/contracts/token/MisfundRecovery.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n\n/// @title  MisfundRecovery\n/// @notice Allows the owner of the token contract extending MisfundRecovery\n///         to recover any ERC20 and ERC721 sent mistakenly to the token\n///         contract address.\ncontract MisfundRecovery is Ownable {\n    using SafeERC20 for IERC20;\n\n    function recoverERC20(\n        IERC20 token,\n        address recipient,\n        uint256 amount\n    ) external onlyOwner {\n        token.safeTransfer(recipient, amount);\n    }\n\n    function recoverERC721(\n        IERC721 token,\n        address recipient,\n        uint256 tokenId,\n        bytes calldata data\n    ) external onlyOwner {\n        token.safeTransferFrom(address(this), recipient, tokenId, data);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/draft-IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\nimport \"../extensions/draft-IERC20PermitUpgradeable.sol\";\nimport \"../../../utils/AddressUpgradeable.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20Upgradeable {\n    using AddressUpgradeable for address;\n\n    function safeTransfer(\n        IERC20Upgradeable token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20Upgradeable token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20PermitUpgradeable token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-IERC20PermitUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20PermitUpgradeable {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/math/SafeCast.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCastUpgradeable {\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        require(value <= type(uint248).max, \"SafeCast: value doesn't fit in 248 bits\");\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        require(value <= type(uint240).max, \"SafeCast: value doesn't fit in 240 bits\");\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        require(value <= type(uint232).max, \"SafeCast: value doesn't fit in 232 bits\");\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        require(value <= type(uint216).max, \"SafeCast: value doesn't fit in 216 bits\");\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        require(value <= type(uint208).max, \"SafeCast: value doesn't fit in 208 bits\");\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        require(value <= type(uint200).max, \"SafeCast: value doesn't fit in 200 bits\");\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        require(value <= type(uint192).max, \"SafeCast: value doesn't fit in 192 bits\");\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        require(value <= type(uint184).max, \"SafeCast: value doesn't fit in 184 bits\");\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        require(value <= type(uint176).max, \"SafeCast: value doesn't fit in 176 bits\");\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        require(value <= type(uint168).max, \"SafeCast: value doesn't fit in 168 bits\");\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        require(value <= type(uint160).max, \"SafeCast: value doesn't fit in 160 bits\");\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        require(value <= type(uint152).max, \"SafeCast: value doesn't fit in 152 bits\");\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        require(value <= type(uint144).max, \"SafeCast: value doesn't fit in 144 bits\");\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        require(value <= type(uint136).max, \"SafeCast: value doesn't fit in 136 bits\");\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        require(value <= type(uint120).max, \"SafeCast: value doesn't fit in 120 bits\");\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        require(value <= type(uint112).max, \"SafeCast: value doesn't fit in 112 bits\");\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        require(value <= type(uint104).max, \"SafeCast: value doesn't fit in 104 bits\");\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        require(value <= type(uint88).max, \"SafeCast: value doesn't fit in 88 bits\");\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        require(value <= type(uint80).max, \"SafeCast: value doesn't fit in 80 bits\");\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        require(value <= type(uint72).max, \"SafeCast: value doesn't fit in 72 bits\");\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        require(value <= type(uint56).max, \"SafeCast: value doesn't fit in 56 bits\");\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        require(value <= type(uint48).max, \"SafeCast: value doesn't fit in 48 bits\");\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        require(value <= type(uint40).max, \"SafeCast: value doesn't fit in 40 bits\");\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        require(value <= type(uint24).max, \"SafeCast: value doesn't fit in 24 bits\");\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     *\n     * _Available since v3.0._\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt248(int256 value) internal pure returns (int248) {\n        require(value >= type(int248).min && value <= type(int248).max, \"SafeCast: value doesn't fit in 248 bits\");\n        return int248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt240(int256 value) internal pure returns (int240) {\n        require(value >= type(int240).min && value <= type(int240).max, \"SafeCast: value doesn't fit in 240 bits\");\n        return int240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt232(int256 value) internal pure returns (int232) {\n        require(value >= type(int232).min && value <= type(int232).max, \"SafeCast: value doesn't fit in 232 bits\");\n        return int232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt224(int256 value) internal pure returns (int224) {\n        require(value >= type(int224).min && value <= type(int224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return int224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt216(int256 value) internal pure returns (int216) {\n        require(value >= type(int216).min && value <= type(int216).max, \"SafeCast: value doesn't fit in 216 bits\");\n        return int216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt208(int256 value) internal pure returns (int208) {\n        require(value >= type(int208).min && value <= type(int208).max, \"SafeCast: value doesn't fit in 208 bits\");\n        return int208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt200(int256 value) internal pure returns (int200) {\n        require(value >= type(int200).min && value <= type(int200).max, \"SafeCast: value doesn't fit in 200 bits\");\n        return int200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt192(int256 value) internal pure returns (int192) {\n        require(value >= type(int192).min && value <= type(int192).max, \"SafeCast: value doesn't fit in 192 bits\");\n        return int192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt184(int256 value) internal pure returns (int184) {\n        require(value >= type(int184).min && value <= type(int184).max, \"SafeCast: value doesn't fit in 184 bits\");\n        return int184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt176(int256 value) internal pure returns (int176) {\n        require(value >= type(int176).min && value <= type(int176).max, \"SafeCast: value doesn't fit in 176 bits\");\n        return int176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt168(int256 value) internal pure returns (int168) {\n        require(value >= type(int168).min && value <= type(int168).max, \"SafeCast: value doesn't fit in 168 bits\");\n        return int168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt160(int256 value) internal pure returns (int160) {\n        require(value >= type(int160).min && value <= type(int160).max, \"SafeCast: value doesn't fit in 160 bits\");\n        return int160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt152(int256 value) internal pure returns (int152) {\n        require(value >= type(int152).min && value <= type(int152).max, \"SafeCast: value doesn't fit in 152 bits\");\n        return int152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt144(int256 value) internal pure returns (int144) {\n        require(value >= type(int144).min && value <= type(int144).max, \"SafeCast: value doesn't fit in 144 bits\");\n        return int144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt136(int256 value) internal pure returns (int136) {\n        require(value >= type(int136).min && value <= type(int136).max, \"SafeCast: value doesn't fit in 136 bits\");\n        return int136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128) {\n        require(value >= type(int128).min && value <= type(int128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return int128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt120(int256 value) internal pure returns (int120) {\n        require(value >= type(int120).min && value <= type(int120).max, \"SafeCast: value doesn't fit in 120 bits\");\n        return int120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt112(int256 value) internal pure returns (int112) {\n        require(value >= type(int112).min && value <= type(int112).max, \"SafeCast: value doesn't fit in 112 bits\");\n        return int112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt104(int256 value) internal pure returns (int104) {\n        require(value >= type(int104).min && value <= type(int104).max, \"SafeCast: value doesn't fit in 104 bits\");\n        return int104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt96(int256 value) internal pure returns (int96) {\n        require(value >= type(int96).min && value <= type(int96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return int96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt88(int256 value) internal pure returns (int88) {\n        require(value >= type(int88).min && value <= type(int88).max, \"SafeCast: value doesn't fit in 88 bits\");\n        return int88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt80(int256 value) internal pure returns (int80) {\n        require(value >= type(int80).min && value <= type(int80).max, \"SafeCast: value doesn't fit in 80 bits\");\n        return int80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt72(int256 value) internal pure returns (int72) {\n        require(value >= type(int72).min && value <= type(int72).max, \"SafeCast: value doesn't fit in 72 bits\");\n        return int72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64) {\n        require(value >= type(int64).min && value <= type(int64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return int64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt56(int256 value) internal pure returns (int56) {\n        require(value >= type(int56).min && value <= type(int56).max, \"SafeCast: value doesn't fit in 56 bits\");\n        return int56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt48(int256 value) internal pure returns (int48) {\n        require(value >= type(int48).min && value <= type(int48).max, \"SafeCast: value doesn't fit in 48 bits\");\n        return int48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt40(int256 value) internal pure returns (int40) {\n        require(value >= type(int40).min && value <= type(int40).max, \"SafeCast: value doesn't fit in 40 bits\");\n        return int40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32) {\n        require(value >= type(int32).min && value <= type(int32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return int32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt24(int256 value) internal pure returns (int24) {\n        require(value >= type(int24).min && value <= type(int24).max, \"SafeCast: value doesn't fit in 24 bits\");\n        return int24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16) {\n        require(value >= type(int16).min && value <= type(int16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return int16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8) {\n        require(value >= type(int8).min && value <= type(int8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return int8(value);\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     *\n     * _Available since v3.0._\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary MathUpgradeable {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. It the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`.\n        // We also know that `k`, the position of the most significant bit, is such that `msb(a) = 2**k`.\n        // This gives `2**k < a <= 2**(k+1)` → `2**(k/2) <= sqrt(a) < 2 ** (k/2+1)`.\n        // Using an algorithm similar to the msb conmputation, we are able to compute `result = 2**(k/2)` which is a\n        // good first aproximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1;\n        uint256 x = a;\n        if (x >> 128 > 0) {\n            x >>= 128;\n            result <<= 64;\n        }\n        if (x >> 64 > 0) {\n            x >>= 64;\n            result <<= 32;\n        }\n        if (x >> 32 > 0) {\n            x >>= 32;\n            result <<= 16;\n        }\n        if (x >> 16 > 0) {\n            x >>= 16;\n            result <<= 8;\n        }\n        if (x >> 8 > 0) {\n            x >>= 8;\n            result <<= 4;\n        }\n        if (x >> 4 > 0) {\n            x >>= 4;\n            result <<= 2;\n        }\n        if (x >> 2 > 0) {\n            result <<= 1;\n        }\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = sqrt(a);\n        if (rounding == Rounding.Up && result * result < a) {\n            result += 1;\n        }\n        return result;\n    }\n}\n"
    },
    "@thesis/solidity-contracts/contracts/token/ERC20WithPermit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"./IERC20WithPermit.sol\";\nimport \"./IReceiveApproval.sol\";\n\n/// @title  ERC20WithPermit\n/// @notice Burnable ERC20 token with EIP2612 permit functionality. User can\n///         authorize a transfer of their token with a signature conforming\n///         EIP712 standard instead of an on-chain transaction from their\n///         address. Anyone can submit this signature on the user's behalf by\n///         calling the permit function, as specified in EIP2612 standard,\n///         paying gas fees, and possibly performing other actions in the same\n///         transaction.\ncontract ERC20WithPermit is IERC20WithPermit, Ownable {\n    /// @notice The amount of tokens owned by the given account.\n    mapping(address => uint256) public override balanceOf;\n\n    /// @notice The remaining number of tokens that spender will be\n    ///         allowed to spend on behalf of owner through `transferFrom` and\n    ///         `burnFrom`. This is zero by default.\n    mapping(address => mapping(address => uint256)) public override allowance;\n\n    /// @notice Returns the current nonce for EIP2612 permission for the\n    ///         provided token owner for a replay protection. Used to construct\n    ///         EIP2612 signature provided to `permit` function.\n    mapping(address => uint256) public override nonce;\n\n    uint256 public immutable cachedChainId;\n    bytes32 public immutable cachedDomainSeparator;\n\n    /// @notice Returns EIP2612 Permit message hash. Used to construct EIP2612\n    ///         signature provided to `permit` function.\n    bytes32 public constant override PERMIT_TYPEHASH =\n        keccak256(\n            \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n        );\n\n    /// @notice The amount of tokens in existence.\n    uint256 public override totalSupply;\n\n    /// @notice The name of the token.\n    string public override name;\n\n    /// @notice The symbol of the token.\n    string public override symbol;\n\n    /// @notice The decimals places of the token.\n    uint8 public constant override decimals = 18;\n\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n\n        cachedChainId = block.chainid;\n        cachedDomainSeparator = buildDomainSeparator();\n    }\n\n    /// @notice Moves `amount` tokens from the caller's account to `recipient`.\n    /// @return True if the operation succeeded, reverts otherwise.\n    /// @dev Requirements:\n    ///       - `recipient` cannot be the zero address,\n    ///       - the caller must have a balance of at least `amount`.\n    function transfer(address recipient, uint256 amount)\n        external\n        override\n        returns (bool)\n    {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    /// @notice Moves `amount` tokens from `spender` to `recipient` using the\n    ///         allowance mechanism. `amount` is then deducted from the caller's\n    ///         allowance unless the allowance was made for `type(uint256).max`.\n    /// @return True if the operation succeeded, reverts otherwise.\n    /// @dev Requirements:\n    ///      - `spender` and `recipient` cannot be the zero address,\n    ///      - `spender` must have a balance of at least `amount`,\n    ///      - the caller must have allowance for `spender`'s tokens of at least\n    ///        `amount`.\n    function transferFrom(\n        address spender,\n        address recipient,\n        uint256 amount\n    ) external override returns (bool) {\n        uint256 currentAllowance = allowance[spender][msg.sender];\n        if (currentAllowance != type(uint256).max) {\n            require(\n                currentAllowance >= amount,\n                \"Transfer amount exceeds allowance\"\n            );\n            _approve(spender, msg.sender, currentAllowance - amount);\n        }\n        _transfer(spender, recipient, amount);\n        return true;\n    }\n\n    /// @notice EIP2612 approval made with secp256k1 signature.\n    ///         Users can authorize a transfer of their tokens with a signature\n    ///         conforming EIP712 standard, rather than an on-chain transaction\n    ///         from their address. Anyone can submit this signature on the\n    ///         user's behalf by calling the permit function, paying gas fees,\n    ///         and possibly performing other actions in the same transaction.\n    /// @dev    The deadline argument can be set to `type(uint256).max to create\n    ///         permits that effectively never expire.  If the `amount` is set\n    ///         to `type(uint256).max` then `transferFrom` and `burnFrom` will\n    ///         not reduce an allowance.\n    function permit(\n        address owner,\n        address spender,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external override {\n        /* solhint-disable-next-line not-rely-on-time */\n        require(deadline >= block.timestamp, \"Permission expired\");\n\n        // Validate `s` and `v` values for a malleability concern described in EIP2.\n        // Only signatures with `s` value in the lower half of the secp256k1\n        // curve's order and `v` value of 27 or 28 are considered valid.\n        require(\n            uint256(s) <=\n                0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0,\n            \"Invalid signature 's' value\"\n        );\n        require(v == 27 || v == 28, \"Invalid signature 'v' value\");\n\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                DOMAIN_SEPARATOR(),\n                keccak256(\n                    abi.encode(\n                        PERMIT_TYPEHASH,\n                        owner,\n                        spender,\n                        amount,\n                        nonce[owner]++,\n                        deadline\n                    )\n                )\n            )\n        );\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        require(\n            recoveredAddress != address(0) && recoveredAddress == owner,\n            \"Invalid signature\"\n        );\n        _approve(owner, spender, amount);\n    }\n\n    /// @notice Creates `amount` tokens and assigns them to `account`,\n    ///         increasing the total supply.\n    /// @dev Requirements:\n    ///      - `recipient` cannot be the zero address.\n    function mint(address recipient, uint256 amount) external onlyOwner {\n        require(recipient != address(0), \"Mint to the zero address\");\n\n        beforeTokenTransfer(address(0), recipient, amount);\n\n        totalSupply += amount;\n        balanceOf[recipient] += amount;\n        emit Transfer(address(0), recipient, amount);\n    }\n\n    /// @notice Destroys `amount` tokens from the caller.\n    /// @dev Requirements:\n    ///       - the caller must have a balance of at least `amount`.\n    function burn(uint256 amount) external override {\n        _burn(msg.sender, amount);\n    }\n\n    /// @notice Destroys `amount` of tokens from `account` using the allowance\n    ///         mechanism. `amount` is then deducted from the caller's allowance\n    ///         unless the allowance was made for `type(uint256).max`.\n    /// @dev Requirements:\n    ///      - `account` must have a balance of at least `amount`,\n    ///      - the caller must have allowance for `account`'s tokens of at least\n    ///        `amount`.\n    function burnFrom(address account, uint256 amount) external override {\n        uint256 currentAllowance = allowance[account][msg.sender];\n        if (currentAllowance != type(uint256).max) {\n            require(\n                currentAllowance >= amount,\n                \"Burn amount exceeds allowance\"\n            );\n            _approve(account, msg.sender, currentAllowance - amount);\n        }\n        _burn(account, amount);\n    }\n\n    /// @notice Calls `receiveApproval` function on spender previously approving\n    ///         the spender to withdraw from the caller multiple times, up to\n    ///         the `amount` amount. If this function is called again, it\n    ///         overwrites the current allowance with `amount`. Reverts if the\n    ///         approval reverted or if `receiveApproval` call on the spender\n    ///         reverted.\n    /// @return True if both approval and `receiveApproval` calls succeeded.\n    /// @dev If the `amount` is set to `type(uint256).max` then\n    ///      `transferFrom` and `burnFrom` will not reduce an allowance.\n    function approveAndCall(\n        address spender,\n        uint256 amount,\n        bytes memory extraData\n    ) external override returns (bool) {\n        if (approve(spender, amount)) {\n            IReceiveApproval(spender).receiveApproval(\n                msg.sender,\n                amount,\n                address(this),\n                extraData\n            );\n            return true;\n        }\n        return false;\n    }\n\n    /// @notice Sets `amount` as the allowance of `spender` over the caller's\n    ///         tokens.\n    /// @return True if the operation succeeded.\n    /// @dev If the `amount` is set to `type(uint256).max` then\n    ///      `transferFrom` and `burnFrom` will not reduce an allowance.\n    ///      Beware that changing an allowance with this method brings the risk\n    ///      that someone may use both the old and the new allowance by\n    ///      unfortunate transaction ordering. One possible solution to mitigate\n    ///      this race condition is to first reduce the spender's allowance to 0\n    ///      and set the desired value afterwards:\n    ///      https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n    function approve(address spender, uint256 amount)\n        public\n        override\n        returns (bool)\n    {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    /// @notice Returns hash of EIP712 Domain struct with the token name as\n    ///         a signing domain and token contract as a verifying contract.\n    ///         Used to construct EIP2612 signature provided to `permit`\n    ///         function.\n    /* solhint-disable-next-line func-name-mixedcase */\n    function DOMAIN_SEPARATOR() public view override returns (bytes32) {\n        // As explained in EIP-2612, if the DOMAIN_SEPARATOR contains the\n        // chainId and is defined at contract deployment instead of\n        // reconstructed for every signature, there is a risk of possible replay\n        // attacks between chains in the event of a future chain split.\n        // To address this issue, we check the cached chain ID against the\n        // current one and in case they are different, we build domain separator\n        // from scratch.\n        if (block.chainid == cachedChainId) {\n            return cachedDomainSeparator;\n        } else {\n            return buildDomainSeparator();\n        }\n    }\n\n    /// @dev Hook that is called before any transfer of tokens. This includes\n    ///      minting and burning.\n    ///\n    /// Calling conditions:\n    /// - when `from` and `to` are both non-zero, `amount` of `from`'s tokens\n    ///   will be to transferred to `to`.\n    /// - when `from` is zero, `amount` tokens will be minted for `to`.\n    /// - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n    /// - `from` and `to` are never both zero.\n    // slither-disable-next-line dead-code\n    function beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    function _burn(address account, uint256 amount) internal {\n        uint256 currentBalance = balanceOf[account];\n        require(currentBalance >= amount, \"Burn amount exceeds balance\");\n\n        beforeTokenTransfer(account, address(0), amount);\n\n        balanceOf[account] = currentBalance - amount;\n        totalSupply -= amount;\n        emit Transfer(account, address(0), amount);\n    }\n\n    function _transfer(\n        address spender,\n        address recipient,\n        uint256 amount\n    ) private {\n        require(spender != address(0), \"Transfer from the zero address\");\n        require(recipient != address(0), \"Transfer to the zero address\");\n        require(recipient != address(this), \"Transfer to the token address\");\n\n        beforeTokenTransfer(spender, recipient, amount);\n\n        uint256 spenderBalance = balanceOf[spender];\n        require(spenderBalance >= amount, \"Transfer amount exceeds balance\");\n        balanceOf[spender] = spenderBalance - amount;\n        balanceOf[recipient] += amount;\n        emit Transfer(spender, recipient, amount);\n    }\n\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) private {\n        require(owner != address(0), \"Approve from the zero address\");\n        require(spender != address(0), \"Approve to the zero address\");\n        allowance[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function buildDomainSeparator() private view returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n                    ),\n                    keccak256(bytes(name)),\n                    keccak256(bytes(\"1\")),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/math/SafeCast.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        require(value <= type(uint248).max, \"SafeCast: value doesn't fit in 248 bits\");\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        require(value <= type(uint240).max, \"SafeCast: value doesn't fit in 240 bits\");\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        require(value <= type(uint232).max, \"SafeCast: value doesn't fit in 232 bits\");\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        require(value <= type(uint216).max, \"SafeCast: value doesn't fit in 216 bits\");\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        require(value <= type(uint208).max, \"SafeCast: value doesn't fit in 208 bits\");\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        require(value <= type(uint200).max, \"SafeCast: value doesn't fit in 200 bits\");\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        require(value <= type(uint192).max, \"SafeCast: value doesn't fit in 192 bits\");\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        require(value <= type(uint184).max, \"SafeCast: value doesn't fit in 184 bits\");\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        require(value <= type(uint176).max, \"SafeCast: value doesn't fit in 176 bits\");\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        require(value <= type(uint168).max, \"SafeCast: value doesn't fit in 168 bits\");\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        require(value <= type(uint160).max, \"SafeCast: value doesn't fit in 160 bits\");\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        require(value <= type(uint152).max, \"SafeCast: value doesn't fit in 152 bits\");\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        require(value <= type(uint144).max, \"SafeCast: value doesn't fit in 144 bits\");\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        require(value <= type(uint136).max, \"SafeCast: value doesn't fit in 136 bits\");\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        require(value <= type(uint120).max, \"SafeCast: value doesn't fit in 120 bits\");\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        require(value <= type(uint112).max, \"SafeCast: value doesn't fit in 112 bits\");\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        require(value <= type(uint104).max, \"SafeCast: value doesn't fit in 104 bits\");\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        require(value <= type(uint88).max, \"SafeCast: value doesn't fit in 88 bits\");\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        require(value <= type(uint80).max, \"SafeCast: value doesn't fit in 80 bits\");\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        require(value <= type(uint72).max, \"SafeCast: value doesn't fit in 72 bits\");\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        require(value <= type(uint56).max, \"SafeCast: value doesn't fit in 56 bits\");\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        require(value <= type(uint48).max, \"SafeCast: value doesn't fit in 48 bits\");\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        require(value <= type(uint40).max, \"SafeCast: value doesn't fit in 40 bits\");\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        require(value <= type(uint24).max, \"SafeCast: value doesn't fit in 24 bits\");\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     *\n     * _Available since v3.0._\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt248(int256 value) internal pure returns (int248) {\n        require(value >= type(int248).min && value <= type(int248).max, \"SafeCast: value doesn't fit in 248 bits\");\n        return int248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt240(int256 value) internal pure returns (int240) {\n        require(value >= type(int240).min && value <= type(int240).max, \"SafeCast: value doesn't fit in 240 bits\");\n        return int240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt232(int256 value) internal pure returns (int232) {\n        require(value >= type(int232).min && value <= type(int232).max, \"SafeCast: value doesn't fit in 232 bits\");\n        return int232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt224(int256 value) internal pure returns (int224) {\n        require(value >= type(int224).min && value <= type(int224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return int224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt216(int256 value) internal pure returns (int216) {\n        require(value >= type(int216).min && value <= type(int216).max, \"SafeCast: value doesn't fit in 216 bits\");\n        return int216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt208(int256 value) internal pure returns (int208) {\n        require(value >= type(int208).min && value <= type(int208).max, \"SafeCast: value doesn't fit in 208 bits\");\n        return int208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt200(int256 value) internal pure returns (int200) {\n        require(value >= type(int200).min && value <= type(int200).max, \"SafeCast: value doesn't fit in 200 bits\");\n        return int200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt192(int256 value) internal pure returns (int192) {\n        require(value >= type(int192).min && value <= type(int192).max, \"SafeCast: value doesn't fit in 192 bits\");\n        return int192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt184(int256 value) internal pure returns (int184) {\n        require(value >= type(int184).min && value <= type(int184).max, \"SafeCast: value doesn't fit in 184 bits\");\n        return int184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt176(int256 value) internal pure returns (int176) {\n        require(value >= type(int176).min && value <= type(int176).max, \"SafeCast: value doesn't fit in 176 bits\");\n        return int176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt168(int256 value) internal pure returns (int168) {\n        require(value >= type(int168).min && value <= type(int168).max, \"SafeCast: value doesn't fit in 168 bits\");\n        return int168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt160(int256 value) internal pure returns (int160) {\n        require(value >= type(int160).min && value <= type(int160).max, \"SafeCast: value doesn't fit in 160 bits\");\n        return int160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt152(int256 value) internal pure returns (int152) {\n        require(value >= type(int152).min && value <= type(int152).max, \"SafeCast: value doesn't fit in 152 bits\");\n        return int152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt144(int256 value) internal pure returns (int144) {\n        require(value >= type(int144).min && value <= type(int144).max, \"SafeCast: value doesn't fit in 144 bits\");\n        return int144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt136(int256 value) internal pure returns (int136) {\n        require(value >= type(int136).min && value <= type(int136).max, \"SafeCast: value doesn't fit in 136 bits\");\n        return int136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128) {\n        require(value >= type(int128).min && value <= type(int128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return int128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt120(int256 value) internal pure returns (int120) {\n        require(value >= type(int120).min && value <= type(int120).max, \"SafeCast: value doesn't fit in 120 bits\");\n        return int120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt112(int256 value) internal pure returns (int112) {\n        require(value >= type(int112).min && value <= type(int112).max, \"SafeCast: value doesn't fit in 112 bits\");\n        return int112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt104(int256 value) internal pure returns (int104) {\n        require(value >= type(int104).min && value <= type(int104).max, \"SafeCast: value doesn't fit in 104 bits\");\n        return int104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt96(int256 value) internal pure returns (int96) {\n        require(value >= type(int96).min && value <= type(int96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return int96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt88(int256 value) internal pure returns (int88) {\n        require(value >= type(int88).min && value <= type(int88).max, \"SafeCast: value doesn't fit in 88 bits\");\n        return int88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt80(int256 value) internal pure returns (int80) {\n        require(value >= type(int80).min && value <= type(int80).max, \"SafeCast: value doesn't fit in 80 bits\");\n        return int80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt72(int256 value) internal pure returns (int72) {\n        require(value >= type(int72).min && value <= type(int72).max, \"SafeCast: value doesn't fit in 72 bits\");\n        return int72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64) {\n        require(value >= type(int64).min && value <= type(int64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return int64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt56(int256 value) internal pure returns (int56) {\n        require(value >= type(int56).min && value <= type(int56).max, \"SafeCast: value doesn't fit in 56 bits\");\n        return int56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt48(int256 value) internal pure returns (int48) {\n        require(value >= type(int48).min && value <= type(int48).max, \"SafeCast: value doesn't fit in 48 bits\");\n        return int48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt40(int256 value) internal pure returns (int40) {\n        require(value >= type(int40).min && value <= type(int40).max, \"SafeCast: value doesn't fit in 40 bits\");\n        return int40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32) {\n        require(value >= type(int32).min && value <= type(int32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return int32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt24(int256 value) internal pure returns (int24) {\n        require(value >= type(int24).min && value <= type(int24).max, \"SafeCast: value doesn't fit in 24 bits\");\n        return int24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16) {\n        require(value >= type(int16).min && value <= type(int16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return int16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8) {\n        require(value >= type(int8).min && value <= type(int8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return int8(value);\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     *\n     * _Available since v3.0._\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../interfaces/draft-IERC1822.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967Upgrade {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\n        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");\n            } catch {\n                revert(\"ERC1967Upgrade: new implementation is not UUPS\");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/beacon/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC1822.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822Proxiable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/StorageSlot.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/ERC1967/ERC1967Proxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Proxy.sol\";\nimport \"./ERC1967Upgrade.sol\";\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\n * implementation behind the proxy.\n */\ncontract ERC1967Proxy is Proxy, ERC1967Upgrade {\n    /**\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n     *\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\n     * function call, and allows initializing the storage of the proxy like a Solidity constructor.\n     */\n    constructor(address _logic, bytes memory _data) payable {\n        _upgradeToAndCall(_logic, _data, false);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _implementation() internal view virtual override returns (address impl) {\n        return ERC1967Upgrade._getImplementation();\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/Proxy.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overridden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/transparent/TransparentUpgradeableProxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1967/ERC1967Proxy.sol\";\n\n/**\n * @dev This contract implements a proxy that is upgradeable by an admin.\n *\n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\n * clashing], which can potentially be used in an attack, this contract uses the\n * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\n * things that go hand in hand:\n *\n * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\n * that call matches one of the admin functions exposed by the proxy itself.\n * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the\n * implementation. If the admin tries to call a function on the implementation it will fail with an error that says\n * \"admin cannot fallback to proxy target\".\n *\n * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing\n * the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due\n * to sudden errors when trying to call a function from the proxy implementation.\n *\n * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,\n * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.\n */\ncontract TransparentUpgradeableProxy is ERC1967Proxy {\n    /**\n     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and\n     * optionally initialized with `_data` as explained in {ERC1967Proxy-constructor}.\n     */\n    constructor(\n        address _logic,\n        address admin_,\n        bytes memory _data\n    ) payable ERC1967Proxy(_logic, _data) {\n        _changeAdmin(admin_);\n    }\n\n    /**\n     * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.\n     */\n    modifier ifAdmin() {\n        if (msg.sender == _getAdmin()) {\n            _;\n        } else {\n            _fallback();\n        }\n    }\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function admin() external ifAdmin returns (address admin_) {\n        admin_ = _getAdmin();\n    }\n\n    /**\n     * @dev Returns the current implementation.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\n     */\n    function implementation() external ifAdmin returns (address implementation_) {\n        implementation_ = _implementation();\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-changeProxyAdmin}.\n     */\n    function changeAdmin(address newAdmin) external virtual ifAdmin {\n        _changeAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}.\n     */\n    function upgradeTo(address newImplementation) external ifAdmin {\n        _upgradeToAndCall(newImplementation, bytes(\"\"), false);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified\n     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the\n     * proxied contract.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}.\n     */\n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable ifAdmin {\n        _upgradeToAndCall(newImplementation, data, true);\n    }\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _admin() internal view virtual returns (address) {\n        return _getAdmin();\n    }\n\n    /**\n     * @dev Makes sure the admin cannot access the fallback function. See {Proxy-_beforeFallback}.\n     */\n    function _beforeFallback() internal virtual override {\n        require(msg.sender != _getAdmin(), \"TransparentUpgradeableProxy: admin cannot fallback to proxy target\");\n        super._beforeFallback();\n    }\n}\n"
    },
    "contracts/hardhat-dependency-compiler/@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport '@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol';\n"
    },
    "@keep-network/random-beacon/contracts/libraries/Callback.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n//\n// ▓▓▌ ▓▓ ▐▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▄\n// ▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n//   ▓▓▓▓▓▓    ▓▓▓▓▓▓▓▀    ▐▓▓▓▓▓▓    ▐▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n//   ▓▓▓▓▓▓▄▄▓▓▓▓▓▓▓▀      ▐▓▓▓▓▓▓▄▄▄▄         ▓▓▓▓▓▓▄▄▄▄         ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n//   ▓▓▓▓▓▓▓▓▓▓▓▓▓▀        ▐▓▓▓▓▓▓▓▓▓▓         ▓▓▓▓▓▓▓▓▓▓         ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n//   ▓▓▓▓▓▓▀▀▓▓▓▓▓▓▄       ▐▓▓▓▓▓▓▀▀▀▀         ▓▓▓▓▓▓▀▀▀▀         ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▀\n//   ▓▓▓▓▓▓   ▀▓▓▓▓▓▓▄     ▐▓▓▓▓▓▓     ▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌\n// ▓▓▓▓▓▓▓▓▓▓ █▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▓▓\n// ▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▓▓\n//\n//\n\npragma solidity 0.8.17;\n\nimport \"../api/IRandomBeaconConsumer.sol\";\n\n/// @title Callback library\n/// @dev Library for handling calls to random beacon consumer.\nlibrary Callback {\n    struct Data {\n        IRandomBeaconConsumer callbackContract;\n    }\n\n    event CallbackFailed(uint256 entry, uint256 entrySubmittedBlock);\n\n    /// @notice Sets callback contract.\n    /// @param callbackContract Callback contract.\n    function setCallbackContract(\n        Data storage self,\n        IRandomBeaconConsumer callbackContract\n    ) internal {\n        self.callbackContract = callbackContract;\n    }\n\n    /// @notice Executes consumer specified callback for the relay entry request.\n    /// @param entry The generated random number.\n    /// @param callbackGasLimit Callback gas limit.\n    function executeCallback(\n        Data storage self,\n        uint256 entry,\n        uint256 callbackGasLimit\n    ) internal {\n        if (address(self.callbackContract) != address(0)) {\n            try\n                self.callbackContract.__beaconCallback{gas: callbackGasLimit}(\n                    entry,\n                    block.number\n                )\n            {} catch {\n                // slither-disable-next-line reentrancy-events\n                emit CallbackFailed(entry, block.number);\n            }\n        }\n    }\n}\n"
    },
    "contracts/test/RandomBeaconStub.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity 0.8.17;\n\nimport \"@keep-network/random-beacon/contracts/api/IRandomBeacon.sol\";\nimport \"@keep-network/random-beacon/contracts/api/IRandomBeaconConsumer.sol\";\nimport \"@keep-network/random-beacon/contracts/libraries/Callback.sol\";\n\n// TODO: get rid of this contract; use RandomBeacon implementation instead.\n// This implementation is used to test callback's gas limit only. In most tests\n// we use smock's FakeContract of IRandomBeacon.\ncontract RandomBeaconStub is IRandomBeacon {\n    using Callback for Callback.Data;\n    Callback.Data internal callback;\n\n    // This value has to reflect the one set in the Random Beacon contract!\n    uint256 public callbackGasLimit = 64000;\n\n    event CallbackFailed(uint256 entry, uint256 entrySubmittedBlock);\n\n    function requestRelayEntry(IRandomBeaconConsumer _callbackContract)\n        external\n    {\n        callback.setCallbackContract(_callbackContract);\n    }\n\n    function submitRelayEntry(bytes calldata entry) external {\n        callback.executeCallback(uint256(keccak256(entry)), callbackGasLimit);\n    }\n}\n"
    },
    "contracts/hardhat-dependency-compiler/@keep-network/random-beacon/contracts/api/IRandomBeacon.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport '@keep-network/random-beacon/contracts/api/IRandomBeacon.sol';\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "storageLayout",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}